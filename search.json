[{"title":"ç”¨å¥½åˆ‡ç‰‡","url":"/2019/12/03/slice/","content":"`slice`æ˜¯`go`ä¸­æ¯”è¾ƒç®€å•çš„ä¸€ä¸ªæ•°æ®ç»“æ„äº†ï¼ˆå½“ç„¶ï¼Œ`string`æ›´åŠ ç®€å•ï¼‰ã€‚\n\nå…ˆçœ‹å…¶å®šä¹‰ï¼š\n```go\ntype slice struct {\n\tarray unsafe.Pointer  // å¯¹åº”åº•å±‚æ•°ç»„\n\tlen   int             // åˆ‡ç‰‡å½“å‰é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯å…·æœ‰çš„å…ƒç´ ä¸ªæ•°\n\tcap   int             // åº•å±‚æ•°ç»„çš„å®é™…é•¿åº¦\n}\n```\n\nå¯ä»¥çœ‹åˆ°åˆ‡ç‰‡å®é™…ä¸Šæœ‰3ä¸ªå­—æ®µï¼Œç¬¬ä¸€ä¸ªæ˜¯å…¶åº•å±‚æ•°ç»„ï¼Œç¬¬äºŒä¸ªæ˜¯å½“å‰å…·æœ‰çš„å…ƒç´ ä¸ªæ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸‹æ ‡`[0,len)`æ¥è®¿é—®ä»–ä»¬ï¼Œè€Œ`cap`å­—æ®µæ˜¯åº•å±‚æ•°ç»„çš„é•¿åº¦ã€‚\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨`make`æ¥åˆ›å»ºä¸€ä¸ªåˆ‡ç‰‡ï¼š\n```go\ns1 := make([]User,0,10)\n```\nè¡¨ç¤ºåˆ›å»ºä¸€ä¸ªé•¿åº¦æ˜¯0ï¼Œå®¹é‡æ˜¯10çš„Useråˆ‡ç‰‡ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•°`append`æ¥è¿½åŠ å…ƒç´ ï¼š\n```go\n s1 = append(s1, User{})\n```\nä½¿ç”¨`append`ï¼Œå¦‚æœåˆ‡ç‰‡çš„åº•å±‚æ•°ç»„å¦‚æœè¿˜æœ‰è¶³å¤Ÿçš„å®¹é‡ï¼Œåˆ™å¯ä»¥ç›´æ¥æ‰©å±•`len`å­—æ®µï¼Œå¦åˆ™ä¼šå‘ç”Ÿåˆ‡ç‰‡çš„æ‰©å®¹ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ[åˆ‡ç‰‡æ‰©å®¹](https://mcll.top/2019/02/26/slice%E6%89%A9%E5%AE%B9/)\nå› ä¸º`slice`æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼Œè€Œ`append`éœ€è¦æ›´æ”¹å†…éƒ¨çŠ¶æ€ï¼Œå› æ­¤ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„åˆ‡ç‰‡è¿”å›ã€‚\nå¦‚æœå‘ç”Ÿäº†æ‰©å®¹ç°åœ¨ï¼Œé‚£ä¹ˆæ–°è¿”å›çš„åˆ‡ç‰‡çš„åº•å±‚æ•°ç»„å’ŒåŸæ¥çš„åº•å±‚æ•°ç»„æ˜¯ä¸¤ä¸ªä¸åŒçš„æ•°ç»„ï¼Œå¦åˆ™ä¼šå…±äº«åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚\n\nå¦‚æœæˆ‘ä»¬éœ€è¦appendå¯ä»¥è¿”å›ä¸€ä¸ªæœ‰ç‹¬ç«‹åº•å±‚æ•°ç»„çš„åˆ‡ç‰‡ï¼Œåˆ™å¯ä»¥ï¼š\n```go\n\ts1 := make([]User, 10, 20)\n\ts2 :=append(s1[:len(s1):len(s1)], User{}) // s1[:len(s1):len(s1)]ä¼šåˆ›å»ºä¸€ä¸ªcapç­‰äºlençš„åˆ‡ç‰‡ï¼Œè¿™æ ·appendå°±ä¼šå‘ç”Ÿæ‰©å®¹\n```\n\n\nåœ¨å¹³å¸¸çš„å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä½¿ç”¨åˆ°åˆ‡ç‰‡çš„ä¸€ä¸ªåœºæ™¯æ˜¯æ•°æ®åº“åˆ†é¡µæŸ¥è¯¢ï¼Œåˆ›å»ºä¸€ä¸ª`slice`ï¼Œç„¶åæŠŠè¿”å›çš„ç»“æœé›†è£…åˆ°è¿™ä¸ª`slice`ä¸­ã€‚\n\né‚£ä¹ˆåœ¨è¿™ä¸ªåœºæ™¯ä¸‹æˆ‘ä»¬åº”è¯¥æ€ä¹ˆç”¨å¥½`slice`å‘¢ï¼Ÿ\n\né¦–å…ˆï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åˆ†é¡µæŸ¥è¯¢ï¼Œç»“æœé›†çš„å¤§å°æ˜¯å·²çŸ¥çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥**é¢„åˆ†é…åˆ‡ç‰‡å¤§å°**ã€‚\n\nç„¶åï¼Œæ˜¯ä½¿ç”¨`[]User`å¥½è¿˜æ˜¯`[]*User`å¥½å‘¢ï¼Ÿ\n\nå› ä¸º`go`çš„å†…å­˜ç®¡ç†ä¼šå°†`mspan`æŒ‰ç…§`sizeClass`è¿›è¡Œåˆ’åˆ†ï¼Œä»`8byte`åˆ°`32kb`ï¼Œå¹¶ä¸”ä¼šåœ¨`P`ä¸­ç¼“å­˜æ¯ä¸ªçº§åˆ«çš„`mspan`ï¼ˆæ¯ä¸ªPä¸­éƒ½æœ‰ä¸€ä¸ªmcacheï¼Œmcacheä¸­é’ˆå¯¹æ¯ç§sizeClassç¼“å­˜ä¸¤ä¸ªmspanï¼Œä¸€ä¸ªåªç”¨äºåˆ†é…ä¸éœ€è¦gcæ‰«æçš„å¯¹è±¡ï¼Œè¿™æ ·æ•´ä¸ªmspanä¸­çš„pageéƒ½ä¸éœ€è¦æ‰«æï¼‰ã€‚\n\nå› æ­¤ï¼Œå¦‚æœå¯¹è±¡çš„å¤§å°ä¸è¶…è¿‡`32kb`ï¼ˆå®é™…ä¸Šæˆ‘ä»¬å¾ˆå°‘ä¼šç”¨åˆ°é‚£ä¹ˆå¤§çš„å¯¹è±¡ï¼‰ï¼Œé‚£ä¹ˆå†…å­˜åˆ†é…çš„æ•ˆç‡ä¸åˆ†é…çš„å¤§å°å¹¶æ²¡æœ‰å¤šå¤§å…³ç³»ã€‚è€Œä¸”æœ¬èº«é¢‘ç¹çš„å†…å­˜åˆ†é…ä¹Ÿæ˜¯ä¸€ç§æ€§èƒ½æŸè€—ã€‚\n\nå› æ­¤ï¼Œ**æ¨èçš„æ˜¯ä½¿ç”¨`[]User`ç±»å‹**ã€‚è¿™æ ·åªä¼šåˆ†é…ä¸€æ¬¡å†…å­˜ã€‚è€Œå¦‚æœä½¿ç”¨`[]*User`ç±»å‹ï¼Œéœ€è¦åˆ†é…n+1æ¬¡ï¼Œåº•å±‚æ•°ç»„1æ¬¡åŠ ä¸Šnæ¬¡åˆ‡ç‰‡å…ƒç´ ã€‚\n\nç„¶è€Œï¼Œäº‹ä¸æ„¿è¿çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¼šä½¿ç”¨ç¬¬ä¸‰æ–¹`orm`æ¡†æ¶ï¼Œè¿™äº›æ¡†æ¶ä¸­ï¼Œä¼šå¾ªç¯çš„é€šè¿‡åå°„å»`new`å¯¹è±¡ï¼Œç„¶å`append`è¿›å»ã€‚\n","tags":["go"]},{"title":"redisé›†ç¾¤æ­å»º","url":"/2019/08/30/redisé›†ç¾¤æ­å»º/","content":"\n### ç¯å¢ƒå‡†å¤‡\n\nå‡†å¤‡å…­å°æœåŠ¡å™¨ï¼ˆç³»ç»Ÿä¸º`centos7`ï¼‰ï¼Œå¹¶ä¸”å®‰è£…makeã€gccç­‰å·¥å…·\n\næ¯ä¸ªèŠ‚ç‚¹éœ€è¦å¼€æ”¾æŒ‡å®šç«¯å£ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œå…³é—­é˜²ç«å¢™ï¼Œç”Ÿäº§ä¸è¦å…³é—­\n\n```sh\n$ service iptables stop # centos 6.x\n$ systemctl stop firewalld.service # centos 7.x\n```\n\n### ç¼–è¯‘redisæºç \nä¸‹è½½`redis`æºç ï¼ˆ`redis-5.0.3.tar.gz`)ï¼Œè§£å‹è¿›å…¥é¡¹ç›®ç›®å½•åï¼Œæ‰§è¡Œ`make MALLOC=libc`è¿›è¡Œç¼–è¯‘ï¼Œç¼–è¯‘å®Œæˆåï¼Œå¯ä»¥åœ¨`src/`ç›®å½•ä¸‹çœ‹åˆ°ç¼–è¯‘ç”Ÿæˆçš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶ã€‚\n\n### å¯åŠ¨rediså®ä¾‹\n\n##### ç¼–è¾‘é…ç½®æ–‡ä»¶\n\nä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªrediså®ä¾‹ï¼Œè¿™é‡Œæ¯å°åªé…ç½®ä¸¤ä¸ªå®ä¾‹ã€‚\n\nåœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šåˆ›å»ºç›®å½•`~/redis-cluster/7000`å’Œ`~/redis-cluster/7001`ä¸¤ä¸ªç›®å½•ï¼Œè¿™é‡Œ`7000`å’Œ`7001`è¡¨ç¤ºå®ä¾‹ç›‘å¬ç«¯å£ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹éœ€è¦éƒ¨ç½²å¤šä¸ªå®ä¾‹ï¼Œå°±åˆ›å»ºå¤šä¸ªä¸åŒç«¯å£å·çš„ç›®å½•ï¼Œç„¶ååœ¨æ¯ä¸ªç›®å½•ä¸‹åˆ›å»º`redis.conf`æ–‡ä»¶ï¼š\n\n```ini\n#ç«¯å£7000ï¼Œ7001\nport 7000\n\n#é»˜è®¤ipä¸º127.0.0.1ï¼Œéœ€è¦æ”¹ä¸ºå…¶ä»–èŠ‚ç‚¹æœºå™¨å¯è®¿é—®çš„ipï¼Œå¦åˆ™åˆ›å»ºé›†ç¾¤æ—¶æ— æ³•è®¿é—®å¯¹åº”çš„ç«¯å£ï¼Œæ— æ³•åˆ›å»ºé›†ç¾¤\nbind 0.0.0.0\n\n#redisåå°è¿è¡Œ\ndaemonize yes\n\n#pidfileæ–‡ä»¶ 7000å’Œ7001\npidfile /var/run/redis_7000.pid\n\n#å¼€å¯é›†ç¾¤\ncluster-enabled yes\n\n#é›†ç¾¤çš„é…ç½®ï¼Œé…ç½®æ–‡ä»¶é¦–æ¬¡å¯åŠ¨è‡ªåŠ¨ç”Ÿæˆ   \ncluster-config-file nodes_7000.conf\n\n#è¯·æ±‚è¶…æ—¶ï¼Œé»˜è®¤15ç§’ï¼Œå¯è‡ªè¡Œè®¾ç½® \ncluster-node-timeout 10100\n\n#aofæ—¥å¿—å¼€å¯ï¼Œæœ‰éœ€è¦å°±å¼€å¯ï¼Œå®ƒä¼šæ¯æ¬¡å†™æ“ä½œéƒ½è®°å½•ä¸€æ¡æ—¥å¿—\nappendonly yes\n\n#é»˜è®¤æ˜¯yesï¼Œåªè¦æœ‰ç»“ç‚¹å®•æœºå¯¼è‡´16384ä¸ªæ§½ä¸èƒ½éƒ½å¯ä»¥è®¿é—®åˆ°ï¼Œæ•´ä¸ªé›†ç¾¤å°±å…¨éƒ¨åœæ­¢æœåŠ¡ï¼Œæ‰€ä»¥ä¸€å®šè¦æ”¹ä¸ºno\ncluster-require-full-coverage no\n```\n\n##### å¯åŠ¨\nåœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œï¼š\n\n```sh\n$ for ((i=0;i<2;i++)); do redis-5.0.3/src/redis-server redis-cluster/700$i/redis.conf; done\n```\n\nå¯åŠ¨æ—¶ï¼Œä¼šä¸ºæ¯ä¸ªå®ä¾‹ç”Ÿæˆnodeidï¼Œå¹¶åœ¨å½“å‰ç›®å½•ç”Ÿæˆ`nodes_7000.conf`å’Œ`nodes_7001.conf`ä¸¤ä¸ªæ–‡ä»¶ã€‚\n\næ£€æŸ¥è¿›ç¨‹ï¼š\n\n```sh\n$ ps -ef | grep redis           //redisæ˜¯å¦å¯åŠ¨æˆåŠŸ\n$ netstat -tnlp | grep redis    //ç›‘å¬redisç«¯å£\n```\n\n### åˆ›å»ºé›†ç¾¤\nå®˜æ–¹æä¾›äº†`redis-trib.rb`æ¥åˆ›å»ºé›†ç¾¤ï¼Œå°±åœ¨`redis-5.0.3/src`ç›®å½•ä¸‹ï¼Œè¯¥è„šæœ¬åªéœ€è¦åœ¨é›†ç¾¤ä¸­ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ä¸Šæ‰§è¡Œä¸€æ¬¡å°±è¡Œã€‚\n\n##### å®‰è£…ruby\n\nå¦‚æœæ˜¯`redis-4.x.x`ç‰ˆæœ¬ï¼Œéœ€è¦å®‰è£…rubyã€‚\n\n```sh\n$ yum -y install ruby ruby-devel rubygems rpm-build\n```\n\nåœ¨`centos 7`ä¸­ï¼Œå®‰è£…çš„`ruby`ç‰ˆæœ¬è¿‡ä½ï¼Œä½¿ç”¨ä¸‹é¢æ–¹æ³•å®‰è£…ï¼š\n\n```sh\n$ yum install centos-release-scl-rh\n$ yum install rh-ruby23 -y\n$ scl  enable  rh-ruby23 bash\n$ ruby -v\n```\n\nå®‰è£…`redis`\n\n```sh\n$ gem install redis -v 3.3.5\n```\n\n##### é›†ç¾¤åˆ›å»º\n###### 5.0ä»¥ä¸‹\nå¦‚æœä¸º`5.0`ä»¥ä¸‹ç‰ˆæœ¬åˆ›å»ºé›†ç¾¤ï¼Œåˆ™æ‰§è¡Œå®˜æ–¹çš„rubyè„šæœ¬ï¼Œè¿™ä¸ªå·¥å…·èƒ½è‡ªåŠ¨æ£€æµ‹æœåŠ¡å™¨åˆ†é…masterå’Œslaveï¼Œ`--replicas`æŒ‡å®šæ¯ä¸ª`master`æœ‰å‡ ä¸ª`slave`\n\n```sh\n$ redis-4.0.12/src/redis-trib.rb create --replicas 3 10.0.1.50:7000 10.0.1.50:7001 10.0.1.19:7000 10.0.1.19:7001 10.0.1.133:7000 10.0.1.133:7001 10.0.1.169:7000 10.0.1.169:7001 10.0.1.210:7000 10.0.1.210:7001 10.0.1.127:7000 10.0.1.127:7001\n```\n\n###### 5.0ä¹‹å\né€šè¿‡`redis-cli`å®¢æˆ·ç«¯å·¥å…·æ¥åˆ›å»ºé›†ç¾¤ï¼Œ` --cluster-replicas 3`æŒ‡å®šæ¯ä¸ª`master`æœ‰3ä¸ª`slave`\n```sh\n$ redis-cli --cluster create --replicas 3 10.0.1.50:7000 10.0.1.50:7001 10.0.1.19:7000 10.0.1.19:7001 10.0.1.133:7000 10.0.1.133:7001 10.0.1.169:7000 10.0.1.169:7001 10.0.1.210:7000 10.0.1.210:7001 10.0.1.127:7000 10.0.1.127:7001 --cluster-replicas 3\n```\nè¾“å‡ºï¼š\n\n```\n>>> Performing hash slots allocation on 12 nodes...\nMaster[0] -> Slots 0 - 5460\nMaster[1] -> Slots 5461 - 10922\nMaster[2] -> Slots 10923 - 16383\nAdding replica 10.0.1.169:7000 to 10.0.1.50:7000\nAdding replica 10.0.1.210:7000 to 10.0.1.50:7000\nAdding replica 10.0.1.127:7000 to 10.0.1.50:7000\nAdding replica 10.0.1.50:7001 to 10.0.1.19:7000\nAdding replica 10.0.1.133:7001 to 10.0.1.19:7000\nAdding replica 10.0.1.169:7001 to 10.0.1.19:7000\nAdding replica 10.0.1.19:7001 to 10.0.1.133:7000\nAdding replica 10.0.1.210:7001 to 10.0.1.133:7000\nAdding replica 10.0.1.127:7001 to 10.0.1.133:7000\nM: 0c58af35acebf7988ff8eade95dfc9873eefe89c 10.0.1.50:7000\n   slots:[0-5460] (5461 slots) master\nS: da377f156086211e31170674caabb348bdb544e3 10.0.1.50:7001\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nM: 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d 10.0.1.19:7000\n   slots:[5461-10922] (5462 slots) master\nS: 903b50ea7ed1524f491d10b6f0be6e16dbfb8d40 10.0.1.19:7001\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nM: d0e3847c6b89140566a180e6a536c053b64ab901 10.0.1.133:7000\n   slots:[10923-16383] (5461 slots) master\nS: 0f8e1743c272e959cabea082002a2b3e4dc24dd0 10.0.1.133:7001\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nS: bf03f0fe45fc6d1850f3edfeec918193a61f0bba 10.0.1.169:7000\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: 047f288ddf0ec6a92042520aa4b812e531803aed 10.0.1.169:7001\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nS: 3c1a50c8e195f93d569abcb0bc77b2b8dfcef828 10.0.1.210:7000\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: 229ee5af18dab07d5b813acbc9f9eb17b9132dd7 10.0.1.210:7001\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nS: 2b7ad5f50a04b5df6015a06b2be3b07f0384c557 10.0.1.127:7000\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: 20172d062bd9b2a7d9c833ab1e653e25bbb6be03 10.0.1.127:7001\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nCan I set the above configuration? (type 'yes' to accept): \n```\nå¯ä»¥çœ‹åˆ°åˆ†é…äº†ä¸‰ä¸ªä¸»èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªä¸»èŠ‚ç‚¹åˆ†é…äº†ä¸‰ä¸ªä»èŠ‚ç‚¹ï¼Œè¾“å…¥`yes`å®Œæˆåˆ›å»ºï¼š\n```\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n..........\n>>> Performing Cluster Check (using node 10.0.1.50:7000)\nM: 0c58af35acebf7988ff8eade95dfc9873eefe89c 10.0.1.50:7000\n   slots:[0-5460] (5461 slots) master\n   3 additional replica(s)\nS: 0f8e1743c272e959cabea082002a2b3e4dc24dd0 10.0.1.133:7001\n   slots: (0 slots) slave\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nS: 229ee5af18dab07d5b813acbc9f9eb17b9132dd7 10.0.1.210:7001\n   slots: (0 slots) slave\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nS: 3c1a50c8e195f93d569abcb0bc77b2b8dfcef828 10.0.1.210:7000\n   slots: (0 slots) slave\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: 047f288ddf0ec6a92042520aa4b812e531803aed 10.0.1.169:7001\n   slots: (0 slots) slave\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nS: da377f156086211e31170674caabb348bdb544e3 10.0.1.50:7001\n   slots: (0 slots) slave\n   replicates 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d\nS: 2b7ad5f50a04b5df6015a06b2be3b07f0384c557 10.0.1.127:7000\n   slots: (0 slots) slave\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: bf03f0fe45fc6d1850f3edfeec918193a61f0bba 10.0.1.169:7000\n   slots: (0 slots) slave\n   replicates 0c58af35acebf7988ff8eade95dfc9873eefe89c\nS: 903b50ea7ed1524f491d10b6f0be6e16dbfb8d40 10.0.1.19:7001\n   slots: (0 slots) slave\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nS: 20172d062bd9b2a7d9c833ab1e653e25bbb6be03 10.0.1.127:7001\n   slots: (0 slots) slave\n   replicates d0e3847c6b89140566a180e6a536c053b64ab901\nM: d0e3847c6b89140566a180e6a536c053b64ab901 10.0.1.133:7000\n   slots:[10923-16383] (5461 slots) master\n   3 additional replica(s)\nM: 1e8cc5ef1f15cea04e94f48610a66ebc8a775d8d 10.0.1.19:7000\n   slots:[5461-10922] (5462 slots) master\n   3 additional replica(s)\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n### æµ‹è¯•é›†ç¾¤\n\nä½¿ç”¨å®¢æˆ·ç«¯å·¥å…·è¿æ¥`redis`é›†ç¾¤ï¼š\n\n```sh\n$ redis-5.0.3/src/redis-cli -c -p 7000\n```\n\nä¸Šé¢çš„`-c`è¡¨ç¤ºè¿æ¥é›†ç¾¤ï¼Œå½“è®¿é—®çš„`key`ä¸åœ¨å½“å‰èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥é‡å®šå‘åˆ°ç›®æ ‡èŠ‚ç‚¹è·å–æ•°æ®ï¼š\n\n```\n127.0.0.1:7001> get foo\n-> Redirected to slot [12182] located at 10.0.1.210:7001\n\"haha\"\n```\n\n### æŸ¥çœ‹é›†ç¾¤çŠ¶æ€\n```sh\n10.0.1.210:7001> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:12\ncluster_size:3\ncluster_current_epoch:13\ncluster_my_epoch:13\ncluster_stats_messages_ping_sent:4896\ncluster_stats_messages_pong_sent:3255\ncluster_stats_messages_meet_sent:2\ncluster_stats_messages_auth-req_sent:11\ncluster_stats_messages_sent:8164\ncluster_stats_messages_ping_received:3234\ncluster_stats_messages_pong_received:3382\ncluster_stats_messages_meet_received:9\ncluster_stats_messages_fail_received:2\ncluster_stats_messages_auth-ack_received:2\ncluster_stats_messages_received:6629\n```\n\n### redisé›†ç¾¤çš„æ•°æ®åˆ†ç‰‡\n> Redis Cluster does not use consistent hashing, but a different form of sharding where every key is conceptually part of what we call an **hash slot**.\n>\n> There are 16384 hash slots in Redis Cluster, and to compute what is the hash slot of a given key, we simply take the CRC16 of the key modulo 16384.\n>\n> Every node in a Redis Cluster is responsible for a subset of the hash slots, so for example you may have a cluster with 3 nodes, where:\n>\n> - Node A contains hash slots from 0 to 5500.\n> - Node B contains hash slots from 5501 to 11000.\n> - Node C contains hash slots from 11001 to 16383.\n\n\nredisé›†ç¾¤æ²¡æœ‰ä½¿ç”¨hashä¸€è‡´æ€§æ¥å­˜å‚¨æ¥å¯¹keyè¿›è¡Œåˆ†é…ï¼Œè€Œæ˜¯ä½¿ç”¨å“ˆå¸Œæ§½çš„æ¦‚å¿µã€‚\n\nåœ¨redisé›†ç¾¤ä¸­æœ‰16384ä¸ªå“ˆå¸Œæ§½ï¼Œé€šè¿‡ä½¿ç”¨`CRC16(key)%16384`æ¥ç¡®å®škeyå­˜å‚¨åœ¨å“ªä¸ªå“ˆå¸Œæ§½ä¸­ã€‚\nredisé›†ç¾¤ä¸­æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥åŒ…å«å¤šä¸ªå“ˆå¸Œæ§½ï¼Œæ¯”å¦‚ï¼š\n- èŠ‚ç‚¹Aï¼š0~5500\n- èŠ‚ç‚¹Bï¼š5501~11000\n- èŠ‚ç‚¹Cï¼š11001~16383\n\n##### mult-keys æ“ä½œ\n`redis`é›†ç¾¤å¯¹`mult-keys`å‘½ä»¤çš„æ”¯æŒæœ‰é™ï¼š\n\n**Redis Cluster supports multiple key operations as long as all the keys involved into a single command execution (or whole transaction, or Lua script execution) all belong to the same hash slot**.The user can force multiple keys to be part of the same hash slot by using a concept called *hash tags*.\n\nä¸€ä¸ªäº‹åŠ¡ã€luaè„šæœ¬æˆ–è€…`mult-keys`å‘½ä»¤åªèƒ½ä½¿ç”¨ä½äºåŒä¸€ä¸ªå“ˆå¸Œæ§½ä¸­çš„`key`ï¼Œä¹Ÿå°±æ˜¯ä¸æ”¯æŒä¸€ä¸ª`mult-keys`æ“ä½œä¸æ”¯æŒè·¨å“ˆå¸Œæ§½ã€‚å¯ä»¥ä½¿ç”¨`hash tags`æ¥å¼ºåˆ¶è®©éœ€è¦åœ¨ä¸€ä¸ªå‘½ä»¤ä¸­æ‰§è¡Œçš„æ•°æ®å­˜å‚¨åˆ°åŒä¸€ä¸ªå“ˆå¸Œæ§½ä¸­ã€‚\n\nåœ¨keyä¸­åŒ…å«`{TAG}`ï¼Œåˆ™ä¼šä½¿ç”¨`{}`ä¸­çš„`TAG`æ¥è®¡ç®—è¯¥keyæ‰€å±çš„å“ˆå¸Œæ§½ï¼Œæ¯”å¦‚`{foo}k1`å’Œ`{foo}k2`å°†ä¼šè¢«åˆ†é…åˆ°åŒä¸€ä¸ªå“ˆå¸Œæ§½ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨`lua`è„šæœ¬ä¸­åŒæ—¶ä½¿ç”¨`{foo}k1`å’Œ`{foo}k2`ã€‚å¦åˆ™å¦‚æœåœ¨ä¸€ä¸ª`lua`è„šæœ¬ä¸­åŒæ—¶è®¿é—®ä¸åŒå“ˆå¸Œæ§½ä¸­çš„keyå°†ä¼šæŠ¥é”™ã€‚\n\n### codis\nå’Œredisé›†ç¾¤ä¸åŒçš„æ˜¯ï¼Œ`Codis`é‡‡ç”¨ä¸€å±‚æ— çŠ¶æ€çš„`proxy`å±‚ï¼Œå°†åˆ†å¸ƒå¼é€»è¾‘å†™åœ¨`proxy`ä¸Šï¼Œåº•å±‚çš„å­˜å‚¨å¼•æ“è¿˜æ˜¯`Redis`æœ¬èº«ã€‚\n\n`codis`é€šè¿‡`presharding`æŠŠæ•°æ®åœ¨æ¦‚å¿µä¸Šåˆ†æˆ`1024`ä¸ª`slot`ï¼Œç„¶ååœ¨`proxy`ä¸­å°†ä¸åŒ`key`çš„è¯·æ±‚è½¬å‘åˆ°ä¸åŒçš„æœºå™¨ä¸Šï¼Œé€šè¿‡`crc32(key)%1024`è®¡ç®—`key`å¯¹åº”çš„`slot`ã€‚\n\n`Codis`æ”¯æŒçš„`MGET/MSET`æ— æ³•ä¿è¯åŸæœ¬å•ç‚¹æ—¶çš„åŸå­è¯­ä¹‰ã€‚ å› ä¸º`MSET`æ‰€å‚ä¸çš„`key`å¯èƒ½åˆ†ä¸åœ¨ä¸åŒçš„æœºå™¨ä¸Šï¼Œå¦‚æœéœ€è¦ä¿è¯åŸæ¥çš„è¯­ä¹‰ï¼Œä¹Ÿå°±æ˜¯è¦ä¹ˆä¸€èµ·æˆåŠŸï¼Œè¦ä¹ˆä¸€èµ·å¤±è´¥ï¼Œè¿™æ ·å°±æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼äº‹åŠ¡çš„é—®é¢˜ï¼Œå¯¹äº`Redis`æ¥è¯´ï¼Œå¹¶æ²¡æœ‰`WAL`æˆ–è€…å›æ»šè¿™ä¹ˆä¸€è¯´ï¼Œæ‰€ä»¥å³ä½¿æ˜¯ä¸€ä¸ªæœ€ç®€å•çš„äºŒé˜¶æ®µæäº¤çš„ç­–ç•¥éƒ½å¾ˆéš¾å®ç°ï¼Œè€Œä¸”å³ä½¿å®ç°äº†ï¼Œæ€§èƒ½ä¹Ÿæ²¡æœ‰ä¿è¯ã€‚æ‰€ä»¥åœ¨`Codis`ä¸­ä½¿ç”¨`MSET/MGET`å…¶å®å’Œä½ æœ¬åœ°å¼€ä¸ªå¤šçº¿ç¨‹`SET/GET`æ•ˆæœä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯ç”±`codis`å¸®å¿™å®ç°äº†ã€‚\n\n`codis`æ”¯æŒ`lua`è„šæœ¬ï¼Œä½†æ˜¯**ä»…ä»…æ˜¯è½¬å‘è€Œå·²ï¼Œå®ƒå¹¶ä¸ä¿è¯ä½ è„šæœ¬æ“ä½œçš„æ•°æ®æ˜¯å¦åœ¨æ­£ç¡®çš„èŠ‚ç‚¹ä¸Šã€‚**æ¯”å¦‚ï¼Œè„šæœ¬é‡Œæ¶‰åŠæ“ä½œå¤šä¸ª`key`ï¼Œ`Codis`èƒ½åšçš„å°±æ˜¯å°†è¿™ä¸ªè„šæœ¬åˆ†é…åˆ°å‚æ•°åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ª`key`çš„æœºå™¨ä¸Šæ‰§è¡Œã€‚æ‰€ä»¥è¿™ç§åœºæ™¯ä¸‹ï¼Œä½ éœ€è¦è‡ªå·±ä¿è¯ä½ çš„è„šæœ¬æ‰€ç”¨åˆ°çš„`key`åˆ†å¸ƒåœ¨åŒä¸€ä¸ªæœºå™¨ä¸Šï¼Œè¿™é‡Œå¯ä»¥é‡‡ç”¨`hashtag`çš„æ–¹å¼ã€‚","tags":["redis"]},{"title":"gops","url":"/2019/08/29/gops/","content":"[gops](https://github.com/google/gops): A tool to list and diagnose Go processes currently running on your system\n\n`gops`èƒ½å¤Ÿåˆ—å‡ºå½“å‰ç³»ç»Ÿä¸­è¿è¡Œçš„`go`è¿›ç¨‹ï¼Œå¹¶ä¸”èƒ½å¤Ÿå¸®åŠ©å¯¹æŒ‡å®š`go`è¿›ç¨‹è¿›è¡Œè¯Šæ–­ï¼Œæ˜¯`gopher`å¿…å¤‡å±…å®¶è‰¯å“ã€‚\n\n### å®‰è£…\n```sh\n$ go get -u github.com/google/gops\n```\n\n### ç®€å•ä½¿ç”¨\n##### æŸ¥çœ‹å‘½ä»¤å¸®åŠ©\n```sh\n$ gops \ngops is a tool to list and diagnose Go processes.\n\nUsage:\n  gops <cmd> <pid|addr> ...\n  gops <pid> # displays process info\n  gops help  # displays this help message\n\nCommands:\n  stack      Prints the stack trace.\n  gc         Runs the garbage collector and blocks until successful.\n  setgc\t     Sets the garbage collection target percentage.\n  memstats   Prints the allocation and garbage collection stats.\n  version    Prints the Go version used to build the program.\n  stats      Prints runtime stats.\n  trace      Runs the runtime tracer for 5 secs and launches \"go tool trace\".\n  pprof-heap Reads the heap profile and launches \"go tool pprof\".\n  pprof-cpu  Reads the CPU profile and launches \"go tool pprof\".\n\nAll commands require the agent running on the Go process.\n\"*\" indicates the process is running the agent.\n```\n\n##### æŸ¥çœ‹å½“å‰ç³»ç»Ÿçš„goè¿›ç¨‹\n```sh\n$ gops \n3348  3088  docker-containerd       go1.7.5  /usr/bin/docker-containerd\n3088  1     dockerd                 go1.7.5  /usr/bin/dockerd\n26504 3088  docker-proxy            go1.7.5  /usr/bin/docker-proxy\n26510 3348  docker-containerd-shim  go1.7.5  /usr/bin/docker-containerd-shim\n29311 18550 gops                    go1.11.2 /usr/local/bin/gops\n29135 27413 gops-demo             * go1.11.2 /home/vagrant/go/src/just-for-fun/gops/gops-demo\n```\nä¸Šé¢å„åˆ—çš„å«ä¹‰åˆ†åˆ«æ˜¯ï¼š\n```\npid ppid äºŒè¿›åˆ¶æ–‡ä»¶å goç¼–è¯‘ç‰ˆæœ¬ äºŒè¿›åˆ¶æ–‡ä»¶è·¯å¾„\n```\nè€Œåœ¨goç¼–è¯‘ç‰ˆæœ¬å‰é¢çš„ `*` è¡¨æ˜å½“å‰è¿›ç¨‹åŒ…å«äº†`agent`ã€‚\n\n##### æŸ¥çœ‹æŸä¸ªè¿›ç¨‹çš„ä¿¡æ¯\n```sh\n$ gops 29573\nparent PID:\t27413\nthreads:\t6\nmemory usage:\t0.278%\ncpu usage:\t0.012%\nusername:\troot\ncmd+args:\t./gops-demo\nelapsed time:\t02:49\nlocal/remote:\t:::5050 <-> :::0 (LISTEN)\nlocal/remote:\t:::8989 <-> :::0 (LISTEN)\n```\n\n### è¿›ç¨‹è¯Šæ–­\nä¸ºäº†èƒ½å¤Ÿä½¿ç”¨è¯Šæ–­åŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æˆ‘ä»¬çš„ç¨‹åºä»£ç ä¸­å¯åŠ¨ä¸€ä¸ª`agent`ï¼š\n```go\n// import \"github.com/google/gops/agent\"\n\nfunc main(){\n\terr := agent.Listen(agent.Options{\n\t\tAddr:            \":5050\", // agentç›‘å¬åœ°å€\n\t\tShutdownCleanup: false, // å¦‚æœtrueï¼Œä¼šç›‘å¬SIGINTä¿¡å·ï¼Œè‡ªåŠ¨å…³é—­agentå¹¶é€€å‡ºè¿›ç¨‹\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer agent.Close() // æ‰‹åŠ¨å…³é—­agent\n\n  .....\n\n}\n```\n\nåœ¨å¯åŠ¨`agent`çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šç›‘å¬çš„ç«¯å£ã€‚\n\nå¯åŠ¨äº†`agent`ä¹‹åï¼Œæˆ‘ä»¬åœ¨`gops`ä¸­å°±å¯ä»¥çœ‹åˆ°å¤šäº†ä¸€ä¸ª`*`ï¼š\n```sh\n$ gops\n29135 27413 gops-demo   * go1.11.2  /home/...\n```\n\nå¼€å¯äº†`agent`ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨`gops`å¼ºå¤§çš„è¯Šæ–­åŠŸèƒ½äº†\n```sh\n$ gops <cmd> <pid|agent-addr>\n```\n\nCommands:\n- `stack`ï¼šæŸ¥çœ‹è¿›ç¨‹æ ˆä¿¡æ¯\n- `gc`ï¼šæ‰‹åŠ¨è§¦å‘ä¸€æ¬¡`gc`ï¼Œå¹¶é˜»å¡ç­‰åˆ°`gc`ç»“æŸ\n- `setgc`ï¼šç›¸å½“äºè®¾ç½®`GOGC`å€¼\n- `memstats`ï¼šæŸ¥çœ‹è¿›ç¨‹çš„å†…å­˜ç»Ÿè®¡ä¿¡æ¯\n- `version`ï¼šæŸ¥çœ‹æ„å»ºäºŒè¿›åˆ¶ç¨‹åºçš„goç‰ˆæœ¬\n- `stats`ï¼šæŸ¥çœ‹runtimesçš„ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸»è¦æ˜¯goroutineæ•°é‡å’Œthreadæ•°é‡\n- `trace`ï¼šè¿è¡Œ5sçš„ runtime tracerï¼Œå¹¶å¯åŠ¨ä¸€ä¸ª`http server`ç”¨äºæŸ¥çœ‹traceä¿¡æ¯\n- `pprof-heap`ï¼šè¯»å–heapçš„profileå¹¶å¯åŠ¨`go tool pprof`\n- `pprof-cpu`ï¼šè¯»å–cpuä¹‹å30sçš„profileå¹¶å¯åŠ¨`go tool pprof`\n\n\n##### æŸ¥çœ‹å†…å­˜ç»Ÿè®¡\n```sh\n$ gops memstats 29573\nalloc: 196.65KB (201368 bytes) # å½“å‰åˆ†é…çš„å †å¯¹è±¡å­—èŠ‚æ•°ï¼ŒåŒä¸‹é¢çš„`heap-alloc`\ntotal-alloc: 3.64MB (3819256 bytes) # åˆ†é…çš„å †å¯¹è±¡å­—èŠ‚æ•°çš„ç´¯åŠ ç»Ÿè®¡\nsys: 68.69MB (72022264 bytes) # ä»æ“ä½œç³»ç»Ÿåˆ†é…çš„å†…å­˜çš„å­—èŠ‚æ•°ï¼Œæ˜¯ä¸‹é¢æ‰€æœ‰`Xsys`çš„ç´¯åŠ \nlookups: 0 # runtimeæ‰§è¡Œçš„æŒ‡é’ˆæŸ¥æ‰¾æ¬¡æ•°ç»Ÿè®¡ï¼Œä¸»è¦ç”¨äºruntimeå†…éƒ¨çš„debug\nmallocs: 2225 # å †å¯¹è±¡åˆ†é…æ¬¡æ•°ç»Ÿè®¡\nfrees: 1507 # å †å¯¹è±¡é‡Šæ”¾æ¬¡æ•°ç»Ÿè®¡\n# å †å†…å­˜ç»Ÿè®¡\nheap-alloc: 196.65KB (201368 bytes) # å½“å‰åˆ†é…çš„å †å¯¹è±¡çš„å­—èŠ‚æ•°\nheap-sys: 63.56MB (66650112 bytes) # ä»æ“ä½œç³»ç»Ÿåˆ†é…çš„å †å†…å­˜çš„å¤§å°\nheap-idle: 62.80MB (65847296 bytes) # ç©ºé—²çš„å †å†…å­˜å¤§å°ï¼ˆbytes in idle spansï¼‰\nheap-in-use: 784.00KB (802816 bytes) # å½“å‰æ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜å¤§å°ï¼ˆbytes in in-use spansï¼‰\nheap-released: 0 bytes # å½’è¿˜æ“ä½œç³»ç»Ÿçš„ç‰©ç†å†…å­˜å¤§å°\nheap-objects: 718 # å½“å‰åˆ†é…çš„å †å¯¹è±¡çš„æ•°é‡\n# ä¸‹é¢æ˜¯æ ˆå†…å­˜ç»Ÿè®¡\n# Stacks are not considered part of the heap, but the runtime can reuse a span of heap memory for stack memory, and vice-versa.\nstack-in-use: 448.00KB (458752 bytes) # bytes in stack spans  \nstack-sys: 448.00KB (458752 bytes) # bytes of stack memory obtained from the OS\n# ä¸‹é¢ä¸»è¦æ˜¯ runtime å†…éƒ¨æ•°æ®ç»“æ„åˆ†é…çš„å†…å­˜ä½¿ç”¨ç»Ÿè®¡\nstack-mspan-inuse: 15.29KB (15656 bytes) \nstack-mspan-sys: 32.00KB (32768 bytes)\nstack-mcache-inuse: 6.75KB (6912 bytes)\nstack-mcache-sys: 16.00KB (16384 bytes)\nother-sys: 1.00MB (1049066 bytes) # runtimeä¸­ä¸€äº›æ‚é¡¹æ•°æ®ç»“æ„çš„å†…å­˜å ç”¨\ngc-sys: 2.26MB (2371584 bytes) # åƒåœ¾æ”¶é›†å™¨å…ƒä¿¡æ¯çš„å†…å­˜å ç”¨\nnext-gc: when heap-alloc >= 4.00MB (4194304 bytes) # ä¸‹ä¸€æ¬¡è§¦å‘gcçš„æ—¶æœº\nlast-gc: 2019-08-29 16:42:26.502415917 +0800 CST # ä¸Šä¸€æ¬¡gcæ—¶é—´\ngc-pause-total: 946.946Âµs # gcæ€»çš„STWçš„æ—¶é—´\ngc-pause: 134271 #  æœ€åä¸€æ¬¡ gc çš„STWæ—¶é—´ï¼Œå•ä½ns\nnum-gc: 9 # gcæ¬¡æ•°\nenable-gc: true\ndebug-gc: fals # è¯¥å­—æ®µå½“å‰æœªä½¿ç”¨(go1.12.5)\n```\n**æ³¨æ„ï¼šè¯»å–å†…å­˜ç»Ÿè®¡ä¿¡æ¯çš„æ—¶å€™ä¼šè§¦å‘`STW`**ï¼š\n```go\n// runtime/mstas.go\nfunc ReadMemStats(m *MemStats) {\n\tstopTheWorld(\"read mem stats\")\n\n\tsystemstack(func() {\n\t\treadmemstats_m(m)\n\t})\n\n\tstartTheWorld()\n}\n```\n\n##### è®¾ç½®gcè§¦å‘ç™¾åˆ†æ¯”\né»˜è®¤`gc`çš„è§¦å‘ç™¾åˆ†æ¯”æ˜¯`100%`\n\næŸ¥çœ‹å½“å‰`gc`è§¦å‘æ¯”ä¾‹ï¼š\n```sh\n$ gops memstats 29573\n...\nnext-gc: when heap-alloc >= 4.00MB (4194304 bytes) \n...\n```\nå½“å‰çš„è§¦å‘æ—¶æœºæ˜¯ï¼Œ`heap-alloc`è¾¾åˆ°4MB\n\næ›´æ”¹`gc`è§¦å‘æ¯”ä¾‹ï¼š\n```sh\n$ gops setgc 29573 200\nNew GC percent set to 200. Previous value was 100.\n\n$ gops memstats 29573\n...\nnext-gc: when heap-alloc >= 8.00MB (8388608 bytes)\n...\n```\n`next-gc`çš„è®¡ç®—å…¬å¼ï¼š\n```go\nnext_gc = heap_marked + heap_marked*uint64(gcpercent)/100\n```\n`heap_marked`è¡¨ç¤ºåœ¨ä¸€æ¬¡`gc`ä¸­ï¼Œæ ‡è®°ä¸ºå­˜æ´»çš„æ€»å¯¹è±¡å¤§å°ï¼Œè€Œ`gcpercent`å°±æ˜¯æˆ‘ä»¬è®¾ç½®çš„`gc`è§¦å‘æ¯”ä¾‹ï¼Œé»˜è®¤ä¸º`100`ã€‚\n\n**æ³¨æ„ï¼šæ¯”å¦‚`next_gc`ä¸º`8MB`ï¼Œå¹¶ä¸æ˜¯çœŸçš„ç­‰åˆ°æ€»å…±åˆ†é…äº†8MBçš„å¯¹è±¡æ‰è§¦å‘GC**ã€‚`è¿™ä¸ªnext_gc`å®é™…ä¸Šæ˜¯`gc`åçš„`goal heap size`ã€‚ç°åœ¨çš„`gc`å®ç°ï¼Œå¯¹è±¡æ ‡è®°ä¸ä¸šåŠ¡ä»£ç ä¼šå¹¶å‘æ‰§è¡Œï¼Œè€Œåœ¨ä¸šåŠ¡ä»£ç ä¸­è¿˜ä¼šç”³è¯·åˆ†é…æ–°çš„å¯¹è±¡ã€‚å¦‚æœçœŸçš„ç­‰åˆ°`next_gc`æ‰è§¦å‘`gc`ï¼Œé‚£ä¹ˆç­‰åˆ°`gc`ç»“æŸä¹‹åï¼Œå½“å‰çš„`heap size`å¯èƒ½ä¼šå¤§äº`next_gc`ï¼Œå› æ­¤å®é™…ä¸Š`gc`çš„è§¦å‘ä¼šæå‰ä¸€ç‚¹ï¼ˆæœ‰å¦ä¸€ä¸ªå­—æ®µ`gc_trigger`æ¥å†³å®šï¼‰ã€‚\n\n### gopsçš„å®ç°\næˆ‘ä»¬ç¨‹åºä¸­çš„`agent`ï¼Œä¼šåœ¨æŒ‡å®šç«¯å£ç›‘å¬`tcp`è¿æ¥ï¼Œé€šæ—¶é»˜è®¤åœ¨`~/.config/gops`ç›®å½•ä¸‹ï¼Œä»¥è¿›ç¨‹å·ä¸ºæ–‡ä»¶ååˆ›å»ºä¸€ä¸ªè®°å½•ç›‘å¬ç«¯å£çš„æ–‡ä»¶ã€‚\nå½“æˆ‘ä»¬é€šè¿‡`gops`æ‰§è¡Œå‘½ä»¤æ—¶ï¼Œé¦–å…ˆä¼šè¯»å–è¯¥æ–‡ä»¶ï¼Œè·å–ç›‘å¬çš„ç«¯å£ï¼Œç„¶åä¸`agent`å»ºç«‹è¿æ¥ï¼Œå‘é€äº‹å…ˆå®šä¹‰å¥½çš„å‘½ä»¤ï¼š\n```go\nconst (\n  // StackTrace represents a command to print stack trace.\n  StackTrace = byte(0x1)\n\n  // GC runs the garbage collector.\n  GC = byte(0x2)\n\n  // MemStats reports memory stats.\n  MemStats = byte(0x3)\n\n  // Version prints the Go version.\n  Version = byte(0x4)\n\n  // HeapProfile starts `go tool pprof` with the current memory profile.\n  HeapProfile = byte(0x5)\n\n  // CPUProfile starts `go tool pprof` with the current CPU profile\n  CPUProfile = byte(0x6)\n\n  // Stats returns Go runtime statistics such as number of goroutines, GOMAXPROCS, and NumCPU.\n  Stats = byte(0x7)\n\n  // Trace starts the Go execution tracer, waits 5 seconds and launches the trace tool.\n  Trace = byte(0x8)\n\n  // BinaryDump returns running binary file.\n  BinaryDump = byte(0x9)\n\n  // SetGCPercent sets the garbage collection target percentage.\n  SetGCPercent = byte(0x10)\n)\n```\n`agent`æ”¶åˆ°`gops`çš„è¯·æ±‚åï¼Œè°ƒç”¨`runtime`çš„æ¥å£ï¼Œå¹¶å°†ç»“æœè¿”å›ã€‚\n","tags":["go - æ€§èƒ½ä¼˜åŒ–"]},{"title":"æ•°æ®åº“äº‹åŠ¡éš”ç¦»çº§åˆ«","url":"/2019/08/29/æ•°æ®åº“äº‹åŠ¡éš”ç¦»çº§åˆ«/","content":"\n### æ•°æ®åº“äº‹åŠ¡\næåˆ°äº‹åŠ¡å¤§å®¶è‚¯å®šéƒ½ä¸é™Œç”Ÿï¼Œæœ€å…¸å‹çš„ä¾‹å­å°±æ˜¯é“¶è¡Œè½¬è´¦ã€‚å¦‚æœä»è´¦æˆ·Aè½¬100å…ƒåˆ°è´¦æˆ·Bï¼Œä¸»è¦æ‰§è¡Œï¼š\n1. æ£€æŸ¥è´¦æˆ·Açš„ä½™é¢\n2. å¦‚æœä½™é¢è¶³å¤Ÿï¼Œä»è´¦æˆ·Açš„ä½™é¢æ‰£é™¤100å…ƒ\n3. è´¦æˆ·Bä½™é¢æ·»åŠ 100å…ƒ\n\næˆ‘ä»¬éœ€è¦ä¿è¯ä¸Šé¢3æ­¥åŠ¨ä½œæ˜¯ä¸å¯åˆ†å‰²çš„ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥åœ¨æ­¥éª¤1å’Œæ­¥éª¤2ä¸­é—´ï¼Œå†æ¬¡å‘èµ·å¦å¤–ä¸€ç¬”è½¬è´¦ï¼Œè¿™æ—¶å€™ä½™é¢è¿˜æ²¡æœ‰æ‰£é™¤ï¼Œæ£€æŸ¥ä»ç„¶é€šè¿‡ï¼Œè¿™æ ·é“¶è¡Œä¸å°±ä¹±å¥—äº†å—ï¼Ÿ\n\näº‹åŠ¡çš„æ¦‚å¿µï¼š\n> æ•°æ®åº“äº‹åŠ¡é€šå¸¸åŒ…å«äº†ä¸€ä¸ªåºåˆ—çš„å¯¹æ•°æ®åº“çš„è¯»/å†™æ“ä½œã€‚åŒ…å«æœ‰ä»¥ä¸‹ä¸¤ä¸ªç›®çš„ï¼š\n> - ä¸ºæ•°æ®åº“æ“ä½œåºåˆ—æä¾›äº†ä¸€ä¸ªä»å¤±è´¥ä¸­æ¢å¤åˆ°æ­£å¸¸çŠ¶æ€çš„æ–¹æ³•ï¼ŒåŒæ—¶æä¾›äº†æ•°æ®åº“å³ä½¿åœ¨å¼‚å¸¸çŠ¶æ€ä¸‹ä»èƒ½ä¿æŒä¸€è‡´æ€§çš„æ–¹æ³•ã€‚\n> - å½“å¤šä¸ªåº”ç”¨ç¨‹åºåœ¨å¹¶å‘è®¿é—®æ•°æ®åº“æ—¶ï¼Œå¯ä»¥åœ¨è¿™äº›åº”ç”¨ç¨‹åºä¹‹é—´æä¾›ä¸€ä¸ªéš”ç¦»æ–¹æ³•ï¼Œä»¥é˜²æ­¢å½¼æ­¤çš„æ“ä½œäº’ç›¸å¹²æ‰°ã€‚\n\nå¹¶éä»»æ„çš„å¯¹æ•°æ®åº“çš„æ“ä½œåºåˆ—éƒ½æ˜¯æ•°æ®åº“äº‹åŠ¡ã€‚æ•°æ®åº“äº‹åŠ¡æ‹¥æœ‰ä»¥ä¸‹å››ä¸ªç‰¹æ€§ï¼Œä¹ æƒ¯ä¸Šè¢«ç§°ä¹‹ä¸ºACIDç‰¹æ€§ï¼š\n- åŸå­æ€§ï¼ˆAtomicityï¼‰ï¼šäº‹åŠ¡ä½œä¸ºä¸€ä¸ªæ•´ä½“è¢«æ‰§è¡Œï¼ŒåŒ…å«åœ¨å…¶ä¸­çš„å¯¹æ•°æ®åº“çš„æ“ä½œè¦ä¹ˆå…¨éƒ¨è¢«æ‰§è¡Œï¼Œè¦ä¹ˆéƒ½ä¸æ‰§è¡Œ\n- ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ï¼šäº‹åŠ¡åº”ç¡®ä¿æ•°æ®åº“çš„çŠ¶æ€ä»ä¸€ä¸ªä¸€è‡´çŠ¶æ€è½¬å˜ä¸ºå¦ä¸€ä¸ªä¸€è‡´çŠ¶æ€ã€‚ä¸€è‡´çŠ¶æ€çš„å«ä¹‰æ˜¯æ•°æ®åº“ä¸­çš„æ•°æ®åº”æ»¡è¶³å®Œæ•´æ€§çº¦æŸ\n- éš”ç¦»æ€§ï¼ˆIsolationï¼‰ï¼šå¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œæ—¶ï¼Œä¸€ä¸ªäº‹åŠ¡çš„æ‰§è¡Œä¸åº”å½±å“å…¶ä»–äº‹åŠ¡çš„æ‰§è¡Œ\n- æŒä¹…æ€§ï¼ˆDurabilityï¼‰ï¼šå·²è¢«æäº¤çš„äº‹åŠ¡å¯¹æ•°æ®åº“çš„ä¿®æ”¹åº”è¯¥æ°¸ä¹…ä¿å­˜åœ¨æ•°æ®åº“ä¸­\n\nåŸå­æ€§ã€ä¸€è‡´æ€§å’ŒæŒä¹…æ€§éƒ½å¾ˆå¥½ç†è§£ï¼Œæˆ‘ä»¬ä»Šå¤©å°±æ¥è¯´è¯´æ˜¯éš”ç¦»æ€§ã€‚\n\n### äº‹åŠ¡çš„éš”ç¦»\nå½“æ•°æ®åº“ä¸Šæœ‰å¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œçš„æ—¶å€™ï¼Œå°±æœ‰å¯èƒ½å‡ºç°è„è¯»ï¼ˆdirty readï¼‰ã€ä¸å¯é‡å¤è¯»ï¼ˆnon-repeatable readï¼‰ã€å¹»è¯»ï¼ˆphantom readï¼‰çš„é—®é¢˜ï¼š\n- è„è¯»ï¼šè¯»å–åˆ°å…¶ä»–äº‹åŠ¡æœªæäº¤çš„æ•°æ®ï¼Œå› ä¸ºè¿™æ¡æ•°æ®ä¹‹åå¯èƒ½ä¼šè¢«å›æ»šï¼Œå¯¼è‡´æˆ‘ä»¬å½“å‰è¯»å–åˆ°çš„æ˜¯è„æ•°æ®\n- ä¸å¯é‡å¤è¯»ï¼šä¸€ä¸ªäº‹åŠ¡ä¸­å‰åè¯»å–åŒä¸€æ¡æ•°æ®ä¸¤æ¬¡ï¼Œå¹¶ä¸”åœ¨ä¸¤æ¬¡è¯»å–ä¸­é—´ï¼Œæœ‰å…¶ä»–äº‹åŠ¡ä¿®æ”¹äº†è¿™æ¡è®°å½•å¹¶æäº¤ï¼Œå¯¼è‡´å‰åä¸¤æ¬¡è¯»åˆ°çš„æ•°æ®ä¸ä¸€è‡´\n- å¹»è¯»ï¼šä¸€ä¸ªäº‹åŠ¡å‰åå¯¹åŒä¸€ä¸ªæ¡ä»¶è¿›è¡Œä¸¤æ¬¡æœç´¢ï¼Œå¹¶ä¸”ä¸¤æ¬¡æœç´¢ä¸­é—´æœ‰å…¶ä»–äº‹åŠ¡æäº¤äº†æ›´æ–°ï¼Œå¯¼è‡´å‰åä¸¤æ¬¡æŸ¥è¯¢å¾—åˆ°äº†ä¸åŒçš„ç»“æœé›†ã€‚ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œäº‹åŠ¡Aéœ€è¦æŸ¥è¯¢ä¸¤æ¬¡`id between 1 and 100`ï¼Œç¬¬ä¸€æ¬¡æŸ¥è¯¢å¾—åˆ°äº†10æ¡æ•°æ®ï¼Œè¿™æ—¶å€™å¦ä¸€ä¸ªäº‹åŠ¡æ’å…¥äº†ä¸€æ¡`id`åœ¨100ä»¥å†…çš„æ•°æ®ï¼Œäº‹åŠ¡Aå†æ¬¡æŸ¥è¯¢å°±ä¼šå¾—åˆ°11æ¡æ•°æ®ï¼Œæ¯”å‰ä¸€æ¬¡æŸ¥è¯¢å¤šäº†ä¸€æ¡ã€‚\n\næ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜å®é™…ä¸Šæ˜¯å¹¶å‘ç¼–ç¨‹å¾ˆå¸¸è§çš„é—®é¢˜ï¼Œå¦‚æœæ¯ä¸ªæ¯ä¸ªäº‹åŠ¡éƒ½ä¸²è¡Œæ‰§è¡Œï¼Œé‚£ä¹ˆä¸Šé¢çš„é—®é¢˜å°±éƒ½ä¸å­˜åœ¨äº†ã€‚\n\nåœ¨è§£å†³å¹¶å‘æ—¶çš„æ•°æ®ä¸ä¸€è‡´é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬å¸¸å¸¸é€šè¿‡åŠ é”æ¥è§£å†³ã€‚ä½†æ˜¯ï¼Œå¦‚æœåŠ é”ç²’åº¦å¤ªå¤§ï¼Œå¹¶å‘å°±ä¸Šä¸å»ã€‚\n\nSQLæ ‡å‡†æ ¹æ®å¹¶å‘äº‹åŠ¡å¯èƒ½å‡ºç°çš„é—®é¢˜ï¼Œå®šä¹‰äº†ä¸åŒçš„äº‹åŠ¡éš”ç¦»çº§åˆ«ï¼Œéš”ç¦»çº§åˆ«è¶Šé«˜ï¼Œä¸²è¡ŒåŒ–ç¨‹åº¦å°±è¶Šé«˜ï¼Œç¨‹åºçš„å¹¶å‘ä¹Ÿå°±è¶Šä½ï¼Œå› æ­¤å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦åœ¨äºŒè€…ä¹‹é—´å¯»æ‰¾ä¸€ä¸ªå¹³è¡¡ç‚¹ã€‚\n\nè¿™äº›éš”ç¦»çº§åˆ«ä»ä½åˆ°é«˜åˆ†åˆ«æ˜¯ï¼š\n- è¯»æœªæäº¤ï¼ˆRead Uncommittedï¼‰ï¼šå…è®¸è„è¯»ï¼Œä¸€ä¸ªäº‹åŠ¡è¿˜æ²¡æäº¤ï¼Œå®ƒçš„å˜æ›´å°±èƒ½è¢«åˆ«çš„äº‹åŠ¡çœ‹è§\n- è¯»å·²æäº¤ï¼ˆRead Committedï¼‰ï¼šè§£å†³äº†è„è¯»é—®é¢˜ï¼Œä¸€ä¸ªäº‹åŠ¡åªæœ‰æäº¤ä¹‹åï¼Œå®ƒçš„å˜æ›´æ‰èƒ½è¢«åˆ«çš„äº‹åŠ¡çœ‹åˆ°\n- å¯é‡å¤è¯»ï¼ˆRepeatable Readï¼‰ï¼šè§£å†³äº†ä¸å¯é‡å¤è¯»é—®é¢˜ï¼Œä¸€ä¸ªäº‹åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­çœ‹åˆ°çš„æ•°æ®æ€»æ˜¯è·Ÿè¿™ä¸ªäº‹åŠ¡åœ¨å¯åŠ¨æ—¶çœ‹åˆ°çš„æ•°æ®æ˜¯ä¸€è‡´çš„ã€‚`mysql`é€šè¿‡`mvcc`æä¾›å¿«ç…§è¯»ï¼Œä¸¤ä¸ªäº‹åŠ¡çš„è¯»å†™ä¸ä¼šå†²çªã€‚æ ‡å‡†ä¸­åªè¦æ±‚è¯¥çº§åˆ«è§£å†³ä¸å¯é‡å¤è¯»é—®é¢˜ï¼Œä½†æ˜¯ **`mysql`çš„å¯é‡å¤è¯»è¿˜é€šè¿‡`gap`é”è§£å†³äº†å¹»è¯»ç°è±¡**ã€‚è¯¥çº§åˆ«æ˜¯`mysql`çš„é»˜è®¤éš”ç¦»çº§åˆ«ã€‚\n- åºåˆ—åŒ–ï¼ˆSerializableï¼‰ï¼šè¿™æ˜¯æœ€é«˜çš„éš”ç¦»çº§åˆ«ï¼Œä¹Ÿæ˜¯SQLæ ‡å‡†ä¸­çš„é»˜è®¤éš”ç¦»çº§åˆ«ã€‚A serializable execution is defined to be an execution of the operations of concurrently executing SQL-transactions that produces the same effect as some serial execution of those same SQL-transactions. A serial execution is one in which each SQL-transaction executes to completion before the next SQL-transaction begins.\n\nä¸Šé¢çš„å››ç§éš”ç¦»çº§åˆ«ï¼Œä»ä¸Šå¾€ä¸‹ï¼Œéš”ç¦»æ€§è¶Šæ¥è¶Šé«˜ï¼Œä½†æ˜¯æ€§èƒ½ä¹Ÿè¶Šæ¥è¶Šå·®ã€‚æˆ‘ä»¬ä¸€èˆ¬ä¸ä¼šä½¿ç”¨åºåˆ—åŒ–éš”ç¦»çº§åˆ«ï¼Œè¯¥çº§åˆ«ä¼šå¯¼è‡´å¤§é‡çš„äº‹åŠ¡è¶…æ—¶ã€‚`mysql`é»˜è®¤çš„éš”ç¦»çº§åˆ«æ˜¯`å¯é‡å¤è¯»`çº§åˆ«ï¼Œå¹¶ä¸”è§£å†³äº†`å¹»è¯»`é—®é¢˜ã€‚æœ‰æ—¶å€™ï¼Œå½“æˆ‘ä»¬å¯¹æ•°æ®çš„éš”ç¦»æ€§è¦æ±‚ä¸é«˜çš„æ—¶å€™ï¼Œå¯ä»¥å°†å…¶ä¿®æ”¹ä¸º`è¯»å·²æäº¤`çº§åˆ«ã€‚\n\n`mysql`ä¸­æŸ¥çœ‹å½“å‰éš”ç¦»çº§åˆ«ï¼š\n```sh\n$ mysql -p$MYSQL_ROOT_PASSWORD\nmysql> show variables like 'transaction_isolation'; \n+-----------------------+-----------------+\n| Variable_name         | Value           |\n+-----------------------+-----------------+\n| transaction_isolation | REPEATABLE-READ |\n+-----------------------+-----------------+\n1 row in set (0.01 sec)\n```\n\nè®¾ç½®éš”ç¦»çº§åˆ«ï¼š\n```sh\nmysql> SET [global|session] transaction isolation LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE];\n```\n```sh\nmysql> SET session transaction isolation LEVEL READ COMMITTED; # å½“å‰sessionçº§åˆ«\nmysql> SET global transaction isolation LEVEL READ COMMITTED; # å…¨å±€ç”Ÿæ•ˆ\n```\n\n","tags":["mysql"]},{"title":"gopark","url":"/2019/08/26/gopark/","content":"\n åœ¨ go çš„ runtime åŒ…ä¸­ï¼Œç»å¸¸èƒ½å¤Ÿçœ‹åˆ°`gopark`æ–¹æ³•ï¼Œä»Šå¤©æ¥çœ‹ä¸€ä¸‹è¯¥å‡½æ•°çš„å®ç°å’Œä½œç”¨ã€‚\n\n\n\n### å®ç°\n\nè¯¥æ–¹æ³•çš„æºç åœ¨`runtime/proc.go`ï¼š\n\n```go\n// Puts the current goroutine into a waiting state and calls unlockf.\n// If unlockf returns false, the goroutine is resumed.\n// unlockf must not access this G's stack, as it may be moved between\n// the call to gopark and the call to unlockf.\n// Reason explains why the goroutine has been parked.\n// It is displayed in stack traces and heap dumps.\n// Reasons should be unique and descriptive.\n// Do not re-use reasons, add new ones.\n\n// æ ¹æ®ä¸Šé¢çš„æ³¨é‡Šï¼Œè¯¥æ–¹æ³•çš„ä½œç”¨æ˜¯å¦‚æœunlockfè¿”å›trueï¼Œåˆ™å°†å½“å‰åç¨‹æŒ‚èµ·ï¼Œå¦åˆ™ç»§ç»­æ‰§è¡Œ\n// \nfunc gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {\n\tif reason != waitReasonSleep {\n\t\tcheckTimeouts() // timeouts may expire while two goroutines keep the scheduler busy\n\t}\n\tmp := acquirem() // è¿™é‡Œè·å–å½“å‰çš„må¹¶åŠ é”\n\tgp := mp.curg // gpå³ä¸ºå½“å‰è¿è¡Œçš„åç¨‹\n\tstatus := readgstatus(gp)\n    // æ£€æŸ¥gpçš„çŠ¶æ€\n\tif status != _Grunning && status != _Gscanrunning {\n\t\tthrow(\"gopark: bad g status\")\n\t}\n    // å°† lock å’Œ unlockf åˆ†åˆ«ä¿å­˜åˆ° mp çš„ waitlock å’Œ waitunlockf\n    // unlockf éœ€è¦æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ˜¯ gpï¼Œå¦ä¸€ä¸ªå°±æ˜¯å‚æ•° lock\n\tmp.waitlock = lock\n\tmp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))\n    // ç­‰å¾…çš„åŸå› \n\tgp.waitreason = reason\n    // traceç›¸å…³\n\tmp.waittraceev = traceEv\n\tmp.waittraceskip = traceskip\n\treleasem(mp) // é‡Šæ”¾å½“å‰m\n\t// can't do anything that might move the G between Ms here.\n    // è¿™é‡Œmcallæ˜¯ä¸€ä¸ªç”±æ±‡ç¼–å®ç°çš„å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œç„¶ååˆ‡æ¢åˆ° m çš„ g0 æ ˆå»æ‰§è¡Œè¿™ä¸ªå‡½æ•°\n\tmcall(park_m) // åˆ‡æ¢åˆ° m çš„ g0 æ ˆæ‰§è¡Œ park_m æ–¹æ³•\n}\n```\n\n\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¦å…ˆæ¥çœ‹ä¸€ä¸‹ `park_m` è¿™ä¸ªæ–¹æ³•çš„å®ç°ï¼Œè¯¥æ–¹æ³•åŒæ ·ä½äº`runtime/proc.go`ï¼š\n\n```go\n// park continuation on g0.\n// mcall æ–¹æ³•ä¼šåˆ‡æ¢åˆ° m çš„ g0 è¿è¡Œï¼Œç„¶åæŠŠåŸå…ˆçš„ g ä½œä¸ºå‚æ•°ä¼ é€’ç»™è¯¥æ–¹æ³•\nfunc park_m(gp *g) {\n\t_g_ := getg() // è·å–å½“å‰è¿è¡Œçš„ gï¼Œè¿™æ—¶å€™è¿”å›çš„æ˜¯ g0\n\t\n    // å¦‚æœå¼€å¯äº†traceï¼Œåˆ™å‘é€traceäº‹ä»¶\n\tif trace.enabled {\n\t\ttraceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)\n\t}\n\n    // casæ›´æ–°gpçš„çŠ¶æ€\n\tcasgstatus(gp, _Grunning, _Gwaiting)\n    // è¿™é‡Œå°† gp ä¸ m åˆ†ç¦»\n\tdropg()\n    \n\t// è¿™é‡Œçš„ waitunlockf å°±æ˜¯ä¸Šé¢ gopark æ–¹æ³•çš„å‚æ•° unlockf\n    // åœ¨ gopark ä¸­åˆ†åˆ«å°†å…¶ä¸¤ä¸ªå‚æ•° unlockf å’Œ lock ä¿å­˜åˆ° m çš„ waitunlockf å’Œ waitlockå­—æ®µä¸­\n\tif _g_.m.waitunlockf != nil { // å¦‚æœ gopark æ–¹æ³•æ¥æ”¶çš„ unlockf ä¸ä¸ºç©º\n\t\tfn := *(*func(*g, unsafe.Pointer) bool)(unsafe.Pointer(&_g_.m.waitunlockf))\n\t\t// waitlock å°±æ˜¯ gopark æ–¹æ³•çš„å¦ä¸€ä¸ªå‚æ•° lock\n        ok := fn(gp, _g_.m.waitlock)\n        // åŠæ—¶æ¸…ç©º m çš„ä¸¤ä¸ªè¿™ä¸¤ä¸ªå­—æ®µ\n\t\t_g_.m.waitunlockf = nil \n\t\t_g_.m.waitlock = nil\n        // å¦‚æœ unlockf è¿”å›äº† falseï¼Œé‚£ä¹ˆä¸è¦æŒ‚èµ·ï¼Œç»§ç»­æ‰§è¡Œ\n\t\tif !ok {\n\t\t\tif trace.enabled {\n\t\t\t\ttraceGoUnpark(gp, 2)\n\t\t\t}\n            // çŠ¶æ€åˆ‡æ¢ä¸º _Grunnable\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n            // é‡æ–°ç»‘å®š gp åˆ°å½“å‰ mï¼Œå¹¶æ¢å¤æ‰§è¡Œï¼Œè¯¥æ–¹æ³•ä¸ä¼šè¿”å›\n\t\t\texecute(gp, true) // Schedule it back, never returns.\n\t\t}\n\t}\n    // unlockf ä¸º nil æˆ–è€…è¿”å› trueï¼Œåˆ™æŒ‚èµ· gpï¼Œå¹¶é‡æ–°è°ƒåº¦æ–°çš„ g åˆ°å½“å‰ m\n\tschedule() // åç¨‹è°ƒåº¦ï¼Œè¯¥æ–¹æ³•ä¹Ÿä¸ä¼šè¿”å›\n}\n```\n\næ ¹æ®ä¸Šé¢çš„ `park_m`çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“ `mcall` æ–¹æ³•éœ€è¦ä¿å­˜ `gp` çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¹¶åˆ‡æ¢åˆ° `g0` æ ˆï¼Œä»¥ `gp` ä½œä¸ºå‚æ•°è°ƒç”¨ `park_m`ã€‚\n\n\n\nåœ¨çœ‹ `mcall` æ–¹æ³•çš„å®ç°ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ `g` ä¸­çš„ å‡ ä¸ªå­—æ®µï¼Œ`g`çš„å®ç°åœ¨`runtime/runtime2.go`ï¼š\n\n```go\ntype g struct {\n\tstack       stack   // å½“å‰gçš„æ ˆä¿¡æ¯\n \t...\n\tm              *m      // å½“å‰gç»‘å®šçš„m\n\tsched          gobuf   // ä¿å­˜gçš„è¿è¡Œä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä¸‹æ¬¡è°ƒåº¦æ—¶ä»å“ªé‡Œå¼€å§‹æ‰§è¡Œ\n\t... \n}\n\ntype stack struct {\n\tlo uintptr // æ ˆåº•\n\thi uintptr // æ ˆé¡¶\n}\n\ntype gobuf struct {\n\tsp   uintptr \t // æ ˆé¡¶\n\tpc   uintptr\t // pcï¼Œæ¢å¤ç‚¹\n\tg    guintptr    // å¯¹åº”çš„gæŒ‡é’ˆå€¼\n\tctxt unsafe.Pointer\n\tret  sys.Uintreg\n\tlr   uintptr\n\tbp   uintptr     // æ ˆåº•\n}\n```\n\n\n\næ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ `mcall` åœ¨ `amd64` ä½“ç³»ä¸‹çš„å®ç°ï¼Œæºä»£ç ä½äº `runtime/asm_amd64.s`ï¼š\n\n```assembly\n// func mcall(fn func(*g))\n// Switch to m->g0's stack, call fn(g).\n// Fn must never return. It should gogo(&g->sched)\n// to keep running g.\n// \n// æ ¹æ®æ³¨é‡Šï¼Œmcall åˆ‡æ¢åˆ° g0 æ ˆè°ƒç”¨ fn(g), fn ä¸èƒ½è¿”å›\nTEXT runtimeÂ·mcall(SB), NOSPLIT, $0-8 // æ ˆå¸§å¤§å°ä¸º0ï¼Œè¿™ç§æƒ…å†µ0(SP)ä¿å­˜çš„ä¸ºè¿”å›åœ°å€\n\t// å…³äºgoçš„å‡½æ•°è°ƒç”¨æ ˆçš„å¸ƒå±€ï¼Œå¯ä»¥å‚è€ƒ http://mcll.top/2019/04/29/goå‡½æ•°æ ˆå¸ƒå±€\n\t\n\tMOVQ\tfn+0(FP), DI // å°†mcallçš„å‚æ•°ä¿å­˜åˆ°DIå¯„å­˜å™¨ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªfuncvalæŒ‡é’ˆ\n\t// å…³äºfuncvalçš„ä»‹ç»ï¼Œå¯ä»¥å‚è€ƒhttp://mcll.top/2019/03/06/goä¸­çš„çŒ´å­è¡¥ä¸\n\n\tget_tls(CX)  // å°†TLSä¿å­˜åˆ°CXå¯„å­˜å™¨ï¼ŒTLSæ˜¯ä¸€ä¸ªä¼ªå¯„å­˜å™¨ï¼Œget_tlsæ˜¯ä¸€ä¸ªå®ï¼Œä¸€ç›´æ²¡æ‰¾åˆ°å…¶å®šä¹‰ğŸ˜“\n\tMOVQ\tg(CX), AX\t// ä¿å­˜å½“å‰gåˆ°AXå¯„å­˜å™¨ä¸­\n\tMOVQ\t0(SP), BX\t// 0(SP)ä¿å­˜è¿”å›åœ°å€ï¼Œä¹Ÿå°±æ˜¯mcallè°ƒç”¨è€…çš„PC\n\tMOVQ\tBX, (g_sched+gobuf_pc)(AX) // ä¿å­˜åˆ°g.sched.pcå­—æ®µä¸­\n\tLEAQ\tfn+0(FP), BX\t// fn+0(FP)ä¹Ÿå°±æ˜¯è°ƒç”¨è€…çš„SP\n\tMOVQ\tBX, (g_sched+gobuf_sp)(AX) // ä¿å­˜åˆ°g.sched.spå­—æ®µä¸­\n\tMOVQ\tAX, (g_sched+gobuf_g)(AX) // ä¿å­˜å½“å‰gåˆ°g.sched.gä¸­\n\tMOVQ\tBP, (g_sched+gobuf_bp)(AX) // å› ä¸ºæ ˆå¸§ä¸º0ï¼ŒBPå°±æ˜¯è°ƒç”¨è€…çš„BPï¼Œä¿å­˜åˆ°g.sched.bp\n\n\t// switch to m->g0 & its stack, call fn\n\tMOVQ\tg(CX), BX  // å°†åŸæ¥çš„gä¿å­˜åˆ°BX\n\tMOVQ\tg_m(BX), BX  // è·å–g.mï¼Œè¿˜æ˜¯ä¿å­˜åˆ°BX\n\tMOVQ\tm_g0(BX), SI // ä¿å­˜g0åˆ°SI\n\tCMPQ\tSI, AX\t// AXå¯„å­˜å™¨ä¸Šé¢å·²ç»è®¾ç½®ä¸ºåŸæ¥çš„gäº†ï¼Œç¦æ­¢åœ¨g0æ ˆä¸Šè°ƒç”¨mcallï¼Œè¿™é‡Œè¦åˆ¤æ–­ä¸€ä¸‹\n\tJNE\t3(PC) // å¦‚æœåŸæ¥çš„gä¸æ˜¯g0ï¼Œè·³è½¬åˆ°pc+3çš„ä½ç½®æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯ä»è¿™é‡Œå¾€ä¸‹ç¬¬ä¸‰æ¡æŒ‡ä»¤\n\tMOVQ\t$runtimeÂ·badmcall(SB), AX // å¦‚æœåœ¨g0ä¸Šè°ƒç”¨mcallï¼Œç›´æ¥panic\n\tJMP\tAX // è·³è½¬åˆ° badmcall æ–¹æ³•ï¼Œæœ€ç»ˆä¼španic\n\tMOVQ\tSI, g(CX)\t// å°†g0è®¾ç½®åˆ°TLSä¸­\n\tMOVQ\t(g_sched+gobuf_sp)(SI), SP\t// æ¢å¤g0çš„SPå¯„å­˜å™¨\n\tPUSHQ\tAX\t// AXä¿å­˜åŸæ¥çš„gï¼Œå…¥æ ˆ\n\tMOVQ\tDI, DX // ä¸Šé¢è¯´è¿‡ï¼ŒDIä¿å­˜äº†è¦è°ƒç”¨å‡½æ•°çš„funcvalå€¼ï¼Œå°†å…¶ä¿å­˜çš„DXå¯„å­˜å™¨ï¼ŒDXå¯„å­˜å™¨ä¸é—­åŒ…å®ç°æœ‰å…³\n\tMOVQ\t0(DI), DI // å°†è¦è°ƒç”¨å‡½æ•°çš„å…¥å£åœ°å€ä¿å­˜åˆ°DIå¯„å­˜å™¨\n\tCALL\tDI // è°ƒç”¨è¯¥å‡½æ•°ï¼Œå‚æ•°å°±æ˜¯åˆšåˆšå…¥æ ˆçš„AXä¸­çš„å€¼ï¼Œä¹Ÿå°±æ˜¯åŸæ¥çš„gï¼Œè¯¥å‡½æ•°ç¦æ­¢è¿”å›\n\tPOPQ\tAX // å‡ºæ ˆ\n\tMOVQ\t$runtimeÂ·badmcall2(SB), AX // å¦‚æœè°ƒç”¨å‡½æ•°è¿”å›äº†ï¼Œpanic\n\tJMP\tAX \n\tRET\n```\n\n\n\n### ä½¿ç”¨\n\n`runtime`åŒ…ä¸­æœ‰å¾ˆå¤šç”¨åˆ°`gopark`æ–¹æ³•çš„åœ°æ–¹ï¼Œè¿™é‡Œä¸¾ä¾‹å‡ ä¸ª\n\n\n\n##### åœºæ™¯ä¸€ï¼šå†™ç©º channel\n\n```go\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n\t// æ ¹æ®goè¯­ä¹‰ï¼Œå‘ä¸€ä¸ªnilçš„channelä¼šå¯¼è‡´é˜»å¡\n    if c == nil {\n     \t// ä¸€èˆ¬blockéƒ½æ˜¯true\n\t\tif !block {\n\t\t\treturn false\n\t\t}\n        \n        // æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œunlockfä¸ºnilä¼šæŒ‚èµ·å½“å‰åç¨‹\n\t\tgopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)\n\t\tthrow(\"unreachable\")\n\t}\n\n    ...\n}\n```\n\n\n\n##### åœºæ™¯äºŒï¼šselect\n\n`selectgo`å®ç°äº†`select`è¯­å¥çš„åŠŸèƒ½\n\n```go\nfunc selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {\n\t...\n    // selparkcommitä¼šé‡Šæ”¾æ‰€æœ‰caseçš„é”ï¼Œå¹¶é˜»å¡ç­‰å¾…å½“å‰gï¼Œç­‰å¾…æœ‰caseè¢«è§¦å‘\n    gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)\n    ...\n}\n```\n\n","tags":["go - runtime"]},{"title":"ç³»ç»Ÿå¹³å‡è´Ÿè½½","url":"/2019/08/25/load-average/","content":"\nå½“æˆ‘ä»¬å‘ç°ç³»ç»Ÿå˜æ…¢æ—¶ï¼Œé€šå¸¸ä¼šæ‰§è¡Œ`top`æˆ–è€…`uptime`å‘½ä»¤ï¼Œæ¥äº†è§£ç³»ç»Ÿçš„è´Ÿè½½æƒ…å†µï¼Œæ¯”å¦‚ï¼š\n\n```sh\n$ uptime\n 07:48:28 up 8 min,  1 user,  load average: 0.00, 0.08, 0.07\n```\n\n`uptime`å‘½ä»¤è¾“å‡ºçš„ä¿¡æ¯åˆ†åˆ«æ˜¯ï¼šå½“å‰ç³»ç»Ÿæ—¶é—´ï¼Œç³»ç»Ÿè¿è¡Œæ—¶é—´ï¼Œå½“å‰ç™»é™†ç”¨æˆ·æ•°ï¼Œä»¥åŠ**æœ€è¿‘1åˆ†é’Ÿã€æœ€è¿‘5åˆ†é’Ÿå’Œæœ€è¿‘15åˆ†é’Ÿçš„ç³»ç»Ÿè¯„ä»·è´Ÿè½½æƒ…å†µ**\n\n\n\n### ä»€ä¹ˆæ˜¯ç³»ç»Ÿå¹³å‡è´Ÿè½½ï¼Ÿ\n\næˆ‘ä»¬å¯ä»¥é€šè¿‡`man uptime`æŸ¥çœ‹å‘½ä»¤å¸®åŠ©æ‰‹å†Œï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ä»‹ç»ä»€ä¹ˆæ˜¯ç³»ç»Ÿçš„å¹³å‡è´Ÿè½½ï¼š\n\n> â€‹    System load averages is the average number of processes that are either in a runnable or uninterruptable state.  A process in a runnable state is either using the CPU or waiting to use  the  CPU.   A process  in  uninterruptable state is waiting for some I/O access, eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.\n\nç®€å•æ¥è¯´ï¼Œå¹³å‡è´Ÿè½½å°±æ˜¯æŒ‡å•ä½æ—¶é—´å†…ï¼Œç³»ç»Ÿå¤„äº**å¯è¿è¡ŒçŠ¶æ€**å’Œ**ä¸å¯ä¸­æ–­çŠ¶æ€**çš„å¹³å‡è¿›ç¨‹æ•°ï¼Œä¹Ÿå°±æ˜¯**å¹³å‡æ´»è·ƒè¿›ç¨‹æ•°**ã€‚è¿™é‡Œçš„**å¯è¿è¡ŒçŠ¶æ€**åŒ…æ‹¬**æ­£åœ¨ä½¿ç”¨CPUï¼ˆRunningçŠ¶æ€ï¼‰**å’Œ**æ­£åœ¨ç­‰å¾…CPUï¼ˆRunnableçŠ¶æ€ï¼‰**ã€‚è€Œ**ä¸å¯ä¸­æ–­çŠ¶æ€**æ˜¯æŒ‡è¿›ç¨‹è¿è¡Œåœ¨å†…æ ¸æ€ï¼Œæ­£åœ¨ç­‰å¾…`I/O`ï¼Œ**ä¸ºäº†èƒ½å¤Ÿå°½å¿«å®Œæˆ`I/O`æ“ä½œ**ï¼Œç­‰å¾…`I/O`çš„è¿›ç¨‹ä¸ä¼šè¢«ä¸­æ–­ã€‚\n\né€šè¿‡`ps`å‘½ä»¤æŸ¥çœ‹è¿›ç¨‹æ—¶ï¼Œå¯è¿è¡ŒçŠ¶æ€å¯¹åº”çš„æ˜¯`R`ï¼Œè€Œä¸å¯ä¸­æ–­çŠ¶æ€å¯¹åº”çš„æ˜¯`D`ã€‚\n\nç³»ç»Ÿå¹³å‡è´Ÿè½½ä¸ä¼šæ ¹æ® CPU æ•°é‡è¿›è¡Œæ ‡å‡†åŒ–ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ç³»ç»Ÿå¹³å‡è´Ÿè½½æ˜¯1çš„æ—¶å€™ï¼š\n\n- åœ¨å•æ ¸ç³»ç»Ÿä¸Šï¼Œè¯´æ˜ CPU æ»¡è·‘\n- è€Œåœ¨4æ ¸ç³»ç»Ÿä¸Šï¼Œè¯´æ˜ CPU æœ‰75%çš„ç©ºé—²\n\n\n\n### å¹³å‡è´Ÿè½½ä¸ºå¤šå°‘åˆé€‚ï¼Ÿ\n\nç†æƒ³çš„æƒ…å†µä¸‹ï¼Œæ˜¯æ¯ä¸ª CPU éƒ½åˆšå¥½è¿è¡Œç€ä¸€ä¸ªè¿›ç¨‹ï¼Œè¿™æ ·æ¯ä¸ª CPU éƒ½èƒ½å¾—åˆ°å……åˆ†çš„åˆ©ç”¨ï¼Œå› æ­¤**ç†æƒ³æƒ…å†µä¸‹å¹³å‡è´Ÿè½½åº”è¯¥ç­‰äºç³»ç»Ÿ CPU çš„ä¸ªæ•°**ã€‚\n\nå½“æˆ‘ä»¬åœ¨è¯„åˆ¤ç³»ç»Ÿè´Ÿè½½æƒ…å†µçš„æ—¶å€™ï¼Œåº”è¯¥å…ˆè¦çŸ¥é“ç³»ç»Ÿæœ‰å‡ ä¸ªCPUï¼š\n\n```sh\n$ grep 'model name' /proc/cpuinfo| wc -l\n```\n\n`/proc/cpuinfo`æ–‡ä»¶å†…ä¼šè®°å½•ç³»ç»Ÿ CPU çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ç»Ÿè®¡è¯¥æ–‡ä»¶ä¿¡æ¯è·å– CPU ä¸ªæ•°ã€‚\n\né€šè¿‡ä¸ CPU ä¸ªæ•°å¯¹æ¯”ï¼Œæˆ‘ä»¬å°±å¯ä»¥çŸ¥é“å½“å‰ç³»ç»Ÿçš„è´Ÿè½½æƒ…å†µæ˜¯å¦è¿‡è½½ã€‚\n\nå¹³å‡è´Ÿè½½çš„å€¼æœ‰ä¸‰ä¸ªï¼Œåˆ†åˆ«å¯¹åº”æœ€è¿‘1åˆ†é’Ÿï¼Œæœ€è¿‘5åˆ†é’Ÿå’Œæœ€è¿‘15åˆ†é’Ÿï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™ä¸‰ä¸ªå€¼æ¥æ›´å…¨é¢çš„äº†è§£ç³»ç»Ÿçš„è´Ÿè½½æƒ…å†µï¼š\n\n- å¦‚æœè¿™ä¸‰ä¸ªå€¼åŸºæœ¬ç›¸å·®ä¸å¤§ï¼Œé‚£å°±è¯´æ˜ç³»ç»Ÿè´Ÿè½½æ¯”è¾ƒå¹³ç¨³\n- å¦‚æœæœ€è¿‘1åˆ†é’Ÿçš„è´Ÿè½½è¿œå°äº15åˆ†é’Ÿçš„è´Ÿè½½ï¼Œè¯´æ˜è¿‡å»15åˆ†é’Ÿè´Ÿè½½å¾ˆå¤§ï¼Œè€Œç°åœ¨åœ¨æ…¢æ…¢å‡å°\n- å¦‚æœæœ€è¿‘1åˆ†é’Ÿè´Ÿè½½å¾ˆå¤§ï¼Œè€Œ15åˆ†é’Ÿçš„å¾ˆå°ï¼Œè¯´æ˜æœ€è¿‘1åˆ†é’Ÿçš„è´Ÿè½½åœ¨é€æ¸å¢åŠ ï¼Œè¿™ç§å¢åŠ å¯èƒ½æ˜¯ä¸´æ—¶æ€§çš„ï¼Œä¹Ÿæœ‰å¯èƒ½ä¼šæŒç»­å¢åŠ ï¼Œéœ€è¦æŒç»­è§‚å¯Ÿ\n\n**åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå½“å¹³å‡è´Ÿè½½é«˜äºCPUæ•°é‡çš„70%æ—¶ï¼Œå°±åº”è¯¥åˆ†ææ’æŸ¥è´Ÿè½½é«˜çš„é—®é¢˜äº†**ã€‚ä¸€æ—¦è´Ÿè½½è¿‡é«˜ï¼Œå°±ä¼šå¯¼è‡´è¿›ç¨‹å“åº”å˜æ…¢ï¼Œè¿›è€Œå½±å“æœåŠ¡æ­£å¸¸åŠŸèƒ½ã€‚\n\n\n\n### å¹³å‡è´Ÿè½½ä¸CPUä½¿ç”¨ç‡\n\nCPUä½¿ç”¨ç‡æ˜¯å•ä½æ—¶é—´å†…å¯¹CPUç¹å¿™æƒ…å†µçš„ç»Ÿè®¡ã€‚æ ¹æ®å¹³å‡è´Ÿè½½çš„å«ä¹‰ï¼Œæˆ‘ä»¬çŸ¥é“è¿™ä¸¤è€…æ˜¯ä¸¤ä¸ªä¸åŒçš„æ¦‚å¿µã€‚\n\nå¹³å‡è´Ÿè½½ä¸CPUä½¿ç”¨ç‡ä¸¤è€…ä¹‹é—´ä¹Ÿä¸ä¸€å®šæ˜¯å¯¹åº”çš„ï¼š\n\n- CPUå¯†é›†å‹è¿›ç¨‹ï¼šä¼šä½¿ç”¨å¤§é‡çš„CPUï¼Œè¿™æ—¶å€™ä¸¤è€…ä¸€èˆ¬æ˜¯ä¸€è‡´çš„\n- IOå¯†é›†å‹è¿›ç¨‹ï¼šç­‰å¾…IOä¼šå¯¼è‡´å¹³å‡è´Ÿè½½å‡é«˜ï¼Œä½†æ˜¯è¿™æ—¶å€™è¿›ç¨‹æ˜¯å¤„äºç­‰å¾…çŠ¶æ€çš„ï¼Œå› æ­¤è¿™æ—¶å€™çš„CPUä½¿ç”¨ç‡ä¸ä¸€å®šé«˜\n- å¤§é‡è¿›ç¨‹ç­‰å¾…CPUè°ƒåº¦ï¼šè¿™æ—¶å€™çš„å¹³å‡è´Ÿè½½ä¼šå¾ˆé«˜ï¼Œè€ŒCPUä½¿ç”¨ç‡ä¸€èˆ¬ä¹Ÿä¼šæ¯”è¾ƒé«˜\n\nå½“æˆ‘ä»¬å‘ç°ç³»ç»Ÿçš„å¹³å‡è´Ÿè½½å¾ˆé«˜æ—¶ï¼Œé¦–å…ˆå°±éœ€è¦åˆ†ææ˜¯ç”±äºä¸Šé¢å“ªç§åŸå› å¯¼è‡´çš„ï¼Œè¿™æ ·æ‰èƒ½æœ‰æ•ˆçš„è§£å†³é—®é¢˜ã€‚\n\n\n\n### æ¡ˆä¾‹æ¨¡æ‹Ÿåˆ†æ\n\næ¥ä¸‹æ¥æˆ‘ä»¬æ¥æ¨¡æ‹Ÿä¸€ä¸‹å¹³å‡è´Ÿè½½è¿‡é«˜çš„æ¡ˆä¾‹åˆ†æã€‚\n\né¦–å…ˆè¦å…ˆå®‰è£…ä¸€ä¸‹`stress-ng`å’Œ`sysstat`ä¸¤ä¸ªåŒ…ã€‚å…¶ä¸­`stress-ng`æ˜¯å‹åŠ›æµ‹è¯•å·¥å…·ï¼Œç”¨æ¥æ¨¡æ‹Ÿå¹³å‡è´Ÿè½½è¿‡é«˜çš„åœºæ™¯ï¼Œè€Œ`sysstat`åŒ…å«äº†å¸¸ç”¨çš„æ€§èƒ½å·¥å…·ï¼Œç”¨æ¥ç›‘æ§å’Œåˆ†æç³»ç»Ÿçš„æ€§èƒ½ï¼ŒåŒ…æ‹¬ï¼š\n\n- `mpstat`ï¼šå¤šæ ¸cpuæ€§èƒ½å·¥å…·ï¼Œç”¨æ¥å®æ—¶æŸ¥çœ‹æ¯ä¸ªcpuçš„æ€§èƒ½æŒ‡æ ‡ï¼Œä»¥åŠæ‰€æœ‰cpuçš„å¹³å‡æŒ‡æ ‡\n- `pidstat`ï¼šè¿›ç¨‹æ€§èƒ½åˆ†æå·¥å…·ï¼Œç”¨æ¥å®æ—¶æŸ¥çœ‹è¿›ç¨‹çš„cpuã€å†…å­˜ã€i/oä»¥åŠä¸Šä¸‹æ–‡åˆ‡æ¢ç­‰æ€§èƒ½æŒ‡æ ‡\n\n\n\n##### åœºæ™¯ä¸€ï¼šCPUå¯†é›†å‹è¿›ç¨‹\n\né¦–å…ˆï¼Œåœ¨ç¬¬ä¸€ä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ stress-ng --cpu 2 --timeout 600\n```\n\n- `-- cpu 2`ï¼šä½¿ç”¨2ä¸ªworkerå»ä¸æ–­æ‰§è¡Œcpuå¯†é›†çš„ä»»åŠ¡ï¼Œè¿™é‡Œä½¿ç”¨2æ˜¯å› ä¸ºæˆ‘æœ¬åœ°æµ‹è¯•çš„è™šæ‹Ÿæœºåªæœ‰ä¸¤ä¸ªcpu\n- `--timeout 600`ï¼šè¡¨ç¤ºæŒç»­è¿è¡Œ600s\n\næ¥ç€åœ¨ç¬¬äºŒä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ watch -d uptime # -d ä¼šé«˜äº®æ˜¾ç¤ºå˜åŒ–çš„åŒºåŸŸ\n..., load average: 2.01, 1.44, 0.71\n```\n\næˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªç»ˆç«¯çœ‹åˆ°ï¼Œå¹³å‡è´Ÿè½½ä¼šé€æ¸å‡é«˜ï¼Œæœ€åæœ€è¿‘1åˆ†é’Ÿçš„å¹³å‡è´Ÿè½½ä¼šç¨³å®šåœ¨2å·¦å³\n\næœ€åï¼Œåœ¨ç¬¬ä¸‰ä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ mpstat -P ALL 5 20 # -P All è¡¨ç¤ºç»Ÿè®¡æ‰€æœ‰cpuä¿¡æ¯ï¼Œ5è¡¨ç¤ºé—´éš”5sæ‰“å°ä¸€æ¬¡ç»Ÿè®¡ï¼Œ20è¡¨ç¤ºå…±æ‰“å°20ç»„ç»Ÿè®¡\n...\n09:03:00 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\n09:03:05 AM  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00\n09:03:05 AM    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00\n09:03:05 AM    1   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00\n\nAverage:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\nAverage:     all   99.71    0.00    0.28    0.00    0.00    0.01    0.00    0.00    0.00    0.00\nAverage:       0   99.78    0.00    0.22    0.00    0.00    0.00    0.00    0.00    0.00    0.00\nAverage:       1   99.64    0.00    0.34    0.00    0.00    0.02    0.00    0.00    0.00    0.00\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªcpuçš„ç”¨æˆ·ä½¿ç”¨ç‡éƒ½æ¥è¿‘100%ï¼Œè¯´æ˜æ˜¯å› ä¸ºcpuå¯†é›†è¿›ç¨‹å¯¼è‡´çš„å¹³å‡è´Ÿè½½è¿‡é«˜\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`pidstat`å‘½ä»¤æ¥æŸ¥è¯¢å¼‚å¸¸è¿›ç¨‹ï¼š\n\n```sh\n$ pidstat -u 5 2 # -uè¾“å‡ºcpuä½¿ç”¨ç‡ï¼Œé—´éš”5sæ‰“å°ä¸€æ¬¡ç»Ÿè®¡ä¿¡æ¯ï¼Œå…±æ‰“å°2ç»„\nLinux 4.4.0-159-generic (ubuntu-xenial) \t08/25/2019 \t_x86_64_\t(2 CPU)\n\n09:11:59 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command\n09:12:04 AM     0      5336   99.20    0.00    0.00   99.20     1  stress\n09:12:04 AM     0      5337   99.60    0.00    0.00   99.60     0  stress\n09:12:04 AM  1000      5344    0.20    0.20    0.00    0.40     1  watch\n09:12:04 AM  1000      5538    0.00    0.20    0.00    0.20     1  pidstat\n\n09:12:04 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command\n09:12:09 AM     0      1112    0.00    0.20    0.00    0.20     1  iscsid\n09:12:09 AM     0      1179    0.20    0.00    0.00    0.20     0  containerd\n09:12:09 AM     0      5336   99.60    0.00    0.00   99.60     1  stress\n09:12:09 AM     0      5337  100.00    0.20    0.00  100.20     0  stress\n09:12:09 AM  1000      5344    0.20    0.00    0.00    0.20     1  watch\n\nAverage:      UID       PID    %usr %system  %guest    %CPU   CPU  Command\nAverage:        0      1112    0.00    0.10    0.00    0.10     -  iscsid\nAverage:        0      1179    0.10    0.00    0.00    0.10     -  containerd\nAverage:        0      5336   99.40    0.00    0.00   99.40     -  stress-ng-cpu\nAverage:        0      5337   99.80    0.10    0.00   99.90     -  stress-ng-cpu\nAverage:     1000      5344    0.20    0.10    0.00    0.30     -  watch\nAverage:     1000      5538    0.00    0.10    0.00    0.10     -  pidstat\n```\n\nä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œå¤§é‡å ç”¨cpuä½¿ç”¨ç‡çš„è¿›ç¨‹æ˜¯`stress-ng`å‘½ä»¤\n\n\n\n##### åœºæ™¯äºŒï¼šioå¯†é›†å‹è¿›ç¨‹\n\né¦–å…ˆåœ¨ç¬¬ä¸€ä¸ªç»ˆç«¯æ‰§è¡Œå‘½ä»¤ï¼š\n\n```sh\n$ stress-ng --hdd 2 --timeout 600\n```\n\n- `--hdd 2`ï¼šè¡¨ç¤ºä½¿ç”¨ä¸¤ä¸ª`worker`ä¸æ–­çš„è¯»å†™ä¸´æ—¶æ–‡ä»¶\n- `--timeout`ï¼šè¡¨ç¤ºæŒç»­è¿è¡Œ600s\n\n\n\næ¥ç€ï¼Œåœ¨ç¬¬äºŒä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ watch -d uptime\n..., load average: 2.79, 1.80, 1.16\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œå¹³å‡è´Ÿè½½ä¸æ–­ä¸Šå‡ï¼Œæœ€ç»ˆæ–‡æ¡£åœ¨2.7~2.8ä¹‹é—´\n\næœ€åï¼Œåœ¨ç¬¬ä¸‰ä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ mpstat -P ALL 5 1\nLinux 4.4.0-159-generic (ubuntu-xenial) \t08/25/2019 \t_x86_64_\t(2 CPU)\n\n09:30:45 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\n09:30:50 AM  all    0.11    0.00    5.09   41.86    0.00    0.11    0.00    0.00    0.00   52.82\n09:30:50 AM    0    0.21    0.00    1.47   21.85    0.00    0.21    0.00    0.00    0.00   76.26\n09:30:50 AM    1    0.23    0.00    9.09   63.87    0.00    0.23    0.00    0.00    0.00   26.57\n\nAverage:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\nAverage:     all    0.11    0.00    5.09   41.86    0.00    0.11    0.00    0.00    0.00   52.82\nAverage:       0    0.21    0.00    1.47   21.85    0.00    0.21    0.00    0.00    0.00   76.26\nAverage:       1    0.23    0.00    9.09   63.87    0.00    0.23    0.00    0.00    0.00   26.57\n```\n\n> %iowait: the percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.\n>\n> %idle: the percentage of time that the CPU or CPUs were idle and the system did not have an outstanding disk I/O request.\n\nä»è¾“å‡ºç»“æœæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå°½ç®¡ç³»ç»Ÿçš„å¹³å‡è´Ÿè½½å¾ˆé«˜ï¼Œä½†æ˜¯cpuä½¿ç”¨ç‡å¹¶ä¸é«˜ï¼Œè€Œiowaitå´å¾ˆé«˜ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯ç”±äºioå¯†é›†å¯¼è‡´çš„ç³»ç»Ÿè´Ÿè½½è¿‡é«˜ã€‚\n\n\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨`pidstat`æ¥æŸ¥æ‰¾å‡ºå¯¼è‡´è¿‡è½½çš„è¿›ç¨‹ï¼š\n\n```sh\n$ pidstat -d # -dè¾“å‡ºioç»Ÿè®¡ä¿¡æ¯\nLinux 4.4.0-159-generic (ubuntu-xenial) \t08/25/2019 \t_x86_64_\t(2 CPU)\n\n09:36:31 AM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command\n...\n09:36:31 AM     0      6564      0.01      0.00      0.00       0  stress-ng\n09:36:31 AM     0      6565   4394.88   8064.26      0.00   38334  stress-ng-hdd\n09:36:31 AM     0      6566   4486.84   6272.20      0.00   39617  stress-ng-hdd\n...\n```\n\n\n\n##### åœºæ™¯ä¸‰ï¼šå¤§é‡è¿›ç¨‹åœºæ™¯\n\né¦–å…ˆåœ¨ç¬¬ä¸€ä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ stress-ng -c 8 --timeout 600 # -c 8 è¡¨ç¤ºå¼€å¯8ä¸ªè¿›ç¨‹\n```\n\n\n\nç„¶ååœ¨ç¬¬äºŒä¸ªç»ˆç«¯è¿è¡Œï¼š\n\n```sh\n$ watch -d uptime\n..., load average: 8.03, 5.47, 1.72\n```\n\nå¯ä»¥è§‚å¯Ÿåˆ°ï¼Œç»è¿‡ä¸€æ®µæ—¶é—´ä¹‹åï¼Œç³»ç»Ÿè´Ÿè½½ä¸Šå‡åˆ°8.0å·¦å³ï¼Œè¿œè¿œé«˜äºæ­£å¸¸ç³»ç»Ÿè´Ÿè½½ï¼Œæˆ‘ä»¬ä½¿ç”¨`pidstat`çœ‹ä¸€ä¸‹è¿›ç¨‹æƒ…å†µï¼š\n\n```sh\n$ pidstat -u 3 1\nLinux 4.4.0-159-generic (ubuntu-xenial) \t08/25/2019 \t_x86_64_\t(2 CPU)\n\n10:11:03 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command\n10:11:07 AM     0      7489   24.75    0.00    0.00   24.75     0  stress-ng-cpu\n10:11:07 AM     0      7490   24.75    0.00    0.00   24.75     0  stress-ng-cpu\n10:11:07 AM     0      7491   24.75    0.00    0.00   24.75     1  stress-ng-cpu\n10:11:07 AM     0      7492   24.75    0.00    0.00   24.75     1  stress-ng-cpu\n10:11:07 AM     0      7493   24.75    0.00    0.00   24.75     0  stress-ng-cpu\n10:11:07 AM     0      7494   24.75    0.00    0.00   24.75     1  stress-ng-cpu\n10:11:07 AM     0      7495   25.08    0.00    0.00   25.08     0  stress-ng-cpu\n10:11:07 AM     0      7496   25.08    0.00    0.00   25.08     1  stress-ng-cpu\n\nAverage:      UID       PID    %usr %system  %guest    %CPU   CPU  Command\nAverage:        0      7489   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7490   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7491   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7492   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7493   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7494   24.75    0.00    0.00   24.75     -  stress-ng-cpu\nAverage:        0      7495   25.08    0.00    0.00   25.08     -  stress-ng-cpu\nAverage:        0      7496   25.08    0.00    0.00   25.08     -  stress-ng-cpu\n```\n\næˆ‘ä»¬çœ‹åˆ°æœ‰8ä¸ªè¿›ç¨‹åœ¨äº‰å¤ºç³»ç»Ÿçš„ä¸¤ä¸ªcpuï¼Œå¹³å‡æ¯ä¸ªè¿›ç¨‹å ç”¨25%çš„cpuä½¿ç”¨ç‡ã€‚\n\n\n\n### æ€»ç»“\n\nå¹³å‡è´Ÿè½½æä¾›äº†ä¸€ä¸ªå¿«é€ŸæŸ¥çœ‹ç³»ç»Ÿæ•´ä½“æ€§èƒ½çš„æ‰‹æ®µï¼Œååº”äº†ç³»ç»Ÿæ•´ä½“çš„è´Ÿè½½æƒ…å†µï¼Œä½†æ˜¯åªçœ‹å¹³å‡è´Ÿè½½æœ¬èº«å¹¶ä¸èƒ½ç›´æ¥å‘ç°ç³»ç»Ÿç“¶é¢ˆã€‚\n\n- å¹³å‡è´Ÿè½½é«˜æœ‰å¯èƒ½æ˜¯cpuå¯†é›†å‹è¿›ç¨‹å¯¼è‡´çš„\n- å¹³å‡è´Ÿè½½é«˜ä¸ä¸€å®šä»£è¡¨cpuä½¿ç”¨ç‡é«˜ï¼Œæœ‰å¯èƒ½æ˜¯I/Oç¹å¿™å¯¼è‡´çš„\n- å½“å‘ç°å¹³å‡è´Ÿè½½è¿‡é«˜æ—¶ï¼Œå¯ä»¥ä½¿ç”¨`mpstat`å’Œ`pidstat`ç­‰å·¥å…·è¾…åŠ©åˆ†æ\n\n\n\n### å‚è€ƒ\n\n- [æå®¢æ—¶é—´ä¸“æ ï¼šLinuxæ€§èƒ½ä¼˜åŒ–å®è·µ](<https://time.geekbang.org/column/intro/140>)","tags":["linux - æ€§èƒ½ä¼˜åŒ–"]},{"title":"gctrace","url":"/2019/08/23/gctrace/","content":"\nåœ¨ä¼˜åŒ–`go`ç¨‹åºæ—¶ï¼Œå†…å­˜ä¼˜åŒ–æ˜¯å…¶ä¸­ä¸€é¡¹å¾ˆé‡è¦çš„å†…å®¹ï¼Œå‡è½»`gc`çš„å‹åŠ›ï¼Œèƒ½å¤Ÿæå¤§çš„ä¼˜åŒ–æˆ‘ä»¬çš„ç¨‹åºè¿è¡Œæ•ˆç‡ã€‚\n\nä»Šå¤©å…ˆæ¥çœ‹ä¸€ä¸‹ä¸¤ä¸ªä¸`gc`ç›¸å…³çš„ç¯å¢ƒå˜é‡ï¼š`gctrace`å’Œ`GOGC`\n\n### gctrace\n\n`gctrace`æœ¬èº«æ˜¯[`GODEBUG`](<https://golang.org/pkg/runtime/#hdr-Environment_Variables>)è¿™ä¸ªç¯å¢ƒå˜é‡ä¸­çš„ä¸€ä¸ªé€‰é¡¹ï¼Œç”¨æ¥å¼€å¯`gc`æ—¥å¿—çš„ã€‚æ¯æ¬¡å½“å®Œæˆä¸€æ¬¡`gc`æ‰«ææ—¶ï¼Œå°±ä¼šæ‰“å°å‡ºæœ¬æ¬¡`gc`çš„ç›¸å…³ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ¥ç›‘æ§ç¨‹åºçš„å†…å­˜æƒ…å†µ\n\n```sh\n$ GODEBUG=gctrace=1 GO_BIN # å¼€å¯gctrace\ngc 1 @1.569s 0%: 0.28+2.2+4.6 ms clock, 1.1+0/0.96/4.6+18 ms cpu, 4->4->1 MB, 5 MB goal, 4 P\ngc 2 @3.124s 0%: 0.026+1.4+0.058 ms clock, 0.10+1.3/0.033/1.5+0.23 ms cpu, 4->4->1 MB, 5 MB goal, 4 P\ngc 3 @5.326s 0%: 0.58+0.53+0.12 ms clock, 2.3+0.36/0.44/0.30+0.48 ms cpu, 4->4->1 MB, 5 MB goal, 4 P\n...\nscvg1: inuse: 4, idle: 58, sys: 63, released: 0, consumed: 63 (MB)\n...\n```\n\næ¯ä¸€è¡Œå¯¹åº”ä¸€æ¬¡`gc`ï¼Œå…·ä½“çš„è¾“å‡ºæ ¼å¼å¦‚ä¸‹ï¼š\n\n```\ngc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # P [(forced)]\n```\n\n- `gc #`ï¼šç¬¬å‡ è½®gcï¼Œä»1å¼€å§‹é€’å¢\n\n- `@#s`ï¼šç¨‹åºæ€»çš„è¿è¡Œæ—¶é—´ï¼Œå•ä½`s`\n- `#%`ï¼šä»ç¨‹åºå¼€å§‹åˆ°ç°åœ¨è¿è¡Œ`gc`çš„æ—¶é—´å æ¯”\n- `#+#+# ms clock`ï¼šå¯¹åº” <font color=red>ç¬¬ä¸€æ¬¡`STW`ï¼Œç»ˆæ­¢`SWEEP`ã€å¼€å¯å†™å±éšœ</font> +  <font color=red>å¹¶å‘`Mark`å’Œ`Scan`</font> + <font color=red>ç¬¬äºŒæ¬¡`STW`ï¼Œç»“æŸ`Mark`</font> è¿™ä¸‰ä¸ªé˜¶æ®µ`wall-clock`çš„è€—æ—¶ï¼Œå•ä½ä¸º`ms`\n- `#+#/#/#+# ms cpu`ï¼šå¯¹åº” <font color=red>ç¬¬ä¸€æ¬¡`STW`</font> + <font color=red>å¹¶å‘æ ‡è®°ï¼š`Assist Time `</font>/<font color=red> å¹¶å‘æ ‡è®°ï¼š`Background GC time`</font> /<font color=red> å¹¶å‘æ ‡è®°ï¼š`Idle GC time`</font> + <font color=red>ç¬¬äºŒæ¬¡`STW`ç»“æŸ`Mark`</font> è¿™å‡ ä¸ªé˜¶æ®µçš„`cpu`æ—¶é—´ï¼Œå•ä½`ms`\n- `#->#-># MB `ï¼šåˆ†åˆ«å¯¹åº”`gc`å¼€å§‹æ—¶çš„å †å¤§å°ã€`gc`ç»“æŸæ—¶çš„å †å¤§å°ä»¥åŠ`live heap`ï¼ˆ`gc mark`é˜¶æ®µæ ‡è®°ä¸ºé»‘è‰²çš„å†…å­˜æ€»é‡ï¼‰çš„å¤§å°\n\n- `# MB goal`ï¼šç›®æ ‡`heap size`\n- `# P`ï¼šä½¿ç”¨çš„`P`æ•°é‡\n- `(forced)`ï¼šå¦‚æœè°ƒç”¨`runtime.GC()`å¼ºåˆ¶è§¦å‘`gc`\n\né™¤äº†è¾“å‡º`gc`çš„ä¿¡æ¯ï¼Œå½“`runtime`å‘æ“ä½œç³»ç»Ÿå½’è¿˜å†…å­˜æ—¶ï¼Œä¹Ÿä¼šæ‰“å°å‡ºä¿¡æ¯ï¼Œæ¯”å¦‚ä¸Šé¢çš„ï¼š\n\n```\nscvg1: inuse: 4, idle: 58, sys: 63, released: 0, consumed: 63 (MB)\n```\n\n- `scvg#`ï¼šç¬¬å‡ æ¬¡å½’è¿˜ï¼Œä»1å¼€å§‹è®¡æ•°\n- `inuse: #`ï¼šæ­£åœ¨ä½¿ç”¨æˆ–éƒ¨åˆ†è¢«ä½¿ç”¨çš„`spans`çš„å†…å­˜å¤§å°ï¼Œå•ä½`MB`\n- `idle: #`ï¼šç©ºé—²ç­‰å¾…å½’è¿˜ç»™æ“ä½œç³»ç»Ÿçš„`spans`çš„å†…å­˜å¤§å°ï¼Œå•ä½`MB`ï¼›\n- `sys: #`ï¼šä»æ“ä½œç³»ç»Ÿæ˜ å°„çš„å†…å­˜å¤§å°ï¼Œå®é™…ä¸Šæ˜¯`gc`å †å¯è®¿é—®çš„å†…å­˜è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå•ä½`MB`\n- `released: #`ï¼šæœ¬æ¬¡å½’è¿˜ç»™æ“ä½œç³»ç»Ÿçš„å†…å­˜å¤§å°ï¼Œå•ä½`MB`\n- `consumed: #`ï¼šä»æ“ä½œç³»ç»Ÿåˆ†é…çš„å†…å­˜å¤§å°ï¼Œç­‰äº`sys - released`\n\n\n\n### GOGC\n\næ ¹æ®`runtime/mgc.go`ä¸­çš„æ³¨é‡Šï¼š\n\n>  Next GC is after we've allocated an extra amount of memory proportional to\n>  the amount already in use. The proportion is controlled by GOGC environment variable\n>  (100 by default). If GOGC=100 and we're using 4M, we'll GC again when we get to 8M\n>  (this mark is tracked in next_gc variable). This keeps the GC cost in linear\n>  proportion to the allocation cost. Adjusting GOGC just changes the linear constant\n>  (and also the amount of extra memory used).\n\nåœ¨`go1.5`ä¹‹å‰ï¼Œè¿è¡Œ`gc mark`é˜¶æ®µä¼š`stop the world`ï¼Œ èƒ½å¤Ÿæ ¹æ®`next_gc`å˜é‡ï¼ˆä¹Ÿå°±æ˜¯**goal heap size**ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡`GOGC`å˜é‡è°ƒæ•´ï¼‰ç²¾ç¡®åœ°æ§åˆ¶å †å†…å­˜çš„å¢é•¿ï¼š\n\n![](/img/gc_stw.jpg)\n\nä½†æ˜¯`go1.5`ä¹‹åï¼Œ`gc mark`å¯ä»¥è·Ÿç”¨æˆ·åç¨‹å¹¶å‘è¿è¡Œï¼Œå› æ­¤åœ¨`gc`æ‰§è¡Œè¿‡ç¨‹ä¸­ä»ç„¶ä¼šæœ‰æ–°çš„å†…å­˜è¢«åˆ†é…ï¼Œå› æ­¤`gc`çš„è§¦å‘ç‚¹éœ€è¦ç›¸å¯¹`next_gc`æå‰ï¼š\n\n![](/img/gc_bg.jpg)\n\nå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œ`Hm(n-1)`è¡¨ç¤ºä¸Šä¸€æ¬¡`gc`ç»“æŸåçš„å †å¤§å°,è€Œ`Hg`æ˜¯`next_gc`ï¼Œè€Œæˆ‘ä»¬åœ¨`Ht`è§¦å‘`gc`ï¼Œå› ä¸ºgcè¿‡ç¨‹ä¸­å¯èƒ½ä¼šæœ‰æ–°çš„å†…å­˜åˆ†é…ï¼Œå½“`gc`ç»“æŸæ—¶ï¼Œå½“å‰çš„å †å¤§å°ä¸º`Ha`ã€‚`go`çš„`gc`å®ç°ï¼Œéœ€è¦æä¾›ä¸€ç§åŠ¨æ€è°ƒæ•´çš„æœºåˆ¶ï¼Œæ ¹æ®å†…å­˜åˆ†é…æƒ…å†µè°ƒæ•´`Ht`çš„å€¼ï¼Œä½¿å¾—`Ha`èƒ½å¤Ÿä¸`Hg`å°½é‡æ¥è¿‘ã€‚\n\n\n\næ€»ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®`GOGC`çš„å€¼æ¥è°ƒæ•´`gc`çš„è§¦å‘é˜ˆå€¼ï¼š\n\n- **å½“å°äºé›¶æˆ–è€…ç­‰äº`off`æ—¶ï¼Œå°†ä¼šå…³é—­`gc`**\n- è®¾ç½®è¾ƒå¤§çš„å€¼ï¼šå‡å°‘`gc`è§¦å‘ï¼Œä½†æ˜¯ä¼šå¢åŠ å†…å­˜å ç”¨\n- è®¾ç½®åå°çš„å€¼ï¼šé¢‘ç¹è§¦å‘`gc`\n\n","tags":["go"]},{"title":"grpc clientç«¯åˆ†æ1","url":"/2019/07/29/grpc-clientç«¯åˆ†æ1/","content":"\n### grpcå®¢æˆ·ç«¯è¿æ¥åˆ›å»º\n\n`grpc`æœ¬èº«æä¾›äº†æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡çš„æ¥å£ï¼Œå½“éœ€è¦åˆ›å»º`grpc`è¿æ¥æ—¶ï¼Œå°±ä¼šä½¿ç”¨åˆ°è¿™äº›æ¥å£ã€‚\n\næˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹åˆ›å»º`grpc`è¿æ¥æ—¶çš„ä¸»è¦æµç¨‹ï¼š\n\n![](/img/grpc_client1.png)\n\n![](/img/grpc_client2.png)\n\n\n\n##### æœåŠ¡å‘ç°ï¼šResolver\n\nç›¸å…³æ¥å£å£°æ˜åœ¨`resolver/resolver.go`ä¸­\n\n```go\n// scheme://authority/endpoint\ntype Target struct {\n\tScheme    string\n\tAuthority string\n\tEndpoint  string\n}\n\n// å‘grpcæ³¨å†ŒæœåŠ¡å‘ç°å®ç°æ—¶ï¼Œå®é™…ä¸Šæ³¨å†Œçš„æ˜¯Builder\ntype Builder interface {\n    // åˆ›å»ºResolverï¼Œå½“resolverå‘ç°æœåŠ¡åˆ—è¡¨æ›´æ–°ï¼Œéœ€è¦é€šè¿‡ClientConnæ¥å£é€šçŸ¥ä¸Šå±‚\n\tBuild(target Target, cc ClientConn, opts BuildOption) (Resolver, error)\n\tScheme() string\n}\n\ntype Resolver interface {\n    // å½“æœ‰è¿æ¥è¢«å‡ºç°å¼‚å¸¸æ—¶ï¼Œä¼šè§¦å‘è¯¥æ–¹æ³•ï¼Œå› ä¸ºè¿™æ—¶å€™å¯èƒ½æ˜¯æœ‰æœåŠ¡å®ä¾‹æŒ‚äº†ï¼Œéœ€è¦ç«‹å³å®ç°ä¸€æ¬¡æœåŠ¡å‘ç°\n\tResolveNow(ResolveNowOption)\n\tClose()\n}\n\n//\ntype ClientConn interface {\n\t// æœåŠ¡åˆ—è¡¨å’ŒæœåŠ¡é…ç½®æ›´æ–°å›è°ƒæ¥å£\n\tUpdateState(State)\n\t// æœåŠ¡åˆ—è¡¨æ›´æ–°é€šçŸ¥æ¥å£\n\tNewAddress(addresses []Address)\n \t// æœåŠ¡é…ç½®æ›´æ–°é€šçŸ¥æ¥å£\n\tNewServiceConfig(serviceConfig string)\n}\n```\n\nå…¶ä¸­`Builder`æ¥å£ç”¨æ¥åˆ›å»º`Resolver`ï¼Œæˆ‘ä»¬å¯ä»¥æä¾›è‡ªå·±çš„æœåŠ¡å‘ç°å®ç°ï¼Œç„¶åå°†å…¶æ³¨å†Œåˆ°`grpc`ä¸­ï¼Œå…¶ä¸­é€šè¿‡`scheme`æ¥æ ‡è¯†ï¼Œè€Œ`Resolver`æ¥å£åˆ™æ˜¯æä¾›æœåŠ¡å‘ç°åŠŸèƒ½ã€‚å½“`resover`å‘ç°æœåŠ¡åˆ—è¡¨å‘ç”Ÿå˜æ›´æ—¶ï¼Œä¼šé€šè¿‡`ClientConn`å›è°ƒæ¥å£é€šçŸ¥ä¸Šå±‚ã€‚\n\nå½“æˆ‘ä»¬ä½¿ç”¨`Dial`æˆ–è€…`DialContext`æ¥å£åˆ›å»ºgrpcçš„å®¢æˆ·ç«¯è¿æ¥æ—¶ï¼Œé¦–å…ˆä¼šè§£æå‚æ•°`target`ï¼Œç„¶ååˆ›å»ºå¯¹åº”çš„`resolver`ï¼š\n\n```go\nfunc DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) {\n\tcc := &ClientConn{\n\t\t...\n\t}\n\t\n    ... \n    \n\t// resolverBuilderï¼Œç”¨äºè§£ætargetä¸ºç›®æ ‡æœåŠ¡åˆ—è¡¨\n\t// å¦‚æœæ²¡æœ‰æŒ‡å®šresolverBuilder\n\tif cc.dopts.resolverBuilder == nil {\n\t\t// è§£ætargetï¼Œæ ¹æ®targetçš„schemeè·å–å¯¹åº”çš„resolver\n\t\tcc.parsedTarget = parseTarget(cc.target)\n \t\tcc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)\n\t\t// å¦‚æœschemeæ²¡æœ‰æ³¨å†Œå¯¹åº”çš„resolver\n\t\tif cc.dopts.resolverBuilder == nil {\n            // ä½¿ç”¨é»˜è®¤çš„resolver\n\t\t\tcc.parsedTarget = resolver.Target{\n\t\t\t\tEndpoint: target, // è¿™æ—¶å€™å‚æ•°targetå°±æ˜¯endpointï¼Œpassthroughçš„å®ç°å°±æ˜¯ç›´æ¥è¿”å›endpointï¼Œå³ä¸ä½¿ç”¨æœåŠ¡å‘ç°åŠŸèƒ½ï¼Œå‚æ•°Dialä¼ è¿›æ¥çš„åœ°å€å°±æ˜¯grpc serverçš„åœ°å€\n\t\t\t}\n            // è·å–é»˜è®¤çš„resolverï¼Œä¹Ÿå°±æ˜¯passthrough\n\t\t\tcc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)\n\t\t}\n\t} else {\n        // å¦‚æœDialçš„optionä¸­æ‰‹åŠ¨æŒ‡å®šäº†éœ€è¦ä½¿ç”¨çš„resolverï¼Œé‚£ä¹ˆendpointä¹Ÿæ˜¯target\n\t\tcc.parsedTarget = resolver.Target{Endpoint: target}\n\t}\n    \n\t... \n    \n\t// newCCResolverWrapperæ–¹æ³•å†…è°ƒç”¨builderçš„Buildæ¥å£åˆ›å»ºresolver\n\trWrapper, err := newCCResolverWrapper(cc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build resolver: %v\", err)\n\t}\n\n\tcc.mu.Lock()\n\tcc.resolverWrapper = rWrapper\n\tcc.mu.Unlock()\n    \n \t... \n\n\treturn cc, nil\n}\n\n// æœ‰æ•ˆçš„targetï¼šscheme://authority/endpoint\nfunc parseTarget(target string) (ret resolver.Target) {\n\tvar ok bool\n\tret.Scheme, ret.Endpoint, ok = split2(target, \"://\")\n\tif !ok {\n        // å¦‚æœæ²¡æœ‰schemeï¼Œåˆ™æ•´ä¸ªtargetä½œä¸ºendpoint\n\t\treturn resolver.Target{Endpoint: target}\n\t}\n    // å¦‚æœæŒ‡å®šäº†shemeï¼Œé‚£ä¹ˆå¿…é¡»æœ‰`/`ï¼Œåˆ†å‰²authorigyå’Œendpoint\n    // å½“ä¸éœ€è¦æŒ‡å®šauthorigyï¼Œæ¯”å¦‚ä½¿ç”¨dnsResolveræ—¶:`dns:///www.demo.com`\n\tret.Authority, ret.Endpoint, ok = split2(ret.Endpoint, \"/\")\n\tif !ok {\n\t\treturn resolver.Target{Endpoint: target}\n\t}\n\treturn ret\n}\n\nfunc newCCResolverWrapper(cc *ClientConn) (*ccResolverWrapper, error) {\n\t// åœ¨DialContextæ–¹æ³•ä¸­ï¼Œå·²ç»åˆå§‹åŒ–äº†resolverBuilder\n    rb := cc.dopts.resolverBuilder\n\tif rb == nil {\n\t\treturn nil, fmt.Errorf(\"could not get resolver for scheme: %q\", cc.parsedTarget.Scheme)\n\t}\n\n \t// ccResolverWrapperå®ç°resolver.ClientConnæ¥å£ï¼Œç”¨äºæä¾›æœåŠ¡åˆ—è¡¨å˜æ›´ä¹‹åçš„é€šçŸ¥å›è°ƒæ¥å£\n\tccr := &ccResolverWrapper{\n\t\tcc:     cc,\n\t\taddrCh: make(chan []resolver.Address, 1),\n\t\tscCh:   make(chan string, 1),\n\t}\n\n\tvar err error\n\t// åˆ›å»ºresovlerï¼Œresovleråˆ›å»ºä¹‹åï¼Œéœ€è¦ç«‹å³æ‰§è¡ŒæœåŠ¡å‘ç°é€»è¾‘ï¼Œç„¶åå°†å‘ç°çš„æœåŠ¡åˆ—è¡¨é€šè¿‡resolver.ClientConnå›è°ƒæ¥å£é€šçŸ¥ä¸Šå±‚\n\tccr.resolver, err = rb.Build(cc.parsedTarget, ccr, resolver.BuildOption{DisableServiceConfig: cc.dopts.disableServiceConfig})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ccr, nil\n}\n```\n\n\n\n##### Balancerï¼šè´Ÿè½½å‡è¡¡æ¥å£\n\nç›¸å…³æ¥å£å£°æ˜åœ¨`balancer/balancer.go`æ–‡ä»¶ä¸­ï¼š\n\n```go\n// å£°æ˜äº†balanceréœ€è¦ç”¨åˆ°çš„å›è°ƒæ¥å£\ntype ClientConn interface {\n  \t// æ ¹æ®åœ°å€åˆ›å»ºç½‘è·¯è¿æ¥\n\tNewSubConn([]resolver.Address, NewSubConnOptions) (SubConn, error)\n    // ç§»é™¤æ— æ•ˆç½‘ç»œè¿æ¥\n\tRemoveSubConn(SubConn)\n    // æ›´æ–°Pickerï¼ŒPickerç”¨äºåœ¨æ‰§è¡Œrpcè°ƒç”¨æ—¶æ‰§è¡Œè´Ÿè½½å‡è¡¡ç­–ç•¥ï¼Œé€‰ä¸¾ä¸€æ¡è¿æ¥å‘é€è¯·æ±‚\n\tUpdateBalancerState(s connectivity.State, p Picker)\n    // ç«‹å³è§¦å‘æœåŠ¡å‘ç°\n\tResolveNow(resolver.ResolveNowOption)\n\tTarget() string\n}\n\n// æ ¹æ®å½“å‰çš„è¿æ¥åˆ—è¡¨ï¼Œæ‰§è¡Œè´Ÿè½½å‡è¡¡ç­–ç•¥é€‰ä¸¾ä¸€æ¡è¿æ¥å‘é€rpcè¯·æ±‚\ntype Picker interface {\n\tPick(ctx context.Context, opts PickOptions) (conn SubConn, done func(DoneInfo), err error)\n}\n\n// Builderç”¨äºåˆ›å»ºBalancerï¼Œæ³¨å†Œçš„æ—¶å€™ä¹Ÿæ˜¯æ³¨å†Œbuilder\ntype Builder interface {\n\tBuild(cc ClientConn, opts BuildOptions) Balancer\n\tName() string\n}\n\ntype Balancer interface {\n    // å½“æœ‰è¿æ¥çŠ¶æ€å˜æ›´æ—¶ï¼Œå›è°ƒ\n\tHandleSubConnStateChange(sc SubConn, state connectivity.State)\n    // å½“resolverå‘ç°æ–°çš„æœåŠ¡åœ°å€åˆ—è¡¨æ—¶è°ƒç”¨ï¼ˆæœ‰å¯èƒ½åœ°å€åˆ—è¡¨å¹¶æ²¡æœ‰çœŸçš„æ›´æ–°ï¼‰\n\tHandleResolvedAddrs([]resolver.Address, error)\n\tClose()\n}\n```\n\nå½“`Resolver`å‘ç°æ–°çš„æœåŠ¡åˆ—è¡¨æ—¶ï¼Œæœ€ç»ˆä¼šè°ƒç”¨`Balancer`çš„`HandleResolvedAddrs`æ–¹æ³•è¿›è¡Œé€šçŸ¥ï¼›`Balancer`é€šè¿‡`ClientConn`çš„æ¥å£åˆ›å»ºç½‘ç»œè¿æ¥ï¼Œç„¶åæ ¹æ®å½“å‰çš„ç½‘ç»œè¿æ¥è¿æ¥æ„é€ æ–°çš„`Picker`ï¼Œç„¶åå›è°ƒ`ClientConn.UpdateBalancerState`æ›´æ–°`Picker`ã€‚å½“å‘é€`grpc`è¯·æ±‚æ—¶ï¼Œä¼šå…ˆæ‰§è¡Œ`Picker`çš„æ¥å£ï¼Œæ ¹æ®å…·ä½“çš„è´Ÿè½½å‡è¡¡ç­–ç•¥é€‰ä¸¾ä¸€æ¡ç½‘ç»œè¿æ¥ï¼Œç„¶åå‘é€`rpc`è¯·æ±‚ã€‚\n\nå½“`resolver`å‘ç°æ–°çš„æœåŠ¡åˆ—è¡¨ä¹‹åï¼ŒåŒé€šè¿‡`NewAddress`å›è°ƒé€šçŸ¥ï¼š\n\n```go\n// ccResolverWrapperæ˜¯resolver.ClientConnçš„å®ç°\nfunc (ccr *ccResolverWrapper) NewAddress(addrs []resolver.Address) {\n\tif ccr.isDone() {\n\t\treturn\n\t}\n\t\n\tccr.curState.Addresses = addrs\n\tccr.cc.updateResolverState(ccr.curState)\n}\n\n// æ›´æ–°ClientConnçš„åœ°å€å’ŒServiceConfig\nfunc (cc *ClientConn) updateResolverState(s resolver.State) error {\n\tcc.mu.Lock()\n\tdefer cc.mu.Unlock()\n\t\n    // ClientConnå·²ç»close\n\tif cc.conns == nil {\n\t\treturn nil\n\t}\n\n\t...\n\n\t// è´Ÿè½½å‡è¡¡å™¨å˜æ›´\n\tvar balCfg serviceconfig.LoadBalancingConfig\n\t// å¦‚æœè°ƒç”¨Dialæ—¶æ²¡æœ‰æ‰‹åŠ¨æŒ‡å®šè¦ä½¿ç”¨çš„LoadBalancer\n\tif cc.dopts.balancerBuilder == nil {\n\t\tvar newBalancerName string\n\t\t// å¦‚æœserviceConfigä¸­æŒ‡å®šäº†è´Ÿè½½å‡è¡¡å™¨é…ç½®\n\t\tif cc.sc != nil && cc.sc.lbConfig != nil {\n\t\t\tnewBalancerName = cc.sc.lbConfig.name\n\t\t\tbalCfg = cc.sc.lbConfig.cfg\n\t\t} else {\n\t\t\tvar isGRPCLB bool\n            // åˆ¤æ–­æ˜¯å¦å­˜åœ¨grpclbç±»å‹çš„åœ°å€\n\t\t\tfor _, a := range s.Addresses {\n\t\t\t\tif a.Type == resolver.GRPCLB {\n\t\t\t\t\tisGRPCLB = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\t// å­˜åœ¨grpclbç±»å‹çš„addrï¼Œä½¿ç”¨grpclbè´Ÿè½½å‡è¡¡å™¨\n\t\t\tif isGRPCLB {\n\t\t\t\tnewBalancerName = grpclbName\n                // å¦‚æœé…ç½®ä¸­æŒ‡å®šäº†è´Ÿè½½å‡è¡¡å™¨\n\t\t\t} else if cc.sc != nil && cc.sc.LB != nil { \n\t\t\t\tnewBalancerName = *cc.sc.LB\n\t\t\t} else {\n                // é»˜è®¤ä½¿ç”¨PickFirstè´Ÿè½½å‡è¡¡å™¨ï¼Œæ¯æ¬¡éƒ½ä½¿ç”¨ç¬¬ä¸€æ¡è¿æ¥\n\t\t\t\tnewBalancerName = PickFirstBalancerName \n\t\t\t}\n\t\t}\n\t\t// ä½¿ç”¨æ–°çš„è´Ÿè½½å‡è¡¡å™¨\n\t\tcc.switchBalancer(newBalancerName)\n\t} else if cc.balancerWrapper == nil { // optionsæŒ‡å®šäº†balancerBuilderä½†æ˜¯è¿˜æ²¡æœ‰åˆå§‹åŒ–\n\t\t// åˆå§‹åŒ–balancer\n\t\tcc.curBalancerName = cc.dopts.balancerBuilder.Name()\n\t\tcc.balancerWrapper = newCCBalancerWrapper(cc, cc.dopts.balancerBuilder, cc.balancerBuildOpts)\n\t}\n\n\t// é€šçŸ¥BalanceræœåŠ¡åˆ—è¡¨å˜æ›´äº†\ncc.balancerWrapper.updateClientConnState(&balancer.ClientConnState{ResolverState: s, BalancerConfig: balCfg})\n\treturn nil\n}\n```\n\næ¥ä¸‹æ¥ï¼Œçœ‹ä¸€ä¸‹`Balancer`æ¥æ”¶åˆ°æ–°çš„æœåŠ¡åˆ—è¡¨ä¹‹åçš„æ‰§è¡Œé€»è¾‘ï¼š\n\n```go\n// baseBalancerå¯ä»¥çœ‹æˆæ˜¯Balanceræ¥å£å®ç°çš„åŸºç±»ï¼Œå½“è¦å®ç°è‡ªå·±çš„è´Ÿè½½å‡è¡¡ç­–ç•¥æ—¶åªéœ€è¦åœ¨å™¨åŸºç¡€ä¸Šå®ç°Pickeræ¥å£\nfunc (b *baseBalancer) UpdateClientConnState(s balancer.ClientConnState) {\n    // è®°å½•æ–°çš„æœåŠ¡åˆ—è¡¨\n    addrsSet := make(map[resolver.Address]struct{})\n\t// ä¸ºæ–°çš„åœ°å€åˆ›å»ºè¿æ¥\n\tfor _, a := range s.ResolverState.Addresses {\n\t\taddrsSet[a] = struct{}{}\n        // å¦‚æœè¯¥åœ°å€ä¹‹å‰ä¸å­˜åœ¨\n\t\tif _, ok := b.subConns[a]; !ok {\n            // åˆ›å»ºè¿æ¥\n\t\t\tsc, err := b.cc.NewSubConn([]resolver.Address{a}, balancer.NewSubConnOptions{HealthCheckEnabled: b.config.HealthCheck})\n\t\t\tif err != nil {\n\t\t\t\tgrpclog.Warningf(\"base.baseBalancer: failed to create new SubConn: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n            // ä¿å­˜åˆ°subConns\n\t\t\tb.subConns[a] = sc\n            // è®¾ç½®åˆå§‹çŠ¶æ€\n            // è¿æ¥çŠ¶æ€æœ‰ï¼š\n            //     - IDLE: æœªè¿æ¥\n            //     - CONNECTING: è¿æ¥ä¸­\n            //     - READY: å·²ç»è¿æ¥ï¼Œå¯ç”¨\n            //     - TRANSIENT_FAILURE: è¿æ¥å¼‚å¸¸\n            //     - SHUTDOWN: è¿æ¥å…³é—­\n\t\t\tb.scStates[sc] = connectivity.Idle\n            // å¼€å§‹è¿æ¥ï¼Œæ›´æ–°çŠ¶æ€ä¸ºCONNECTINGï¼Œç„¶åå¼‚æ­¥æ‰§è¡Œè¿æ¥é€»è¾‘\n\t\t\tsc.Connect()\n\t\t}\n\t}\n\t// ç§»é™¤æ— æ•ˆaddr\n\tfor a, sc := range b.subConns {\n\t\t// å¦‚æœä¸åœ¨æ–°çš„è¿æ¥åˆ—è¡¨ä¸­ï¼Œåˆ™éœ€è¦ç§»é™¤\n\t\tif _, ok := addrsSet[a]; !ok {\n            // æ›´æ–°çŠ¶æ€ä¸ºSHUTDOWNï¼Œå¹¶å…³é—­è¿æ¥\n\t\t\tb.cc.RemoveSubConn(sc)\n\t\t\tdelete(b.subConns, a)\n\t\t}\n\t}\n}\n```\n\næ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹`Connect`çš„é€»è¾‘ï¼š\n\n```go\nfunc (ac *addrConn) connect() error {\n\tac.mu.Lock()\n\t// å¦‚æœè¿æ¥å·²ç»è¢«ç§»é™¤\n\tif ac.state == connectivity.Shutdown {\n\t\tac.mu.Unlock()\n\t\treturn errConnClosing\n\t}\n    \n\t// å¦‚æœçŠ¶æ€ä¸æ˜¯Idleï¼Œè¡¨ç¤ºå·²ç»æ‰§è¡Œè¿‡connectæ–¹æ³•ï¼Œç›´æ¥è¿”å›\n\tif ac.state != connectivity.Idle {\n\t\tac.mu.Unlock()\n\t\treturn nil\n\t}\n\n\t// æ›´æ–°çŠ¶æ€ä¸ºConnectingï¼Œè¡¨ç¤ºæ­£åœ¨è¿æ¥ä¸­\n\tac.updateConnectivityState(connectivity.Connecting)\n\tac.mu.Unlock()\n\n\t// å¼‚æ­¥å¯åŠ¨ä¸€ä¸ªåç¨‹å»æ‰§è¡Œç½‘ç»œè¿æ¥\n\tgo ac.resetTransport()\n\treturn nil\n}\n\nfunc (ac *addrConn) resetTransport() {\n\tfor i := 0; ; i++ {\n\t\t// å¦‚æœå‘ç”Ÿé‡è¯•ï¼Œè¯´æ˜æœ‰å¯èƒ½è¦è¿æ¥çš„æœåŠ¡å·²ç»æŒ‚æ‰äº†ï¼Œè¿™æ—¶å€™æœåŠ¡åˆ—è¡¨åº”è¯¥å‘ç”Ÿå˜åŒ–äº†ï¼Œè§¦å‘ä¸€ä¸‹ç«‹å³æ‰§è¡ŒæœåŠ¡å‘ç°\n\t\tif i > 0 {\n            // è¯¥æ–¹æ³•å¼‚æ­¥æ‰§è¡Œï¼Œæœ€ç»ˆè°ƒç”¨resolver.ResolveNow\n\t\t\tac.cc.resolveNow(resolver.ResolveNowOption{})\n\t\t}\n\n\t\tac.mu.Lock()\n\t\t// æ£€æŸ¥è¿æ¥æ˜¯å¦å·²ç»ç§»é™¤\n\t\tif ac.state == connectivity.Shutdown {\n\t\t\tac.mu.Unlock()\n\t\t\treturn\n\t\t}\n        \n\t\t// è¦è¿æ¥çš„addr\n\t\taddrs := ac.addrs\n        // backoffIdxä¿å­˜ä¸€æ¬¡è¿æ¥çš„é‡è¯•æ¬¡æ•°\n\t\tbackoffFor := ac.dopts.bs.Backoff(ac.backoffIdx)\n \n        dialDuration := minConnectTimeout\n\t\tif ac.dopts.minConnectTimeout != nil {\n\t\t\tdialDuration = ac.dopts.minConnectTimeout()\n\t\t}\n\n\t\tif dialDuration < backoffFor {\n\t\t\t// Give dial more time as we keep failing to connect.\n\t\t\tdialDuration = backoffFor\n\t\t}\n\t\t \n\t\tconnectDeadline := time.Now().Add(dialDuration)\n\t\t// æ›´æ–°çŠ¶æ€ä¸ºConnecting\n\t\tac.updateConnectivityState(connectivity.Connecting)\n\t\tac.transport = nil\n\t\tac.mu.Unlock()\n\n\t\t// å°è¯•åˆ›å»ºè¿æ¥ï¼Œåªè¦ä¸€ä¸ªaddræˆåŠŸç«‹å³è¿”å›\n\t\tnewTr, addr, reconnect, err := ac.tryAllAddrs(addrs, connectDeadline)\n\t\tif err != nil { // åˆ›å»ºå¤±è´¥\n\t\t\tac.mu.Lock()\n\t\t\t// æ£€æŸ¥è¿æ¥æ˜¯å¦å·²ç»ç§»é™¤\n\t\t\tif ac.state == connectivity.Shutdown {\n\t\t\t\tac.mu.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// æ›´æ–°çŠ¶æ€ä¸ºTransientFailureï¼Œè¡¨ç¤ºè¿æ¥å¼‚å¸¸\n\t\t\tac.updateConnectivityState(connectivity.TransientFailure)\n\n\t\t\t// Backoff.\n\t\t\tb := ac.resetBackoff\n\t\t\tac.mu.Unlock()\n\t\t\t// sleepä¸€ä¸‹ï¼Œç„¶åé‡è¯•\n\t\t\ttimer := time.NewTimer(backoffFor)\n\t\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\tac.mu.Lock()\n\t\t\t\tac.backoffIdx++\n\t\t\t\tac.mu.Unlock()\n\t\t\tcase <-b:\n\t\t\t\ttimer.Stop()\n\t\t\tcase <-ac.ctx.Done():\n\t\t\t\ttimer.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// è¿™é‡Œè¡¨ç¤ºå·²ç»åˆ›å»ºè¿æ¥æˆåŠŸ\n\t\tac.mu.Lock()\n\t\t// åŒé‡æ£€æŸ¥ï¼Œæ˜¯å¦å·²ç»Shutdown\n\t\tif ac.state == connectivity.Shutdown {\n\t\t\tnewTr.Close()\n\t\t\tac.mu.Unlock()\n\t\t\treturn\n\t\t}\n\t\t// å½“å‰è¿æ¥çš„addr\n\t\tac.curAddr = addr\n\t\t// transport\n\t\tac.transport = newTr\n\t\tac.backoffIdx = 0\n \n        ...\n        // ä¸éœ€è¦\n        if !healthcheckManagingState {\n\t\t\tac.updateConnectivityState(connectivity.Ready)\n\t\t}\n\t\tac.mu.Unlock()\n        // ç­‰å¾…è¿æ¥å¼‚å¸¸ï¼Œè§¦å‘é‡è¿\n        <-reconnect.Done()\n        ...\n\t}\n}\n```\n\næ¥ä¸‹æ¥ï¼Œçœ‹ä¸€ä¸‹è¿æ¥çš„çŠ¶æ€å˜æ›´çš„é€»è¾‘ï¼š\n\n```go\nfunc (ac *addrConn) updateConnectivityState(s connectivity.State) {\n\tif ac.state == s {\n\t\treturn\n\t}\n\n\tupdateMsg := fmt.Sprintf(\"Subchannel Connectivity change to %v\", s)\n\t// çŠ¶æ€å˜æ›´\n\tac.state = s\n \n\t// è°ƒç”¨ClientConnçš„SubConnçŠ¶æ€å˜æ›´å›è°ƒ\n\tac.cc.handleSubConnStateChange(ac.acbw, s)\n}\n\nfunc (cc *ClientConn) handleSubConnStateChange(sc balancer.SubConn, s connectivity.State) {\n\tcc.mu.Lock()\n\tif cc.conns == nil {\n\t\tcc.mu.Unlock()\n\t\treturn\n\t}\n \t\n\tcc.balancerWrapper.handleSubConnStateChange(sc, s)\n\tcc.mu.Unlock()\n}\n\n// ccBalancerWrapperå®ç°äº†balancer.ClientConnæ¥å£\nfunc (ccb *ccBalancerWrapper) handleSubConnStateChange(sc balancer.SubConn, s connectivity.State) {\n\tif sc == nil {\n\t\treturn\n\t}\n    // å°†å˜æ›´äº‹ä»¶åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­\n\tccb.stateChangeQueue.put(&scStateUpdate{\n\t\tsc:    sc,\n\t\tstate: s,\n\t})\n}\n```\n\nä¸Šé¢å°†è¿æ¥çš„çŠ¶æ€å˜æ›´äº‹ä»¶åŠ å…¥åˆ°äº†ä¸€ä¸ªé˜Ÿåˆ—ä¸­ï¼Œé‚£ä¹ˆå¿…ç„¶æœ‰åœ°æ–¹ä»é˜Ÿåˆ—ä¸­å–å‡ºäº‹ä»¶ï¼Œé€šçŸ¥åˆ°balancerï¼š\n\n```go\nfunc (ccb *ccBalancerWrapper) watcher() {\n\tfor {\n\t\tselect {\n        // è·å–è¿æ¥çŠ¶æ€å˜æ›´äº‹ä»¶\n\t\tcase t := <-ccb.stateChangeQueue.get():\n            ...\n\t\t\t// V2Balanceræ˜¯æ–°ç‰ˆçš„Balanceræ¥å£\n\t\t\tif ub, ok := ccb.balancer.(balancer.V2Balancer); ok {\n                // é€šçŸ¥è¿æ¥çŠ¶æ€æ›´æ–°\n\t\t\t\tub.UpdateSubConnState(t.sc, balancer.SubConnState{ConnectivityState: t.state})\n\t\t\t} else {\n                // é€šçŸ¥è¿æ¥çŠ¶æ€æ›´æ–°\n\t\t\t\tccb.balancer.HandleSubConnStateChange(t.sc, t.state)\n\t\t\t}\n\t\tcase s := <-ccb.ccUpdateCh:\n\t\t\t...\n\t\tcase <-ccb.done:\n\t\t}\n\t\t... \n\t}\n}\n```\n\n```go\nfunc (b *baseBalancer) UpdateSubConnState(sc balancer.SubConn, state balancer.SubConnState) {\n   // æ–°çš„çŠ¶æ€\n   s := state.ConnectivityState\n   // æ—§çš„çŠ¶æ€\n   oldS, ok := b.scStates[sc]\n   if !ok {\n      return\n   }\n   // è®¾ç½®æ–°çš„çŠ¶æ€\n   b.scStates[sc] = s\n   switch s {\n   case connectivity.Idle:\n      sc.Connect()        // Idleè§¦å‘è¿æ¥ \n   case connectivity.Shutdown: \n      delete(b.scStates, sc) // è¿æ¥å·²ç»åˆ é™¤\n   }\n\n   // balanceråŸå…ˆçš„çŠ¶æ€\n   oldAggrState := b.state\n   // æ›´æ–°balancerçš„çŠ¶æ€ï¼š\n   //   - å¦‚æœå­˜åœ¨Readyçš„subConnï¼Œåˆ™çŠ¶æ€ä¸ºready\n   //   - å¦åˆ™å¦‚æœå­˜åœ¨connectingï¼Œåˆ™ä¸ºconnecting\n   //   - å¦åˆ™ä¸ºTransientFailure\n   b.state = b.csEvltr.RecordTransition(oldS, s)\n\n   // å½“ä¸‹é¢æƒ…å†µå‘ç”Ÿæ—¶ï¼Œéœ€è¦é‡æ–°åˆ›å»ºPickerï¼š\n   //    - è¿æ¥ç”±å…¶ä»–çŠ¶æ€è½¬å˜ä¸ºReadyçŠ¶æ€\n   //    - è¿æ¥ç”±ReadyçŠ¶æ€è½¬å˜ä¸ºå…¶ä»–çŠ¶æ€\n   //    - balancerè½¬å˜ä¸ºTransientFailureçŠ¶æ€\n   //    - balancerç”±TransientFailureè½¬å˜ä¸ºNon-TransientFailureçŠ¶æ€\n   if (s == connectivity.Ready) != (oldS == connectivity.Ready) ||\n      (b.state == connectivity.TransientFailure) != (oldAggrState == connectivity.TransientFailure) {\n      // é‡æ–°ç”ŸæˆPicker\n      b.regeneratePicker()\n   }\n\n   // å›è°ƒæ›´æ–°çŠ¶æ€å’Œpicker\n   b.cc.UpdateBalancerState(b.state, b.picker)\n}\n```\n\n\n\n##### å®¢æˆ·ç«¯è¿æ¥åˆ›å»ºï¼šDialContext\n\n```go\nfunc DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) {\n\tcc := &ClientConn{\n\t\ttarget:            target,                       // target\n\t\tcsMgr:             &connectivityStateManager{},  // è¿æ¥çŠ¶æ€ç®¡ç†å™¨\n\t\tconns:             make(map[*addrConn]struct{}), // è¿æ¥\n\t\tdopts:             defaultDialOptions(),         // é»˜è®¤çš„options\n\t\tblockingpicker:    newPickerWrapper(),           // balancer.Pickerçš„wrapper\n\t\tczData:            new(channelzData),\n\t\tfirstResolveEvent: grpcsync.NewEvent(),\n\t}\n\n\tcc.retryThrottler.Store((*retryThrottler)(nil))\n\tcc.ctx, cc.cancel = context.WithCancel(context.Background())\n\n\t// åº”ç”¨options\n\tfor _, opt := range opts {\n\t\topt.apply(&cc.dopts)\n\t}\n\n\t// å¦‚æœå­˜åœ¨å¤šä¸ªInterceptorsï¼Œåˆ™ç»„è£…æˆä¸€ä¸ªè°ƒç”¨é“¾\n\tchainUnaryClientInterceptors(cc)\n\tchainStreamClientInterceptors(cc)\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tcc.Close()\n\t\t}\n\t}()\n\n\t...\n\n\t// tlsè¿æ¥åŠ å¯†è¯ä¹¦ç›¸å…³æ£€æŸ¥\n\tif !cc.dopts.insecure {\n\t\tif cc.dopts.copts.TransportCredentials == nil && cc.dopts.copts.CredsBundle == nil {\n\t\t\treturn nil, errNoTransportSecurity\n\t\t}\n\t\tif cc.dopts.copts.TransportCredentials != nil && cc.dopts.copts.CredsBundle != nil {\n\t\t\treturn nil, errTransportCredsAndBundle\n\t\t}\n\t} else {\n\t\tif cc.dopts.copts.TransportCredentials != nil || cc.dopts.copts.CredsBundle != nil {\n\t\t\treturn nil, errCredentialsConflict\n\t\t}\n\t\tfor _, cd := range cc.dopts.copts.PerRPCCredentials {\n\t\t\tif cd.RequireTransportSecurity() {\n\t\t\t\treturn nil, errTransportCredentialsMissing\n\t\t\t}\n\t\t}\n\t}\n\n\t// å¦‚æœæä¾›äº†æœåŠ¡é…ç½®\n\tif cc.dopts.defaultServiceConfigRawJSON != nil {\n\t\tsc, err := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s: %v\", invalidDefaultServiceConfigErrPrefix, err)\n\t\t}\n\t\t// è®¾ç½®é»˜è®¤æœåŠ¡é…ç½®\n\t\tcc.dopts.defaultServiceConfig = sc\n\t}\n\n    // keepAliveé…ç½®\n\tcc.mkp = cc.dopts.copts.KeepaliveParams\n\n\t// å¦‚æœæ²¡æœ‰æä¾›dialï¼Œåˆ™é»˜è®¤ä½¿ç”¨ProxyDialerï¼Œä¼šæ ¹æ®ç³»ç»Ÿç¯å¢ƒå˜é‡çš„ä»£ç†é…ç½®è¿›è¡Œç½‘ç»œè¿æ¥\n\tif cc.dopts.copts.Dialer == nil {\n\t\tcc.dopts.copts.Dialer = newProxyDialer(\n\t\t\tfunc(ctx context.Context, addr string) (net.Conn, error) {\n\t\t\t\tnetwork, addr := parseDialTarget(addr)\n\t\t\t\treturn (&net.Dialer{}).DialContext(ctx, network, addr)\n\t\t\t},\n\t\t)\n\t}\n\n\t// ç”¨æˆ·ä»£ç†æ·»åŠ grpcUA\n\tif cc.dopts.copts.UserAgent != \"\" {\n\t\tcc.dopts.copts.UserAgent += \" \" + grpcUA\n\t} else {\n\t\tcc.dopts.copts.UserAgent = grpcUA\n\t}\n\n\t// å¦‚æœoptionsè®¾ç½®äº†timeout\n\tif cc.dopts.timeout > 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(ctx, cc.dopts.timeout)\n\t\tdefer cancel()\n\t}\n\tdefer func() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tconn, err = nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\t}()\n\n\tscSet := false\n\t// å¦‚æœæä¾›äº†scChanï¼Œæ”¯æŒå¯¹serviceConfigè¿›è¡Œçƒ­æ›´\n\tif cc.dopts.scChan != nil {\n\t\t// Try to get an initial service config.\n\t\tselect {\n\t\t// å°è¯•è·å–åˆå§‹çš„serviceConfig\n\t\tcase sc, ok := <-cc.dopts.scChan:\n\t\t\tif ok {\n\t\t\t\tcc.sc = &sc\n\t\t\t\tscSet = true // æˆåŠŸè·å–åˆå§‹çš„serviceConfig\n\t\t\t}\n\t\tdefault:\n\t\t}\n\t}\n    \n\t// æä¾›retryæ—¶çš„é€€é¿ç®—æ³•\n\tif cc.dopts.bs == nil {\n\t\tcc.dopts.bs = backoff.Exponential{\n\t\t\tMaxDelay: DefaultBackoffConfig.MaxDelay,\n\t\t}\n\t}\n\n\t// resolverBuilderï¼Œç”¨äºè§£ætargetä¸ºç›®æ ‡æœåŠ¡åˆ—è¡¨\n\t// å¦‚æœæ²¡æœ‰æŒ‡å®šresolverBuilder\n\tif cc.dopts.resolverBuilder == nil {\n\t\t// Only try to parse target when resolver builder is not already set.\n\t\t// è§£ætargetï¼Œæ ¹æ®targetçš„schemeè·å–å¯¹åº”çš„resolver\n\t\tcc.parsedTarget = parseTarget(cc.target)\n\t\tgrpclog.Infof(\"parsed scheme: %q\", cc.parsedTarget.Scheme)\n\t\tcc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)\n\t\t// å¦‚æœæ²¡æœ‰çš„è¯ï¼Œä½¿ç”¨é»˜è®¤çš„resolver\n\t\tif cc.dopts.resolverBuilder == nil {\n\t\t\t// If resolver builder is still nil, the parsed target's scheme is\n\t\t\t// not registered. Fallback to default resolver and set Endpoint to\n\t\t\t// the original target.\n\t\t\tgrpclog.Infof(\"scheme %q not registered, fallback to default scheme\", cc.parsedTarget.Scheme)\n\t\t\tcc.parsedTarget = resolver.Target{\n\t\t\t\tScheme:   resolver.GetDefaultScheme(),\n\t\t\t\tEndpoint: target,\n\t\t\t}\n\t\t\tcc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)\n\t\t}\n\t} else {\n\t\tcc.parsedTarget = resolver.Target{Endpoint: target}\n\t}\n\n\t// è¿æ¥è¯ä¹¦\n\tcreds := cc.dopts.copts.TransportCredentials\n\tif creds != nil && creds.Info().ServerName != \"\" {\n\t\tcc.authority = creds.Info().ServerName\n\t} else if cc.dopts.insecure && cc.dopts.authority != \"\" {\n\t\tcc.authority = cc.dopts.authority\n\t} else {\n\t\t// Use endpoint from \"scheme://authority/endpoint\" as the default\n\t\t// authority for ClientConn.\n\t\tcc.authority = cc.parsedTarget.Endpoint\n\t}\n\n\t// å¦‚æœæä¾›äº†scChanä½†æ˜¯è¿˜æ²¡æœ‰è·å–åˆ°åˆå§‹çš„serviceConfigï¼Œåˆ™é˜»å¡ç­‰å¾…serviceConfig\n\tif cc.dopts.scChan != nil && !scSet {\n\t\t// Blocking wait for the initial service config.\n\t\tselect {\n\t\tcase sc, ok := <-cc.dopts.scChan:\n\t\t\tif ok {\n\t\t\t\tcc.sc = &sc\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n    \n\t// å¯åŠ¨å­åç¨‹ï¼Œç›‘å¬scChanï¼Œè¿›è¡ŒserviceConfigçš„çƒ­æ›´\n\tif cc.dopts.scChan != nil {\n\t\tgo cc.scWatcher()\n\t}\n\n\tvar credsClone credentials.TransportCredentials\n\tif creds := cc.dopts.copts.TransportCredentials; creds != nil {\n\t\tcredsClone = creds.Clone()\n\t}\n    \n\t// balancerBuildçš„options\n\tcc.balancerBuildOpts = balancer.BuildOptions{\n\t\tDialCreds:        credsClone,\n\t\tCredsBundle:      cc.dopts.copts.CredsBundle,\n\t\tDialer:           cc.dopts.copts.Dialer,\n\t\tChannelzParentID: cc.channelzID,\n\t\tTarget:           cc.parsedTarget,\n\t}\n\n\t// Build the resolver.\n\t// åˆ›å»ºresovlerï¼Œå¹¶åŒ…è£…æˆresolverWrapper\n\trWrapper, err := newCCResolverWrapper(cc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build resolver: %v\", err)\n\t}\n\n\tcc.mu.Lock()\n\tcc.resolverWrapper = rWrapper\n\tcc.mu.Unlock()\n\t// A blocking dial blocks until the clientConn is ready.\n\t// é»˜è®¤Dialä¸ä¼šç­‰å¾…ç½‘ç»œè¿æ¥å®Œæˆï¼Œå¦‚æœæŒ‡å®šäº†blcokï¼Œåˆ™ä¼šé˜»å¡ç­‰å¾…ç½‘ç»œè¿æ¥å®Œæˆæ‰è¿”å›\n\tif cc.dopts.block {\n\t\tfor {\n\t\t\ts := cc.GetState()\n\t\t\t// å¦‚æœå·²ç»Ready\n\t\t\tif s == connectivity.Ready {\n\t\t\t\tbreak\n\t\t\t} else if cc.dopts.copts.FailOnNonTempDialError && s == connectivity.TransientFailure {\n\t\t\t\tif err = cc.blockingpicker.connectionError(); err != nil {\n\t\t\t\t\tterr, ok := err.(interface {\n\t\t\t\t\t\tTemporary() bool\n\t\t\t\t\t})\n\t\t\t\t\tif ok && !terr.Temporary() {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ç­‰å¾…çŠ¶æ€å˜æ›´\n\t\t\tif !cc.WaitForStateChange(ctx, s) {\n\t\t\t\t// ctx got timeout or canceled.\n\t\t\t\treturn nil, ctx.Err()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cc, nil\n}\n```\n\n\n\n##### æ€»ç»“\n\nåˆ°æ­¤ï¼Œå¯¹grpcå®¢æˆ·ç«¯çš„è¿æ¥åˆ›å»ºæµç¨‹åº”è¯¥æœ‰äº†ä¸€ä¸ªå¤§ä½“çš„äº†è§£ï¼Œå¹¶ä¸”æˆ‘ä»¬èƒ½å¤Ÿå¾ˆå®¹æ˜“çš„æ ¹æ®`Resolver`æ¥å£æä¾›è‡ªå·±çš„æœåŠ¡å‘ç°é€»è¾‘ã€‚","tags":["grpc - go"]},{"title":"grpc serverè§£æ","url":"/2019/07/22/grpc_serverè§£æ/","content":"\n`grpc`æ˜¯ç”±è°·æ­Œå¼€æºçš„ä¸€ä¸ªé«˜æ€§èƒ½ã€é€šç”¨çš„å¼€æº`rpc`æ¡†æ¶ï¼Œå…·ä½“çš„ä½¿ç”¨å¯ä»¥å‚è€ƒ[è¯¥æ–‡ç« ](<http://mcll.top/2018/12/21/grpc%E4%B8%8A%E6%89%8B%E4%BD%BF%E7%94%A8/>)ã€‚æœ¬æ–‡ä¸»è¦çœ‹ä¸€ä¸‹`go`ç‰ˆæœ¬çš„`grpc`çš„æœåŠ¡ç«¯å®ç°ã€‚\n\n### grpc server\n\næˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹å¯åŠ¨ä¸€ä¸ªgrpc serveræ—¶çš„ä»£ç ï¼š\n\n```go\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":6060\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ts := grpc.NewServer()\n\t// æ³¨å†ŒæœåŠ¡ï¼ŒEchoServerå®ç°äº†.protoä¸­å£°æ˜çš„æœåŠ¡æ¥å£\n\tproto.RegisterEchoSvcServer(s, &EchoServer{})\n\t// å¯åŠ¨æœåŠ¡\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œç¬¬6è¡Œåˆ›å»ºäº†ä¸€ä¸ªgrpc serverï¼Œç¬¬8è¡Œå°†å…·ä½“çš„æœåŠ¡æ³¨å†Œåˆ°serverä¸­ï¼Œç„¶åç¬¬10è¡Œå¼€å§‹å¯åŠ¨æœåŠ¡ã€‚\n\nå…¶ä¸­ï¼Œ`RegisterEchoSvcServer`è¿™ä¸ªå‡½æ•°ç”±æ’ä»¶`protoc-gen-go`é€šè¿‡`.proto`æ–‡ä»¶è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹å…¶å®ç°ï¼š\n\n```go\n// æœåŠ¡æè¿°ï¼Œç”±æ’ä»¶é€šè¿‡`.proto`æ–‡ä»¶è‡ªåŠ¨ç”Ÿæˆ\nvar _EchoSvc_serviceDesc = grpc.ServiceDesc{\n\tServiceName: \"proto.EchoSvc\", // æœåŠ¡å\n\tHandlerType: (*EchoSvcServer)(nil), // è¿™é‡Œå£°æ˜äº†è¯¥æœåŠ¡è¦å®ç°çš„æ¥å£\n    // æœåŠ¡å…·æœ‰çš„æ–¹æ³•åˆ—è¡¨\n\tMethods: []grpc.MethodDesc{\n\t\t{\n\t\t\tMethodName: \"Echo\", // rpcæ–¹æ³•å\n\t\t\tHandler:    _EchoSvc_Echo_Handler, // rpcè¯·æ±‚çš„handler\n\t\t},\n\t},\n    // streamæ–¹æ³•åˆ—è¡¨ï¼Œè¯¥æœåŠ¡æ²¡æœ‰\n\tStreams:  []grpc.StreamDesc{},\n\tMetadata: \"echo.proto\",\n}\n\nfunc RegisterEchoSvcServer(s *grpc.Server, srv EchoSvcServer) {\n    // ä¼ å…¥æœåŠ¡æè¿°å’Œå…·ä½“çš„æœåŠ¡å®ç°å¯¹è±¡\n\ts.RegisterService(&_EchoSvc_serviceDesc, srv)\n}\n```\n\nä¸Šé¢çš„_EchoSvc_serviceDescæ˜¯æœ‰æ’ä»¶æ ¹æ®æˆ‘ä»¬çš„æœåŠ¡å£°æ˜è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œgrpcä¸­çš„rpcæ–¹æ³•ä¸»è¦æœ‰ä¸¤ç§ç±»å‹ã€‚ç¬¬ä¸€ç§å°±æ˜¯å¸¸è§çš„æ™®é€šçš„rpcæ–¹æ³•ï¼Œç¬¬äºŒç§æ˜¯[stream rpcæ–¹æ³•](<https://grpc.io/docs/guides/concepts/>)\n\nå¯ä»¥çœ‹åˆ°ï¼Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯grpc serverçš„æœåŠ¡æ³¨å†Œæ–¹æ³•ï¼š\n\n```go\nfunc (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {\n\t// sséœ€è¦å®ç°çš„æ¥å£ç±»å‹\n    ht := reflect.TypeOf(sd.HandlerType).Elem()\n    // sså®é™…çš„ç±»å‹\n\tst := reflect.TypeOf(ss)\n    // sséœ€è¦å®ç°sd.HandlerTypeä¸­æŒ‡å®šçš„æ¥å£\n\tif !st.Implements(ht) {\n\t\tgrpclog.Fatalf(\"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v\", st, ht)\n\t}\n    // æ³¨å†Œæ¥å£åˆ°server\n\ts.register(sd, ss)\n}\n\nfunc (s *Server) register(sd *ServiceDesc, ss interface{}) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.printf(\"RegisterService(%q)\", sd.ServiceName)\n    // å¦‚æœserverå·²ç»å¼€å§‹è¿è¡Œï¼Œä¸å…è®¸æ³¨å†Œ\n\tif s.serve {\n\t\tgrpclog.Fatalf(\"grpc: Server.RegisterService after Server.Serve for %q\", sd.ServiceName)\n\t}\n    // åŒä¸€ä¸ªæœåŠ¡åä¸å…è®¸é‡å¤æ³¨å†Œ\n\tif _, ok := s.m[sd.ServiceName]; ok {\n\t\tgrpclog.Fatalf(\"grpc: Server.RegisterService found duplicate service registration for %q\", sd.ServiceName)\n\t}\n\tsrv := &service{\n\t\tserver: ss, // å…·ä½“çš„æœåŠ¡å®ç°å¯¹è±¡\n\t\tmd:     make(map[string]*MethodDesc), // æ™®é€šrpcæ–¹æ³•æè¿°\n\t\tsd:     make(map[string]*StreamDesc), // streamç±»å‹çš„rpcæ–¹æ³•æè¿°\n\t\tmdata:  sd.Metadata,\n\t}\n    // æ·»åŠ æ–¹æ³•æè¿°åˆ°srvçš„md\n\tfor i := range sd.Methods {\n\t\td := &sd.Methods[i]\n\t\tsrv.md[d.MethodName] = d\n\t}\n    // æ·»åŠ æ–¹æ³•æè¿°åˆ°srv.sd\n\tfor i := range sd.Streams {\n\t\td := &sd.Streams[i]\n\t\tsrv.sd[d.StreamName] = d\n\t}\n    // å°†serviceræ·»åŠ åˆ°serverçš„servicesè¡¨ä¸­\n\ts.m[sd.ServiceName] = srv\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œgrpcçš„serverä¸­æœ‰ä¸€ä¸ªserviceè¡¨ï¼Œç›¸å½“äºhttpæœåŠ¡ä¸­çš„è·¯ç”±è¡¨ã€‚\n\næ¥ä¸‹æ¥çœ‹ä¸€ä¸‹ï¼Œgrpc serverå¦‚æœæä¾›æœåŠ¡ï¼š\n\n```go\nfunc (s *Server) Serve(lis net.Listener) error {\n\ts.mu.Lock()\n\ts.printf(\"serving\")\n    // å¼€å§‹è¿è¡Œ\n\ts.serve = true\n \t\n    s.serveWG.Add(1)\n\tdefer func() {\n\t\ts.serveWG.Done()\n\t\tselect {\n\t\t// serveä¼šé˜»å¡ç›´åˆ°é€€å‡ºæœåŠ¡\n\t\tcase <-s.quit:\n\t\t\t<-s.done\n\t\tdefault:\n\t\t}\n\t}()\n\n    // æŠŠlisæ·»åŠ åˆ°lisè¡¨ä¸­ï¼Œå¯ä»¥çœ‹åˆ°ä¸€ä¸ªserverå¯ä»¥åŒæ—¶ç›‘å¬å¤šä¸ªç«¯å£æä¾›æœåŠ¡\n\tls := &listenSocket{Listener: lis}\n\ts.lis[ls] = true\n\n\ts.mu.Unlock()\n\n\tdefer func() {\n        // æœåŠ¡é€€å‡ºæ—¶ï¼Œä»lisè¡¨ä¸­ç§»é™¤\n\t\ts.mu.Lock()\n\t\tif s.lis != nil && s.lis[ls] {\n\t\t\tls.Close()\n\t\t\tdelete(s.lis, ls)\n\t\t}\n\t\ts.mu.Unlock()\n\t}()\n\n\tfor {\n        // æ¥å—å®¢æˆ·ç«¯è¯·æ±‚\n\t\trawConn, err := lis.Accept()\n\t\tif err != nil {\n\t\t\t// é”™è¯¯å¤„ç†...\n\t\t}\n\t\t\n\t\ts.serveWG.Add(1)\n\t\tgo func() {\n            // å¤„ç†å®¢æˆ·ç«¯è¿æ¥\n\t\t\ts.handleRawConn(rawConn)\n\t\t\ts.serveWG.Done()\n\t\t}()\n\t}\n}\n\nfunc (s *Server) handleRawConn(rawConn net.Conn) {\n    // è®¾ç½®readå’Œwriteçš„Deadline\n\trawConn.SetDeadline(time.Now().Add(s.opts.connectionTimeout))\n\t// å¯èƒ½å¼€å¯äº†tls/sslï¼Œéœ€è¦è¯ä¹¦è®¤è¯ï¼Œå®Œæˆtls/sslæ¡æ‰‹\n    conn, authInfo, err := s.useTransportAuthenticator(rawConn)\n\tif err != nil {\n\t\t// ...\n\t\treturn\n\t}\n\n\ts.mu.Lock()\n\tif s.conns == nil {\n\t\ts.mu.Unlock()\n\t\tconn.Close()\n\t\treturn\n\t}\n\ts.mu.Unlock()\n\n\t// grpcæ˜¯åŸºäºhttp2åè®®è¿›è¡Œé€šä¿¡çš„ï¼Œå®Œæˆhttp2åè®®çš„æ¡æ‰‹\n\tst := s.newHTTP2Transport(conn, authInfo)\n\tif st == nil {\n\t\treturn\n\t}\n\t// å‰é¢è®¾ç½®Deadlineæ˜¯ä¸ºäº†å°½å¿«å®Œæˆæ¡æ‰‹æ“ä½œ\n    // å› ä¸ºå®¢æˆ·ç«¯è¿æ¥ä¹‹åï¼Œå¹¶ä¸æ˜¯ä¸€ç›´åœ¨å‘é€è¯·æ±‚ï¼Œè®¾ç½®Deadlineæ²¡æœ‰æ„ä¹‰ï¼Œå› æ­¤è¿™é‡Œå–æ¶ˆdeadlineçš„è®¾ç½®\n\trawConn.SetDeadline(time.Time{})\n    // ä¿å­˜å®¢æˆ·ç«¯çš„http2è¿æ¥\n\tif !s.addConn(st) {\n\t\treturn\n\t}\n    \n\tgo func() {\n        // ç­‰å¾…å®¢æˆ·ç«¯rpcè¯·æ±‚åˆ°æ¥ï¼Œå¹¶æä¾›æœåŠ¡\n        // åŸºäºhttp2çš„å¤šè·¯å¤ç”¨ï¼Œå®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨ä¸€æ¡è¿æ¥åŒæ—¶å‘é€å¤šä¸ªè¯·æ±‚\n\t\ts.serveStreams(st)\n        // ç§»é™¤å®¢æˆ·ç«¯çš„http2è¿æ¥\n\t\ts.removeConn(st)\n\t}()\n}\n\nfunc (s *Server) serveStreams(st transport.ServerTransport) {\n\tdefer st.Close()\n\tvar wg sync.WaitGroup\n\n    // HandleStreamsæ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼šhandlerå’Œtracer\n    // è¯¥æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°ï¼šhanlderå’Œtracer\n    // è¯¥æ–¹æ³•å¾ªç¯è¯»å–å®¢æˆ·ç«¯è¿æ¥å‘é€è¿‡æ¥çš„å¸§ï¼š\n    //    1. å¦‚æœæ˜¯HEADERå¸§ï¼Œè¯´æ˜æœ‰æ–°çš„rpcè¯·æ±‚åˆ°æ¥ï¼Œå›è°ƒhandler\n    //    2. å¦‚æœæ˜¯DATAå¸§ï¼Œå°†æ•°æ®åˆ†å‘åˆ°å¯¹åº”çš„stream\n    //    3. ...\n\tst.HandleStreams(func(stream *transport.Stream) {\n\t\twg.Add(1)\n        // å›è°ƒä¸­å¼€å¯å­åç¨‹ï¼Œå¤„ç†rpcè¯·æ±‚\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n            // grpcåŸºäºhttp2ï¼ŒåŒä¸€æ¡è¿æ¥ä¼šåˆ†æˆå¤šä¸ªstreamï¼Œæ¯ä¸ªrpcè¯·æ±‚ä½¿ç”¨ä¸€ä¸ªstream\n            // è¿™æ ·å¤šä¸ªå®¢æˆ·ç«¯è¯·æ±‚å¯ä»¥å¤ç”¨åŒä¸€æ¡è¿æ¥\n            // å½“æœ‰æ–°çš„rpcè¯·æ±‚åˆ°æ¥ï¼Œä¼šè¿›å…¥è¯¥å›è°ƒï¼Œç„¶åè°ƒç”¨serverçš„handleStreamå¤„ç†rpcè¯·æ±‚\n\t\t\ts.handleStream(st, stream, s.traceInfo(st, stream))\n\t\t}()\n\t}, func(ctx context.Context, method string) context.Context {\n\t\tif !EnableTracing {\n\t\t\treturn ctx\n\t\t}\n\t\ttr := trace.New(\"grpc.Recv.\"+methodFamily(method), method)\n\t\treturn trace.NewContext(ctx, tr)\n\t})\n\twg.Wait()\n}\n```\n\næ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹serverçš„handleStreamæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å¤„ç†rpcè¯·æ±‚ï¼š\n\n```go\nfunc (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {\n    // rpcæ‰€è¯·æ±‚çš„æ–¹æ³•ï¼šæœåŠ¡å/æ–¹æ³•å\n\tsm := stream.Method()\n    // å»æ‰å¼€å¤´çš„`/`\n\tif sm != \"\" && sm[0] == '/' {\n\t\tsm = sm[1:]\n\t}\n\tpos := strings.LastIndex(sm, \"/\")\n\tif pos == -1 {\n        // åº”è¯¥æ»¡è¶³ï¼šæœåŠ¡å/æ–¹æ³•å\n        // ...\n\t\treturn\n\t}\n    // è¯·æ±‚çš„æœåŠ¡\n\tservice := sm[:pos]\n    // è¯·æ±‚çš„æ–¹æ³•\n\tmethod := sm[pos+1:]\n    // åœ¨serverçš„æœåŠ¡è¡¨ä¸­æŸ¥æ‰¾å¯¹åº”çš„æœåŠ¡å®ç°\n    // serverè¿è¡Œæ—¶ä¸å…è®¸æ³¨å†Œæ–°çš„serviceï¼Œå› æ­¤è¿™é‡Œå¹¶å‘è¯»ï¼Œä¸éœ€è¦åŠ é”\n\tsrv, ok := s.m[service]\n    // å¦‚æœè¯·æ±‚çš„æœåŠ¡ä¸å­˜åœ¨\n\tif !ok {\n        // å¦‚æœserverçš„é…ç½®ä¸­ï¼ŒæŒ‡å®šäº†å¤„ç†æœªçŸ¥æœåŠ¡çš„æ–¹æ³•ï¼Œåˆ™äº¤ç”±å…¶å¤„ç†\n\t\tif unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil {\n\t\t\ts.processStreamingRPC(t, stream, nil, unknownDesc, trInfo)\n\t\t\treturn\n\t\t}\n        // ...\n\t\treturn\n\t}\n\t// å…ˆåœ¨æ™®é€šçš„rpcæ–¹æ³•è¡¨ä¸­æŸ¥æ‰¾\n\tif md, ok := srv.md[method]; ok {\n        // å¤„ç†æ™®é€šçš„rpcæ–¹æ³•\n\t\ts.processUnaryRPC(t, stream, srv, md, trInfo)\n\t\treturn\n\t}\n    // å°è¯•åœ¨strem rpcæ‰¾\n\tif sd, ok := srv.sd[method]; ok {\n        // å¤„ç†stream rpc\n\t\ts.processStreamingRPC(t, stream, srv, sd, trInfo)\n\t\treturn\n\t}\n    \n    // è¯·æ±‚æœªçŸ¥æ–¹æ³•\n    \n    // ...\n\tif unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil {\n\t\ts.processStreamingRPC(t, stream, nil, unknownDesc, trInfo)\n\t\treturn\n\t}\n \t\n    // ...\n}\n```\n\né™äºç¯‡å¹…ï¼Œæˆ‘ä»¬è¿™é‡Œä¸»è¦çœ‹ä¸€ä¸‹`processUnaryRPC`æ–¹æ³•ï¼Œ`processStreamingRPC`æ–¹æ³•å¤§åŒå°å¼‚ï¼š\n\n```go\nfunc (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {\n    \n    // ...\n    \n\tvar comp, decomp encoding.Compressor\n\tvar cp Compressor\n\tvar dc Decompressor\n\t// ...\t\n    // è®¾ç½®å‹ç¼©é€‰é¡¹\n\tif s.opts.cp != nil {\n\t\tcp = s.opts.cp\n\t\tstream.SetSendCompress(cp.Type())\n\t} else if rc := stream.RecvCompress(); rc != \"\" && rc != encoding.Identity {\n\t\t// Legacy compressor not specified; attempt to respond with same encoding.\n\t\tcomp = encoding.GetCompressor(rc)\n\t\tif comp != nil {\n\t\t\tstream.SetSendCompress(rc)\n\t\t}\n\t}\n\n\tvar payInfo *payloadInfo\n\tif sh != nil || binlog != nil {\n\t\tpayInfo = &payloadInfo{}\n\t}\n\t// æ¥æ”¶å¹¶è§£å‹ç¼©æ•°æ®\n\td, err := recvAndDecompress(&parser{r: stream}, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)\n\tif err != nil {\n\t\t// ...\n\t\treturn err\n\t}\n\n\t// dfæ–¹æ³•ç”¨äºä»æ¥æ”¶çš„æ•°æ®åŒ…dä¸­ååºåˆ—åŒ–ä¸ºv\n\tdf := func(v interface{}) error {\n        // ååºåˆ—åŒ–è¯·æ±‚å‚æ•°\n\t\tif err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil {\n\t\t\treturn status.Errorf(codes.Internal, \"grpc: error unmarshalling request: %v\", err)\n\t\t}\n\t\t// ...\n\t\treturn nil\n\t}\n    \n\t// åˆ›å»ºcontextï¼Œè¯¥æ–¹æ³•å’Œheaderçš„è·å–ä»¥åŠå†™å…¥æœ‰å…³ï¼Œä¸‹é¢åˆ†æ\n\tctx := NewContextWithServerTransportStream(stream.Context(), stream)\n\t// æ‰§è¡Œhandlerï¼Œè¿™ä¸ªhandleræ˜¯é€šè¿‡.protoæ–‡ä»¶ç”Ÿæˆçš„ï¼Œè¯¥æ–¹æ³•å†…ä¼šå»è°ƒç”¨serverçš„å¯¹åº”çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›å¯¹åº”çš„resp\n    // è¿™é‡Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ååºåˆ—åŒ–æ–¹æ³•ï¼Œç¬¬å››ä¸ªå‚æ•°æ˜¯åˆ›å»ºserveræ—¶æŒ‡å®šçš„interceptoré€‰é¡¹\n\treply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)\n\t// å¦‚æœè¿”å›çš„é”™è¯¯ï¼Œè¿™é‡Œçš„errå¯èƒ½æ˜¯ç”±æˆ‘ä»¬çš„rpcæ–¹æ³•è¿”å›çš„\n\tif appErr != nil {\n\t\tappStatus, ok := status.FromError(appErr)\n\t\tif !ok {\n\t\t\t// å¦‚è¿‡æ²¡æœ‰å®ç° interface{GRPCStatus()*Status} æ¥å£\n\t\t\tappErr = status.Error(codes.Unknown, appErr.Error())\n\t\t\tappStatus, _ = status.FromError(appErr)\n\t\t}\n\t\t// ...\n\t\t// å†™å…¥é”™è¯¯ä¿¡æ¯åˆ°streamä¸­\n\t\tif e := t.WriteStatus(stream, appStatus); e != nil {\n\t\t\tgrpclog.Warningf(\"grpc: Server.processUnaryRPC failed to write status: %v\", e)\n\t\t}\n\t\t// ...\n\t\treturn appErr\n\t}\n \n\topts := &transport.Options{Last: true}\n\t// åºåˆ—åŒ–replyç»™å®¢æˆ·ç«¯\n\tif err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil {\n\t\t// ...\n\t\treturn err\n\t}\n\n\terr = t.WriteStatus(stream, status.New(codes.OK, \"\"))\n    \n\treturn err\n}\n\n```\n\nä¸Šé¢çš„ä»£ç ç•¥æœ‰åˆ å‡ï¼Œä¸»è¦æ˜¯åˆ æ‰ä¸€äº›å’Œç»Ÿè®¡ã€traceä»¥åŠæ—¥å¿—ç›¸å…³çš„ä»£ç ã€‚ä¸»è¦çš„é€»è¾‘å°±æ˜¯ä»streamè¯»å–è¯·æ±‚å‚å‚æ•°ï¼Œååºåˆ—åŒ–åè°ƒç”¨methodDescä¸­çš„handleræ–¹æ³•ï¼Œç„¶åæŠŠè¿”å›çš„å†…å®¹åºåˆ—åŒ–åå†™å…¥streamè¿”å›ç»™å®¢æˆ·ç«¯ã€‚\n\næˆ‘ä»¬çŸ¥é“ï¼Œgrpcæ˜¯åŸºäºhttp2åè®®çš„ï¼Œå› æ­¤ä¹Ÿæ˜¯å­˜åœ¨`header`çš„ï¼Œgrpcå’Œhttpä¸€æ ·ï¼Œå¯ä»¥è®¾ç½®å’Œè·å–è¯·æ±‚çš„headerã€‚åœ¨æœåŠ¡ç«¯ï¼Œä¸»è¦æœ‰è·å–å®¢æˆ·ç«¯ä¼ é€’è¿‡æ¥çš„headerä»¥åŠä¼ é€’headerç»™å®¢æˆ·ç«¯ä¸¤ä¸ªæ“ä½œã€‚\n\næˆ‘ä»¬å…ˆçœ‹ä¸Šé¢å‡ºç°çš„`NewContextWithServerTransportStream`æ–¹æ³•ï¼š\n\n```go\n// è¯¥æ¥å£ç”¨äºæœåŠ¡ç«¯è®¾ç½®ä¼ é€’ç»™å®¢æˆ·ç«¯çš„header\ntype ServerTransportStream interface {\n\tMethod() string\n\tSetHeader(md metadata.MD) error\n\tSendHeader(md metadata.MD) error\n\tSetTrailer(md metadata.MD) error\n}\n\nfunc NewContextWithServerTransportStream(ctx context.Context, stream ServerTransportStream) context.Context {\n    // åŸºäºctxåˆ›å»ºæ–°çš„contextï¼Œå¹¶æŠŠstreamä¿å­˜åˆ°æ–°çš„contextä¸­\n    // å½“è°ƒç”¨grpc.SetHeaderæ—¶ï¼Œä¼šæ‰§è¡Œstream.SetHeaderæ–¹æ³•\n\treturn context.WithValue(ctx, streamKey{}, stream)\n}\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨`processUnaryRPC`æ–¹æ³•ä¸­ï¼Œå¯¹è¯¥æ–¹æ³•çš„è°ƒç”¨å¦‚ä¸‹ï¼š\n\n```go\nfunc (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {\n \t// ...\n\tctx := NewContextWithServerTransportStream(stream.Context(), stream)\n\treply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)\n \t// ...\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œä¼ å…¥çš„æ˜¯å½“å‰è¯·æ±‚çš„`stream`çš„`context`ï¼Œæ¥ä¸‹æ¥çœ‹ä¸€ä¸‹`stream`çš„`context`åˆ›å»ºï¼š\n\n```go\nfunc (t *http2Server) operateHeaders(frame *http2.MetaHeadersFrame, handle func(*Stream), traceCtx func(context.Context, string) context.Context) (fatal bool) {\n\tstreamID := frame.Header().StreamID\n\tstate := decodeState{serverSide: true}\n    // è§£æheaderå¸§ï¼ŒåŒ…æ‹¬è·å–headerä¸­çš„å„ä¸ªå­—æ®µ\n\tif err := state.decodeHeader(frame); err != nil {\n\t \t// ...\n\t\treturn false\n\t}\n\n\tbuf := newRecvBuffer()\n\ts := &Stream{\n\t\tid:             streamID,\n\t\tst:             t,\n\t\tbuf:            buf,\n\t\tfc:             &inFlow{limit: uint32(t.initialWindowSize)},\n\t\trecvCompress:   state.encoding,\n\t\tmethod:         state.method,\n\t\tcontentSubtype: state.contentSubtype,\n\t}\n \n    // ...\n    \n \t// é™¤äº†grpcé¢„å®šä¹‰çš„å‡ ä¸ªheaderä¹‹å¤–ï¼Œå…¶ä»–headeréƒ½ä¿å­˜åˆ°mdataä¸­\n\tif len(state.mdata) > 0 {\n        // è¿™é‡Œä¼šå°†state.mdataä¿å­˜åˆ°æ–°çš„contextä¸­\n\t\ts.ctx = metadata.NewIncomingContext(s.ctx, state.mdata)\n\t}\n    // ...\n\thandle(s)\n\treturn false\n}\n\nfunc NewIncomingContext(ctx context.Context, md MD) context.Context {\n\treturn context.WithValue(ctx, mdIncomingKey{}, md)\n}\n```\n\nå½“æ”¶åˆ°ä¸€ä¸ª`Header`å¸§ï¼Œå°±è¡¨æ˜æœ‰æ–°çš„rpcè¯·æ±‚åˆ°æ¥ï¼Œè¿™æ—¶å€™å°±ä¼šè§£æheaderå¸§å¹¶åˆ›å»ºstreamï¼Œåœ¨åˆ›å»ºstreamçš„æ—¶å€™ï¼Œä¼šæŠŠç”¨æˆ·è‡ªå®šä¹‰çš„headerå­—æ®µä¿å­˜åˆ°stream.contextä¸­\n\nåœ¨æˆ‘ä»¬å®é™…ç¼–ç æ—¶ï¼Œå¯ä»¥é€šè¿‡`metadata`åŒ…æ¥è¯»å–å®¢æˆ·ç«¯ä¼ é€’è¿‡æ¥çš„`header`ï¼š\n\n```go\nfunc (EchoServer) Echo(ctx context.Context, req *proto.EchoReq) (resp *proto.EchoResp, err error) {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif ok {\n\t\tlog.Printf(\"%s: %v\", md.Get(\"key\"))\n\t}\n    \n\treturn &proto.EchoResp{\n\t\tMsg: VERSION,\n\t}, err\n}\n```\n\nè€Œè®¾ç½®headerè¿”å›ç»™å®¢æˆ·ç«¯å¯ä»¥å¦‚ä¸‹ï¼š\n\n```go\nfunc (EchoServer) Echo(ctx context.Context, req *proto.EchoReq) (resp *proto.EchoResp, err error) {\n\t// æœ€ç»ˆä¼šè®¾ç½®streamçš„header\n\tgrpc.SetHeader(ctx, metadata.Pairs(\"key1\", \"val1\"))\n\n\treturn &proto.EchoResp{\n\t\tMsg: VERSION,\n\t}, err\n}\n```\n\næ¥ä¸‹æ¥çœ‹ä¸€ä¸‹å†™å›è¿”å›å†…å®¹ç»™å®¢æˆ·ç«¯çš„é€»è¾‘ï¼š\n\n```go\nfunc (s *Server) sendResponse(t transport.ServerTransport, stream *transport.Stream, msg interface{}, cp Compressor, opts *transport.Options, comp encoding.Compressor) error {\n    // ååºåˆ—åŒ–è¿”å›å†…å®¹\n\tdata, err := encode(s.getCodec(stream.ContentSubtype()), msg)\n\tif err != nil {\n\t\tgrpclog.Errorln(\"grpc: server failed to encode response: \", err)\n\t\treturn err\n\t}\n    // å‹ç¼©\n\tcompData, err := compress(data, cp, comp)\n\tif err != nil {\n\t\tgrpclog.Errorln(\"grpc: server failed to compress response: \", err)\n\t\treturn err\n\t}\n    // åˆ›å»ºæ¶ˆæ¯å¤´éƒ¨\n\thdr, payload := msgHeader(data, compData)\n\t// TODO(dfawley): should we be checking len(data) instead?\n\tif len(payload) > s.opts.maxSendMessageSize {\n\t\treturn status.Errorf(codes.ResourceExhausted, \"grpc: trying to send message larger than max (%d vs. %d)\", len(payload), s.opts.maxSendMessageSize)\n\t}\n    // å†™å›å†…å®¹\n\terr = t.Write(stream, hdr, payload, opts)\n\tif err == nil && s.opts.statsHandler != nil {\n\t\ts.opts.statsHandler.HandleRPC(stream.Context(), outPayload(false, msg, data, payload, time.Now()))\n\t}\n\treturn err\n}\n\nfunc (t *http2Server) Write(s *Stream, hdr []byte, data []byte, opts *Options) error {\n    // å¦‚æœheaderè¿˜æ²¡æœ‰å‘é€ï¼Œå…ˆå‘é€header\n\tif !s.isHeaderSent() { // Headers haven't been written yet.\n\t\tif err := t.WriteHeader(s, nil); err != nil {\n\t\t\treturn status.Errorf(codes.Internal, \"transport: %v\", err)\n\t\t}\n\t} else {\n\t\t// ...\n\t}\n\n\temptyLen := http2MaxFrameLen - len(hdr)\n\tif emptyLen > len(data) {\n\t\temptyLen = len(data)\n\t}\n\thdr = append(hdr, data[:emptyLen]...)\n\tdata = data[emptyLen:]\n    // æ•°æ®å¸§\n\tdf := &dataFrame{\n\t\tstreamID: s.id,\n\t\th:        hdr,\n\t\td:        data,\n\t\tonEachWrite: func() {\n\t\t\tatomic.StoreUint32(&t.resetPingStrikes, 1)\n\t\t},\n\t}\n\tif err := s.wq.get(int32(len(hdr) + len(data))); err != nil {\n\t\tselect {\n\t\tcase <-t.ctx.Done():\n\t\t\treturn ErrConnClosing\n\t\tdefault:\n\t\t}\n\t\treturn ContextErr(s.ctx.Err())\n\t}\n    // æŠŠæ•°æ®å¸§åŠ å…¥åˆ°å‘é€é˜Ÿåˆ—\n\treturn t.controlBuf.put(df)\n}\n```\n\næœ€åï¼Œçœ‹ä¸€ä¸‹methodDescä¸­çš„handlerï¼Œè¿™ä¸ªæ˜¯ç”±æ’ä»¶è‡ªåŠ¨ç”Ÿæˆçš„åŒ…è£…æ–¹æ³•ï¼š\n\n```go\nfunc (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {\n    // ...\n    reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)\n    // ...\n}\n```\n\n```go\nfunc _EchoSvc_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {\n\t// \n    in := new(EchoReq)\n    // decæ˜¯ä¼ å…¥çš„ååºåˆ—åŒ–æ–¹æ³•\n\tif err := dec(in); err != nil {\n\t\treturn nil, err\n\t}\n    \n    // å¦‚æœæ²¡æœ‰æŒ‡å®šinterceptor\n\tif interceptor == nil {\n        // ç›´æ¥è°ƒç”¨serviceå¯¹åº”çš„æ–¹æ³•\n\t\treturn srv.(EchoSvcServer).Echo(ctx, in)\n\t}\n    \n    // æœåŠ¡ä¿¡æ¯\n\tinfo := &grpc.UnaryServerInfo{\n\t\tServer:     srv,\n\t\tFullMethod: \"/proto.EchoSvc/Echo\",\n\t}\n    \n    // å›è°ƒhandler\n\thandler := func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn srv.(EchoSvcServer).Echo(ctx, req.(*EchoReq))\n\t}\n    // å…ˆæ‰§è¡Œinterceptorï¼Œç„¶ååœ¨æ‰§è¡Œhandler\n\treturn interceptor(ctx, in, info, handler)\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œç”¨æˆ·åˆ›å»º`server`æ—¶ï¼Œå¦‚æœè®¾ç½®äº†`interceptor`é€‰é¡¹ï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œå…·ä½“çš„æœåŠ¡æ–¹æ³•å‰ï¼Œä¼šå…ˆæ‰§è¡Œç”¨æˆ·è®¾ç½®çš„`interceptor`ï¼Œå£°æ˜å¦‚ä¸‹ï¼š\n\n```go\ntype UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)\n```\n\nåœ¨`interceptor`ä¸­ï¼Œå¯ä»¥åšä¸€äº›é€šç”¨å¤„ç†ï¼Œæ¯”å¦‚æ—¥å¿—è®°å½•ï¼Œå¼‚å¸¸å¤„ç†æˆ–è€…è¯·æ±‚æ‹¦æˆªç­‰\n\n\n\n\n\n","tags":["grpc - go"]},{"title":"mmapä½¿ç”¨","url":"/2019/07/22/mmapä½¿ç”¨/","content":"\n`mmap`å¯ä»¥è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ä¸­åˆ›å»ºå†…å­˜æ˜ å°„ï¼Œå¸¸ç”¨æ¥å°†ç£ç›˜æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜ï¼Œè¯»å†™æ–‡ä»¶è½¬å˜æˆè¯»å†™å¯¹åº”çš„å†…å­˜\n\nä½¿ç”¨`mmap`è¯»å†™æ–‡ä»¶ï¼Œé€šå¸¸æ¯”æ™®é€šçš„`read`å’Œ`write`ç³»ç»Ÿè°ƒç”¨è¦æ›´å¿«ï¼š\n\n- ç›´æ¥æ“ä½œå†…å­˜ï¼Œé¿å…äº†ç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œï¼Œä»è€Œé¿å…ç”¨æˆ·æ€/å†…æ ¸æ€ä¹‹é—´çš„åˆ‡æ¢å¼€é”€\n- ç›´æ¥è¯»å†™å†…å­˜ï¼Œä¸éœ€è¦ç»è¿‡å†…æ ¸ç¼“å†²åŒºï¼Œå‡å°‘æ•°æ®æ‹·è´\n\nç”¨æˆ·è®¿æ˜ å°„çš„å†…å­˜æ—¶ï¼Œå¦‚æœç£ç›˜æ•°æ®è¿˜æ²¡æœ‰åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œä¼šè§¦å‘ç¼ºé¡µå¼‚å¸¸ï¼Œç„¶åæ“ä½œç³»ç»Ÿä¼šä»¥`page`ä¸ºå•ä½å°†ç£ç›˜æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼›å¦‚æœå†…å­˜æ•°æ®è¢«ä¿®æ”¹äº†ï¼Œæ“ä½œç³»ç»Ÿä¼šå°†è„é¡µå›å†™åˆ°å¯¹åº”çš„æ–‡ä»¶ä¸­ï¼ˆè„é¡µå›å†™å¹¶ä¸æ˜¯å®æ—¶çš„ï¼‰ã€‚ç¼ºé¡µå¼‚å¸¸çš„å¤„ç†å¼€é”€ä¼šæ¯”è¾ƒå¤§ï¼Œå°¤å…¶æ˜¯å½“ç‰©ç†å†…å­˜ä¸è¶³æ—¶ï¼Œè¿˜ä¼šæ¶‰åŠåˆ°å†…å­˜é¡µçš„æ·˜æ±°ï¼Œå¦‚æœè¢«æ·˜æ±°çš„å†…å­˜é¡µæ˜¯è„é¡µçš„è¯ï¼Œè¿˜éœ€è¦å°†å…¶åŒæ­¥åˆ°ç£ç›˜ä¸­ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½¿ç”¨`mmap`æ˜ å°„å†…å­˜ï¼Œå¯èƒ½ä¼šé¢‘ç¹çš„è§¦å‘ç¼ºé¡µå¼‚å¸¸ï¼Œä»è€Œå¯¼è‡´æ€§èƒ½ä¸‹é™ï¼Œç”šè‡³ä¸å¦‚ç›´æ¥ä½¿ç”¨`read/write`ç³»ç»Ÿè°ƒç”¨ï¼Œæ¯”å¦‚ç‰©ç†å†…å­˜å¾ˆå°ï¼Œè€Œæ˜ å°„çš„æ–‡ä»¶å¾ˆå¤§æ—¶ã€‚\n\nè€Œä¸”ä½¿ç”¨`mmap`å¹¶ä¸ä¼šæ›´æ”¹æ˜ å°„æ–‡ä»¶çš„å¤§å°ï¼Œå½“éœ€è¦æ›´æ”¹æ–‡ä»¶å¤§å°æ—¶ï¼Œéœ€è¦é‡æ–°æ˜ å°„ã€‚\n\n\n\n`mmap`é™¤äº†æ”¯æŒå°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜ï¼Œè¿˜æ”¯æŒåŒ¿åæ˜ å°„ï¼ŒåŒ¿åæ˜ å°„ä¸éœ€è¦åº•å±‚æ–‡ä»¶ã€‚åŒ¿åæ˜ å°„çš„å†…å­˜ä¹Ÿå¯ä»¥åœ¨å¤šä¸ªè¿›ç¨‹é—´å…±äº«ï¼Œå› æ­¤å¯ä»¥ç”¨æ¥å®ç°è¿›ç¨‹é—´çš„å†…å­˜å…±äº«é€šä¿¡ã€‚`go`è¿è¡Œæ—¶çš„å†…å­˜ç®¡ç†ï¼Œä¾¿æ˜¯ä½¿ç”¨åŒ¿åæ˜ å°„å‘æ“ä½œç³»ç»Ÿç”³è¯·äº†ä¸€å—å¤§å†…å­˜ï¼Œç„¶ååŸºäº`tcmalloc`è¿›è¡Œå†…å­˜ç®¡ç†ã€‚\n\n\n\n### åœ¨goä¸­ä½¿ç”¨mmap\n\n`mmap`ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨æœ‰ï¼š\n\n- mmapï¼šåˆ›å»ºå†…å­˜æ˜ å°„\n- munmapï¼šå–æ¶ˆå†…å­˜æ˜ å°„\n- msyncï¼šåŒæ­¥å†…å­˜åˆ°ç£ç›˜æ–‡ä»¶ï¼›å†…å­˜çš„ä¿®æ”¹å¹¶ä¸æ˜¯å®æ—¶å†™å›ç£ç›˜çš„ï¼Œå½“å¯¹å®æ—¶æ€§è¦æ±‚å¾ˆé«˜ï¼Œæ¯”å¦‚æ•°æ®åº“çš„å†™æ“ä½œï¼Œéœ€è¦åœ¨å†™å†…å­˜åæ‰‹åŠ¨åˆ·æ–°åˆ°ç£ç›˜ä¸­\n\næ¥ä¸‹æ¥é€šè¿‡ä¸€ä¸ªå®ä¾‹çœ‹ä¸€ä¸‹å¦‚æœåœ¨goä¸­ä½¿ç”¨è¿™å‡ ä¸ªæ¥å£ï¼š\n\n```go\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc main() {\n    // è·å–intç±»å‹çš„å¤§å°\n\tconst INT_SIZE = unsafe.Sizeof(int(0))\n    // è¿™é‡Œa.txtæ˜¯æˆ‘ä»¬è¦æ˜ å°„çš„åº•å±‚æ–‡ä»¶\n\tfd, err := os.OpenFile(\"a.txt\", os.O_RDWR|os.O_CREATE, os.ModePerm)\n\tcheckErr(err)\n\n\tinfo, _ := fd.Stat()\n    // mmapä¸ä¼šæ›´æ”¹åº•å±‚æ–‡ä»¶çš„å¤§å°ï¼Œæˆ‘ä»¬è¦ç¡®ä¿è®¿é—®çš„æ˜ å°„åœ°å€ä¸ä¼šè¶…è¿‡æ–‡ä»¶å¤§å°ï¼Œå¦åˆ™ä¼španic\n    // è¿™é‡Œè®¾ç½®ä¸€ä¸‹åº•å±‚æ–‡ä»¶å¤§å°\n\tif info.Size() != int64(INT_SIZE) {\n\t\tfd.Truncate(int64(INT_SIZE))\n\t}\n\n    // ä½¿ç”¨syscallçš„mmapæ¥å£ï¼Œåˆ›å»ºå†…å­˜æ˜ å°„\n    // mmapæ¥å£ç›¸æ¯”posixæ¥å£ï¼Œå°‘äº†ä¸€ä¸ªaddrå‚æ•°ï¼Œå¦‚æœæœ‰éœ€è¦å¯ä»¥ä½¿ç”¨syscall.Syscall6æ¥å£\n    // MAP_SHAREDæŒ‡å®šæ˜ å°„çš„ç±»å‹ï¼Œè¯¥æ¨¡å¼ä¸‹å¯¹æ˜ å°„ç©ºé—´çš„æ›´æ–°å¯¹å…¶ä»–è¿›ç¨‹çš„æ˜ å°„å¯è§ï¼Œå¹¶ä¸”ä¼šå†™å›åº•å±‚æ–‡ä»¶\n    // æ˜ å°„å†…å­˜ä¼šé€šè¿‡[]byteçš„å½¢å¼è¿”å›\n\tbuf, err := syscall.Mmap(int(fd.Fd()), 0, int(INT_SIZE), syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)\n\t// mmapè¿”å›ä¹‹åï¼Œåº•å±‚æ–‡ä»¶çš„è®¾å¤‡æè¿°ç¬¦å¯ä»¥ç«‹å³closeæ‰\n    fd.Close() // After the mmap() call has returned, the file descriptor can be closed immediately\n\tcheckErr(err)\n\t\n    // è¿™é‡Œï¼Œç›´æ¥å°†æ˜ å°„çš„å†…å­˜å¼ºåˆ¶ç±»å‹è½¬æ¢æˆä¸€ä¸ªintæŒ‡é’ˆp\n\tp := (*int)(unsafe.Pointer(&buf[0]))\n\t// å¯¹æŒ‡é’ˆpçš„è¯»å–å°±æ˜¯è¯»å–æ–‡ä»¶å†…å®¹\n\tlog.Printf(\"the value saved on file is %d\", *p)\n    // å¯¹æŒ‡é’ˆpçš„æ›´æ–°å°±æ˜¯æ›´æ–°æ–‡ä»¶å†…å®¹\n\t*p = rand.New(rand.NewSource(time.Now().UnixNano())).Intn(1000)\n\t// è„é¡µå†™å›å¹¶ä¸æ˜¯åŠæ—¶çš„ï¼Œä½¿ç”¨msyncç³»ç»Ÿè°ƒç”¨å¼ºåˆ¶å°†æ›´æ–°å†™å›ç£ç›˜æ–‡ä»¶\n\t_, _, errno := syscall.Syscall(syscall.SYS_MSYNC, uintptr(unsafe.Pointer(p)), uintptr(INT_SIZE), syscall.MS_SYNC)\n\tif errno != 0 {\n\t\tlog.Fatal(syscall.Errno(errno))\n\t}\n\t// ä½¿ç”¨munmapç³»ç»Ÿè°ƒç”¨éœ€æ±‚å†…å­˜æ˜ å°„\n\t_, _, errno = syscall.Syscall(syscall.SYS_MUNMAP, uintptr(unsafe.Pointer(p)), uintptr(INT_SIZE), 0)\n\tif errno != 0 {\n\t\tlog.Fatal(syscall.Errno(errno))\n\t}\n\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å°†`mmap`åˆ›å»ºçš„å†…å­˜ï¼Œå¼ºåˆ¶è½¬æ¢æˆå…·ä½“çš„ç±»å‹å€¼ï¼Œç„¶ååƒæ™®é€šçš„å˜é‡ä¸€æ ·æ“ä½œï¼Œè¿åºåˆ—åŒ–/ååºåˆ—åŒ–éƒ½çœäº†ã€‚","tags":["mmap - go"]},{"title":"tcp keepalive in go","url":"/2019/07/20/tcp-keepalive-in-go/","content":"\n### overview\n\nå»ºç«‹`tcp`è¿æ¥åï¼Œå¯ä»¥é€šè¿‡`FIN`åŒ…æˆ–è€…`RST`åŒ…é€šçŸ¥å¯¹ç«¯å…³é—­è¿æ¥ï¼Œå…¶ä¸­`FIN`åŒ…æ˜¯æ­£å¸¸è¿æ¥åŒæ–¹å››æ¬¡æ¡æ‰‹å…³é—­è¿æ¥è¿‡ç¨‹ä¸­å‘é€çš„ï¼Œéœ€è¦æ¥æ”¶å¯¹æ–¹çš„`ack`ï¼Œè€Œ`RST`åŒ…æ˜¯é€šçŸ¥å¯¹æ–¹ç«‹å³å…³é—­ï¼Œä¹Ÿä¸éœ€è¦ç­‰å¾…å¯¹æ–¹çš„`ack`ã€‚\n\nä½†æ˜¯ï¼Œå¦‚æœå®¢æˆ·ç«¯åœ¨è¿æ¥è¿‡ç¨‹ä¸­å®•æœºäº†ï¼ŒæœåŠ¡ç«¯ä¸ä¼šæ”¶åˆ°ä»»ä½•æ¶ˆæ¯ï¼Œè¿™æ—¶å€™æœåŠ¡ç«¯è®¤ä¸ºè¿æ¥è¿˜å­˜åœ¨ï¼Œä½†æ˜¯å®¢æˆ·ç«¯å¹¶ä¸äº†è§£ã€‚è¿™æ—¶å€™ï¼Œéœ€è¦ç­‰åˆ°æœåŠ¡ç«¯å‘å®¢æˆ·ç«¯å†™å…¥æ¶ˆæ¯æ—¶ï¼Œå› ä¸ºå®¢æˆ·ç«¯å¹¶æ²¡æœ‰è¿™æ¡è¿æ¥çš„ä¿¡æ¯ï¼Œå‘æœåŠ¡ç«¯è¿”å›`rst`åŒ…ï¼ŒæœåŠ¡ç«¯æ‰ä¼šå…³é—­è¿™æ¡è¿æ¥ï¼Œå¹¶é‡Šæ”¾ç›¸åº”çš„èµ„æºã€‚\n\n`tcp`è¿æ¥å»ºç«‹ä¹‹åï¼Œå¹¶ä¸æ˜¯ä¸€ç›´å¤„äºè¯»å†™çŠ¶æ€ï¼Œå½“æœ‰ä¸€æ–¹ç”±äºæŸç§åŸå› æ„å¤–æ–­å¼€ï¼Œå¦ä¸€æ–¹éœ€è¦ç­‰åˆ°ä¸‹ä¸€æ¬¡å‘é€æ•°æ®æ—¶æ‰èƒ½å…³é—­è¿æ¥ï¼Œè€Œè¿™ä¸­é—´ä¼šä¸€ç›´å ç”¨ç³»ç»Ÿèµ„æºã€‚\n\nè¿™å°±éœ€è¦æœ‰ä¸€ç§å¿ƒè·³æœºåˆ¶ï¼Œèƒ½å¤Ÿå®šæ—¶æ£€æŸ¥å¯¹æ–¹è¿æ¥æ˜¯å¦å­˜æ´»ï¼Œè€Œ[`tcp keepalive`](<https://tools.ietf.org/html/rfc1122#page-101>)å°±ç®—å®ç°è¯¥åŠŸèƒ½çš„æœºåˆ¶ã€‚`keepalive`ä¸æ˜¯`tcp`æ ‡å‡†çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”é»˜è®¤æ˜¯ç¦ç”¨çš„ï¼Œä½†æ˜¯ç›®å‰å¤§å¤šæ•°`tcp`å®ç°éƒ½æ”¯æŒã€‚\n\næœåŠ¡ç«¯å¼€å¯`tcp keepalive`ä¹‹åï¼Œå½“è¿æ¥ç©ºé—²çš„æ—¶å€™ï¼Œä¼šå®šæ—¶å‘é€ç©º`body`çš„`packet`ç»™å®¢æˆ·ç«¯ã€‚æ ¹æ®`tcp`çš„è§„èŒƒï¼Œå½“å®¢æˆ·ç«¯æ¥æ”¶åˆ°ä¸€ä¸ªåŒ…ä¹‹åï¼Œéœ€è¦å›å¤`ACK`ï¼Œå³ä½¿ä¹‹å‰å·²ç»å›å¤è¿‡ç›¸åŒçš„`ACK`äº†ï¼Œå› æ­¤å³ä½¿å®¢æˆ·ç«¯æ²¡æœ‰å®ç°`keepalive`åŠŸèƒ½ä¹Ÿå¯ä»¥æ­£å¸¸å·¥ä½œã€‚\n\nåœ¨å¤§å¤šæ•°å®ç°ä¸­ï¼Œè®¾ç½®`keepalive`ä¸»è¦æœ‰ä¸‰ä¸ªå‚æ•°ï¼š\n\n- `tcp_keepalive_time`ï¼šé—´éš”å¤šä¹…æ²¡æœ‰å‘é€æ•°æ®åï¼Œå°±å‘é€ä¸€ä¸ªå¿ƒè·³åŒ…\n\n- `tcp_keepalive_intvl`ï¼šå‘é€çš„å¿ƒè·³åŒ…å¦‚æœæ²¡æœ‰æ”¶åˆ°`ack`ï¼Œé—´éš”å¤šä¹…åï¼Œé‡æ–°å‘é€\n\n- `tcp_keepalive_probes`ï¼šæœ€å¤šå‘é€å¤šå°‘ä¸ªå¿ƒè·³åŒ…æ²¡æœ‰æ”¶åˆ°å›å¤åï¼Œè®¤ä¸ºå¯¹æ–¹æŒ‚æ‰äº†\n\næ¯”å¦‚ï¼Œ`tcp_keepalive_time`è®¾ç½®ä¸º30sï¼Œ`tcp_keepalive_intvl`è®¾ç½®ä¸º5sï¼Œ`tcp_keepalive_probes`è®¾ç½®ä¸º3ï¼Œé‚£ä¹ˆå½“è¿æ¥ç©ºé—²30sæ²¡æœ‰å‘é€æ•°æ®ï¼Œä¼šå‘é€ç¬¬ä¸€ä¸ªå¿ƒè·³åŒ…ï¼Œå¦‚æœæ¥æ”¶åˆ°äº†`ack`ï¼Œé‚£ä¹ˆä¼šç­‰å¾…ç©ºé—²30såå†æ¬¡å‘é€å¿ƒè·³åŒ…ï¼›è€Œå¦‚æœæ²¡æœ‰æ”¶åˆ°`ack`ï¼Œ5såä¼šé‡è¯•ï¼Œå‘é€ç¬¬äºŒä¸ªå¿ƒè·³åŒ…ï¼Œå¦‚æœå†æ²¡æœ‰æ”¶åˆ°`ack`åŒ…ï¼Œé‚£ä¹ˆç­‰å¾…5såä¼šé‡è¯•ï¼Œå‘é€ç¬¬ä¸‰ä¸ªå¿ƒè·³åŒ…ï¼Œå¦‚æœè¿˜æ²¡æœ‰æ”¶åˆ°`ack`åŒ…ï¼Œé‚£ä¹ˆå°±ä»»åŠ¡å¯¹æ–¹è¿æ¥å·²ç»æŒ‚æ‰äº†ã€‚\n\nåœ¨linuxä¸­ï¼Œå¯ä»¥æŸ¥çœ‹è¿™ä¸‰ä¸ªå‚æ•°çš„é»˜è®¤å€¼ï¼š\n\n```sh\n$ cat /proc/sys/net/ipv4/tcp_keepalive_time \n7200\n$ cat /proc/sys/net/ipv4/tcp_keepalive_intvl \n75\n$ cat /proc/sys/net/ipv4/tcp_keepalive_probes \n9 \n```\n\næˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–è¾‘`/etc/sysctl.conf`ï¼Œæ¥ä¿®æ”¹è¿™ä¸‰ä¸ªå‚æ•°çš„é»˜è®¤å€¼ï¼Œå¹¶ä½¿ç”¨`sysctl -p`ä½¿å…¶ç”Ÿæ•ˆï¼Œç¨‹åºä¸éœ€è¦é‡å¯ï¼Œå†…æ ¸ç›´æ¥ç”Ÿæ•ˆã€‚\n\n`keepalive`è¿˜æœ‰ä¸€ä¸ªä½œç”¨æ˜¯å½“ä½¿ç”¨NATä»£ç†æˆ–è€…é˜²ç«å¢™çš„æ—¶å€™ï¼Œé˜²æ­¢è¿æ¥å› ä¸ºä¸æ´»åŠ¨è€Œè¢«æ–­å¼€ã€‚\n\n\n\n### code\n\n`go`ä¸­çš„`net.TCPConn`æä¾›äº†`SetKeepAlive`å’Œ`SetKeepAlivePeriod`ä¸¤ä¸ªæ–¹æ³•\n\n```go\nfor {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tlog.Printf(\"failed to accept new conn: %s\", err.Error())\n\t\tcontinue\n\t}\n\n\ttcpConn := conn.(*net.TCPConn)\n\ttcpConn.SetKeepAlive(true) // å¼€å¯keepalive\n\ttcpConn.SetKeepAlivePeriod(time.Second * 30) // è®¾ç½®tcp_keepalive_time\n\tgo handleConn(conn)\n}\n```\n\nå¦‚æœéœ€è¦è®¾ç½®`tcp_keepalive_intvl`å’Œ`tcp_keepalive_probes`ä¸¤ä¸ªå‚æ•°ï¼Œåˆ™éœ€è¦`syscall`åŒ…ä¸­çš„æ–¹æ³•ï¼š\n\n```go\n\tfd, err := tcpConn.File()\n\tif err == nil {\n\t\t// è®¾ç½®tcp_keepalive_probes\n\t\terr = syscall.SetsockoptInt(int(fd.Fd()), syscall.IPPROTO_TCP, syscall.TCP_KEEPCNT, 3)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\t// è®¾ç½®tcp_keepalive_intvl\n\t\terr = syscall.SetsockoptInt(int(fd.Fd()), syscall.IPPROTO_TCP, syscall.TCP_KEEPINTVL, 5)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t}\n```\n\nä¸Šé¢ä½¿ç”¨`File.Fd`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨`os/file_unix.go`çš„å®ç°å¦‚ä¸‹ï¼š\n\n```go\nfunc (f *File) Fd() uintptr {\n\tif f == nil {\n\t\treturn ^(uintptr(0))\n\t}\n\n\t// If we put the file descriptor into nonblocking mode,\n\t// then set it to blocking mode before we return it,\n\t// because historically we have always returned a descriptor\n\t// opened in blocking mode. The File will continue to work,\n\t// but any blocking operation will tie up a thread.\n\tif f.nonblock {\n        // è®¾ç½®æˆé˜»å¡æ¨¡å¼\n\t\tf.pfd.SetBlocking()\n\t}\n\n\treturn uintptr(f.pfd.Sysfd)\n}\n```\n\nåœ¨`go`ä¸­ï¼Œç½‘è·¯è¿æ¥é»˜è®¤æ˜¯éé˜»å¡æ¨¡å¼ï¼Œå¯¹ç½‘è·¯è¿æ¥çš„è¯»å†™ä¼šé€šè¿‡[netpoll](<http://mcll.top/2019/04/07/go%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/>)æ¥å®ç°éé˜»å¡è¯»å†™ï¼Œè€Œå½“è½¬æ¢æˆé˜»å¡æ¨¡å¼ä¹‹åï¼Œæ¯æ¬¡è¯»å†™éƒ½ä¼šå˜æˆä¸€æ¬¡é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä»è€Œå¯¼è‡´**å¤§é‡çš„ç³»ç»Ÿçº¿ç¨‹**è¢«åˆ›å»ºã€‚\n\n`go1.11`ä¹‹åï¼Œæ·»åŠ äº†`syscall.RawConn`æ¥å£ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæ¥å£æ¥è§„é¿ä½¿ç”¨`File.Fd`ï¼š\n\n```go\n\trawConn, err := tcpConn.SyscallConn()\n\tif err == nil {\n\t\trawConn.Control(func(fd uintptr) {\n\t\t\t// è®¾ç½®tcp_keepalive_probes\n\t\t\terr = syscall.SetsockoptInt(int(fd), syscall.IPPROTO_TCP, syscall.TCP_KEEPCNT, 3)\n\t\t\tif err != nil {\n\t\t\t\t// handle error\n\t\t\t}\n\t\t\t// è®¾ç½®tcp_keepalive_intvl\n\t\t\terr = syscall.SetsockoptInt(int(fd), syscall.IPPROTO_TCP, syscall.TCP_KEEPINTVL, 5)\n\t\t\tif err != nil {\n\t\t\t\t// handle error\n\t\t\t}\n\t\t})\n\t}\n```\n\n\n\n### å‚è€ƒé“¾æ¥\n\n- [èŠèŠ TCP ä¸­çš„ KeepAlive æœºåˆ¶](<https://zhuanlan.zhihu.com/p/28894266>)\n- [Notes on TCP keepalive in Go](<https://thenotexpert.com/golang-tcp-keepalive/?utm_campaign=The%20Go%20Gazette&utm_medium=email&utm_source=Revue%20newsletter#an-important-note-on-file-descriptors>)\n- [TCP keepalive overview](<http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html>)","tags":["go - tcp"]},{"title":"syncæ‰©å±•åŒ…","url":"/2019/07/19/syncæ‰©å±•åŒ…/","content":"\n[glang.org/x/sync](<https://github.com/golang/sync>)åŒ…æä¾›äº†ä¸€äº›æ–¹ä¾¿ä½¿ç”¨çš„ç”¨äºå¹¶å‘æ“ä½œçš„æ‰©å±•\n\n\n\n### errgroup\n\n`errgroup`ç”¨äºæ‰§è¡Œä¸€ä¸ªæ•´ä½“ä»»åŠ¡çš„ä¸€ç»„å­ä»»åŠ¡\n\n```go\n// Groupä»£è¡¨ä¸€ç»„å­ä»»åŠ¡\ntype Group struct {\n\tcancel func()\n\n\twg sync.WaitGroup\n\n\terrOnce sync.Once // ç”¨äºåˆå§‹åŒ–err\n\terr     error\n}\n\n// å½“ä¸€ä¸ªå­ä»»åŠ¡è¿”å›erroræˆ–è€…æ‰€æœ‰å­ä»»åŠ¡æˆåŠŸè¿è¡Œç»“æŸï¼Œcancelä¼šè¢«æ‰§è¡Œ\nfunc WithContext(ctx context.Context) (*Group, context.Context) {\n    ctx, cancel := context.WithCancel(ctx)\n\treturn &Group{cancel: cancel}, ctx\n}\n\n// ç­‰å¸¦æ‰€æœ‰å­ä»»åŠ¡éƒ½è¿è¡Œå®Œæˆ\nfunc (g *Group) Wait() error {\n\tg.wg.Wait() \n\tif g.cancel != nil {\n\t\tg.cancel() // cancel\n\t}\n\treturn g.err\n}\n\n// Goå¼€å§‹è¿è¡Œä¸€ä¸ªå­ä»»åŠ¡\nfunc (g *Group) Go(f func() error) {\n\tg.wg.Add(1)\n\n\tgo func() {\n\t\tdefer g.wg.Done()\n\t\t// å¦‚æœè¿”å›äº†error\n\t\tif err := f(); err != nil {\n            // errOnceç¡®ä¿åªæ‰§è¡Œä¸€æ¬¡\n\t\t\tg.errOnce.Do(func() {\n\t\t\t\tg.err = err\n                // è¿”å›é”™è¯¯ï¼Œåˆ™æ‰§è¡Œcancel\n\t\t\t\tif g.cancel != nil {\n\t\t\t\t\tg.cancel()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}()\n}\n```\n\nå¯ä»¥çœ‹åˆ°`Group`çš„æºç å¾ˆç®€å•ï¼Œæ¥ä¸‹æ¥çœ‹ä¸€ä¸‹å®˜æ–¹ç»™çš„demoï¼Œçœ‹ä¸€ä¸‹ä½¿ç”¨æ–¹æ³•ï¼š\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"crypto/md5\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n\n    \"golang.org/x/sync/errgroup\"\n)\n\nfunc main() {\n    // è®¡ç®—æŒ‡å®šè·¯å¾„ä¸‹æ‰€æœ‰æ–‡ä»¶çš„md5\n    m, err := MD5All(context.Background(), \".\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\t\n    for k, sum := range m {\n        fmt.Printf(\"%s:\\t%x\\n\", k, sum)\n    }\n}\n\n// ä¿å­˜æ–‡ä»¶md5\ntype result struct {\n    path string // æ–‡ä»¶è·¯å¾„ \n    sum  [md5.Size]byte // md5ä¿¡æ¯\n}\n\nfunc MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) {\n    // åˆ›å»ºGroup\n    g, ctx := errgroup.WithContext(ctx)\n    paths := make(chan string)\n\n    // ç¬¬ä¸€ä¸ªå­ä»»åŠ¡éå†ç›®å½•æ ‘ï¼Œå¹¶æŠŠæ–‡ä»¶è·¯å¾„é€šè¿‡pathsä¼ ç»™å…¶ä»–è®¡ç®—md5çš„å­ä»»åŠ¡\n    g.Go(func() error {\n        defer close(paths)\n        // éå†ç›®å½•æ ‘\n        return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n            if err != nil {\n                return err\n            }\n            if !info.Mode().IsRegular() {\n                return nil\n            }\n            select {\n            case paths <- path:\n            // å¦‚æœæœ‰å­ä»»åŠ¡è¿”å›äº†errorï¼Œåˆ™ç»“æŸå½“å‰å­ä»»åŠ¡\n            case <-ctx.Done():\n                return ctx.Err()\n            }\n            return nil\n        })\n    })\n\n    c := make(chan result)\n    const numDigesters = 20\n    // è¿è¡Œå¤šä¸ªè®¡ç®—md5çš„å­ä»»åŠ¡\n    for i := 0; i < numDigesters; i++ {\n        g.Go(func() error {\n            // ä»pathsä¸­è¯»å–æ–‡ä»¶è·¯å¾„ï¼Œpathså…³é—­åˆ™é€€å‡ºå¾ªç¯\n            for path := range paths {\n                data, err := ioutil.ReadFile(path)\n                if err != nil {\n                    return err\n                }\n                select {\n                // å†™å…¥è®¡ç®—ç»“æœ\n                case c <- result{path, md5.Sum(data)}:\n                // å¦‚æœæŸä¸ªå­ä»»åŠ¡è¿”å›errorï¼Œç»“æŸå½“å‰å­ä»»åŠ¡    \n                case <-ctx.Done():\n                    return ctx.Err()\n                }\n            }\n            return nil\n        })\n    }\n    go func() {\n       \t// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡ç»“æŸï¼Œå…³é—­c\n        g.Wait()\n        close(c)\n    }()\n\n    m := make(map[string][md5.Size]byte)\n    // è¯»å–è®¡ç®—ç»“æœ\n    for r := range c {\n        m[r.path] = r.sum\n    }\n    \n    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨error\n    if err := g.Wait(); err != nil {\n        return nil, err\n    }\n    return m, nil\n}\n```\n\n\n\n### semaphore\n\n`semaphore`å®ç°äº†ä¸€ä¸ªåŠ æƒä¿¡å·é‡\n\n```go\n// ä¸€ä¸ªæ­£åœ¨ç­‰å¾…åˆ†é…æƒé‡çš„è¯·æ±‚\ntype waiter struct {\n\tn     int64 // è¯·æ±‚åˆ†é…çš„æƒé‡\n\tready chan<- struct{} // ç”¨äºé€šçŸ¥å·²ç»åˆ†é…æˆåŠŸ\n}\n\n// åˆ›å»ºä¸€ä¸ªåŠ æƒä¿¡å·é‡ï¼Œnè¡¨ç¤ºæœ€å¤§å¯è·å–çš„æƒé‡\nfunc NewWeighted(n int64) *Weighted {\n\tw := &Weighted{size: n}\n\treturn w\n}\n\ntype Weighted struct {\n\tsize    int64 // æœ€å¤§æƒé‡\n\tcur     int64 // å½“å‰å·²ç»åˆ†é…çš„æƒé‡\n\tmu      sync.Mutex\n\twaiters list.List // ç­‰å¾…é˜Ÿåˆ—\n}\n```\n\nçœ‹ä¸€ä¸‹ä¿¡å·é‡çš„acquireé€»è¾‘ï¼š\n\n```go\n// Acquire acquires the semaphore with a weight of n, blocking until resources\n// are available or ctx is done. On success, returns nil. On failure, returns\n// ctx.Err() and leaves the semaphore unchanged.\n//\n// If ctx is already done, Acquire may still succeed without blocking.\nfunc (s *Weighted) Acquire(ctx context.Context, n int64) error {\n\t// åŠ é”ä¿æŠ¤\n    s.mu.Lock()\n    // å¦‚ä½•å‰©ä½™æƒé‡è¶³å¤Ÿå¹¶ä¸”ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œç›´æ¥åˆ†é…\n\tif s.size-s.cur >= n && s.waiters.Len() == 0 {\n\t\ts.cur += n // æ›´æ–°å½“å‰åˆ†é…çš„æƒé‡\n\t\ts.mu.Unlock()\n\t\treturn nil\n\t}\n\t\n    // å¦‚æœè¯·æ±‚æƒé‡è¶…è¿‡æœ€å¤§é™åˆ¶ï¼Œé˜»å¡ç›´åˆ°contextå–æ¶ˆï¼Œç›´æ¥è¿”å›ï¼Œä¸è¦åŠ å…¥åˆ°waitersé˜²æ­¢é˜»å¡å…¶ä»–åç¨‹\n\tif n > s.size {\n\t\ts.mu.Unlock()\n\t\t<-ctx.Done()\n\t\treturn ctx.Err()\n\t}\n\t\n    // åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—çš„æœ«å°¾\n\tready := make(chan struct{})\n\tw := waiter{n: n, ready: ready}\n\telem := s.waiters.PushBack(w)\n\ts.mu.Unlock()\n\t\n    // ç­‰å¾…ä¸Šä¸‹æ–‡å–æ¶ˆï¼Œæˆ–è€…ä¿¡å·é‡åˆ†é…æˆåŠŸ\n\tselect {\n\tcase <-ctx.Done():\n\t\terr := ctx.Err()\n\t\ts.mu.Lock()\n\t\tselect {\n\t\tcase <-ready:\n            // å–æ¶ˆçš„æ—¶å€™åˆ†é…æˆåŠŸäº†ï¼Œè¿™æ—¶å€™å¿½ç•¥æ‰ä¸Šä¸‹æ–‡å–æ¶ˆæ“ä½œ\n\t\t\terr = nil\n\t\tdefault:\n            // ä¸Šä¸‹æ–‡å–æ¶ˆï¼Œä»ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤\n\t\t\ts.waiters.Remove(elem)\n\t\t}\n\t\ts.mu.Unlock()\n\t\treturn err\n\t// æˆåŠŸåˆ†é…\n\tcase <-ready:\n\t\treturn nil\n\t}\n}\n```\n\næ¥ç€çœ‹ä¸€ä¸‹ä¿¡å·é‡é‡Šæ”¾é€»è¾‘ï¼š\n\n```go\n// Release releases the semaphore with a weight of n.\nfunc (s *Weighted) Release(n int64) {\n\ts.mu.Lock()\n    // æ›´æ–°å½“å‰åˆ†é…çš„æƒé‡\n\ts.cur -= n\n\tif s.cur < 0 {\n\t\ts.mu.Unlock()\n\t\tpanic(\"semaphore: released more than held\")\n\t}\n    \n    // å”¤é†’ç­‰å¾…é˜Ÿåˆ—\n\tfor {\n\t\tnext := s.waiters.Front()\n\t\tif next == nil {\n\t\t\tbreak // No more waiters blocked.\n\t\t}\n\t\t\n\t\tw := next.Value.(waiter)\n\t\tif s.size-s.cur < w.n {\n\t\t\tbreak\n\t\t}\n\n\t\ts.cur += w.n\n\t\ts.waiters.Remove(next)\n\t\tclose(w.ready)\n\t}\n\ts.mu.Unlock()\n}\n```\n\n\n\n### singleflight\n\n`singleflight`æä¾›äº†é˜²æ­¢å‡½æ•°åŒä¸€æ—¶åˆ»é‡å¤æ‰§è¡Œçš„åŠŸèƒ½\n\n```go\n// callè¡¨ç¤ºä¸€ä¸ªå‡½æ•°è°ƒç”¨\ntype call struct {\n   wg sync.WaitGroup\n\n   // å‡½æ•°è¿”å›å€¼\n   val interface{}\n   // è¿”å›çš„é”™è¯¯\n   err error\n\n   // forgotten indicates whether Forget was called with this call's key\n   // while the call was still in flight.\n   forgotten bool\n\n   // è¡¨ç¤ºè¯¥å‡½æ•°æœ‰å¤šå°‘æ¬¡é‡å¤è°ƒç”¨\n   dups  int\n   // å¼‚æ­¥è¿”å›æ‰§è¡Œç»“æœ\n   chans []chan<- Result\n}\n\n// Result holds the results of Do, so they can be passed\n// on a channel.\ntype Result struct {\n   Val    interface{}\n   Err    error\n   Shared bool\n}\n\n// Group represents a class of work and forms a namespace in\n// which units of work can be executed with duplicate suppression.\ntype Group struct {\n   mu sync.Mutex       // protects m\n   m  map[string]*call // lazily initialized\n}\n\n\n```\n\n```go\n// Do executes and returns the results of the given function, making\n// sure that only one execution is in-flight for a given key at a\n// time. If a duplicate comes in, the duplicate caller waits for the\n// original to complete and receives the same results.\n// The return value shared indicates whether v was given to multiple callers.\n// å…·æœ‰ç›¸åŒkeyçš„å‡½æ•°ï¼ŒåŒä¸€æ—¶åˆ»å¤šæ¬¡è°ƒç”¨åªä¼šæ‰§è¡Œä¸€æ¬¡\nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {\n\tg.mu.Lock()\n    // lazy init\n\tif g.m == nil {\n\t\tg.m = make(map[string]*call)\n\t}\n    \n    // å¦‚æœå·²ç»å­˜åœ¨\n\tif c, ok := g.m[key]; ok {\n\t\tc.dups++\n\t\tg.mu.Unlock()\n\t\tc.wg.Wait() // ç­‰å¾…æ‰§è¡Œç»“æŸ\n\t\treturn c.val, c.err, true // æ‰§è¡Œè¿”å›è°ƒç”¨ç»“æœ\n\t}\n    // åˆ›å»ºä¸€ä¸ªæ–°çš„callï¼ŒåŠ å…¥åˆ°g.mä¸­\n\tc := new(call)\n\tc.wg.Add(1)\n\tg.m[key] = c\n\tg.mu.Unlock()\n\n    // åŒæ­¥æ‰§è¡Œå‡½æ•°è°ƒç”¨\n\tg.doCall(c, key, fn)\n\treturn c.val, c.err, c.dups > 0\n}\n```\n\n\n\n```go\n// DoChan is like Do but returns a channel that will receive the\n// results when they are ready.\nfunc (g *Group) DoChan(key string, fn func() (interface{}, error)) <-chan Result {\n   ch := make(chan Result, 1)\n   g.mu.Lock()\n   if g.m == nil {\n      g.m = make(map[string]*call)\n   }\n   if c, ok := g.m[key]; ok {\n      c.dups++\n      c.chans = append(c.chans, ch)\n      g.mu.Unlock()\n      return ch\n   }\n   c := &call{chans: []chan<- Result{ch}}\n   c.wg.Add(1)\n   g.m[key] = c\n   g.mu.Unlock()\n   // å¼‚æ­¥æ‰§è¡Œå‡½æ•°è°ƒç”¨\n   go g.doCall(c, key, fn)\n\n   return ch\n}\n```\n\n```go\n// doCall handles the single call for a key.\nfunc (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {\n\t// è°ƒç”¨å‡½æ•°\n    c.val, c.err = fn()\n    // é€šçŸ¥å‡½æ•°è°ƒç”¨ç»“æŸ\n\tc.wg.Done()\n    \n    // ä»g.mä¸­ç§»é™¤\n\tg.mu.Lock()\n\tif !c.forgotten {\n\t\tdelete(g.m, key)\n\t}\n    // å¦‚æœå­˜åœ¨å¼‚æ­¥è°ƒç”¨ï¼Œé€šçŸ¥æ‰§è¡Œç»“æœ\n\tfor _, ch := range c.chans {\n\t\tch <- Result{c.val, c.err, c.dups > 0}\n\t}\n\tg.mu.Unlock()\n}\n```\n\n```go\n// Forget tells the singleflight to forget about a key.  Future calls\n// to Do for this key will call the function rather than waiting for\n// an earlier call to complete.\n// ä»g.mä¸­ç§»é™¤æŒ‡å®škeyçš„å‡½æ•°è°ƒç”¨\nfunc (g *Group) Forget(key string) {\n   g.mu.Lock()\n   if c, ok := g.m[key]; ok {\n      c.forgotten = true\n   }\n   delete(g.m, key)\n   g.mu.Unlock()\n}\n```\n\n\n\n### syncmap\n\n`syncmap`æä¾›äº†ä¸€ä¸ªå¹¶å‘å®‰å…¨çš„`map`å®ç°ï¼Œå·²ç»åŠ å…¥åˆ°äº†æ ‡å‡†åº“ä¸­\n\n```go\n// Map is a concurrent map with amortized-constant-time loads, stores, and deletes.\n// It is safe for multiple goroutines to call a Map's methods concurrently.\n//\n// The zero Map is valid and empty.\n//\n// A Map must not be copied after first use.\ntype Map struct {\n   mu sync.Mutex\n   // æŸ¥è¯¢æ—¶ä¼šå…ˆä»readä¸­æŸ¥è¯¢ï¼Œå¦‚æœæ²¡æœ‰æ‰åˆ°dirtyä¸­æŸ¥è¯¢\n   read atomic.Value // readOnly\n   \n   dirty map[interface{}]*entry\n   // è®°å½•åˆ°dirtyä¸­æŸ¥è¯¢çš„æ¬¡æ•°ï¼Œå½“è¾¾åˆ°ä¸€å®šé˜ˆå€¼ï¼Œä¼šä½¿ç”¨dirtyä½œä¸ºæ–°çš„read\n   misses int\n}\n\n// readOnly is an immutable struct stored atomically in the Map.read field.\ntype readOnly struct {\n\tm       map[interface{}]*entry // entryä¿å­˜value\n    // æ˜¯å¦dirtyä¸­åŒ…å«mä¸­ä¸å­˜åœ¨çš„key\n\tamended bool // true if the dirty map contains some key not in m.\n}\n\n// An entry is a slot in the map corresponding to a particular key.\n// readOnlyè™½ç„¶æ˜¯åªè¯»çš„ï¼Œä½†æ˜¯entryå¯ä»¥é€šè¿‡casæ›´æ–°på­—æ®µ\ntype entry struct {\n\tp unsafe.Pointer // *interface{}\n}\n```\n\n```go\n// Load returns the value stored in the map for a key, or nil if no\n// value is present.\n// The ok result indicates whether value was found in the map.\nfunc (m *Map) Load(key interface{}) (value interface{}, ok bool) {\n\t// å…ˆå°è¯•ç›´æ¥ä»readä¸­æŸ¥æ‰¾ï¼ŒreadOnlyæ˜¯åªè¯»çš„ï¼Œå› æ­¤å¹¶å‘è®¿é—®å®‰å…¨\n    read, _ := m.read.Load().(readOnly)\n\te, ok := read.m[key]\n    // å¦‚æœæŸ¥è¯¢ä¸åˆ°å¹¶ä¸”dirtyä¸­åŒ…å«readä¸­ä¸å­˜åœ¨çš„keyï¼Œåˆ™åˆ°dirtyä¸­æŸ¥æ‰¾\n\tif !ok && read.amended {\n        // éœ€è¦åŠ é”\n\t\tm.mu.Lock()\n\t\t// é¦–å…ˆå…ˆå†æ¬¡ä»readä¸­æŸ¥æ‰¾ä¸€éï¼Œé˜²æ­¢åŠ é”è¿‡ç¨‹ä¸­ï¼Œå…¶ä»–åç¨‹è§¦å‘äº†readçš„æ›´æ–°\n\t\tread, _ = m.read.Load().(readOnly)\n\t\te, ok = read.m[key]\n        // å¦‚æœreadä¸­æ²¡æœ‰ï¼Œå¹¶ä¸”dirtyåŒ…å«readä¸­æ²¡æœ‰çš„keyï¼Œä»dirtyä¸­æŸ¥æ‰¾\n\t\tif !ok && read.amended {\n\t\t\te, ok = m.dirty[key]\n\t\t\t// æ›´æ–°misseså­—æ®µï¼Œå¹¶ä¸”å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œåˆ™æ›´æ–°readä¸ºdirty\n\t\t\tm.missLocked()\n\t\t}\n\t\tm.mu.Unlock()\n\t}\n\tif !ok {\n\t\treturn nil, false\n\t}\n\treturn e.load()\n}\n```\n\n```go\n// Store sets the value for a key.\nfunc (m *Map) Store(key, value interface{}) {\n    // é¦–å…ˆåˆ¤æ–­æ˜¯å¦readåŒ…å«è¦æ›´æ–°çš„key\n\tread, _ := m.read.Load().(readOnly)\n    // æ›´æ–°å¯¹åº”çš„entryï¼ŒtryStoreä½¿ç”¨casæ“ä½œï¼Œä¿è¯å¹¶å‘å®‰å…¨\n\tif e, ok := read.m[key]; ok && e.tryStore(&value) {\n\t\treturn\n\t}\n    \n\t// å¦‚æœreadä¸­æ²¡æœ‰ï¼Œåˆ™ä¿å­˜åˆ°dirtyä¸­\n\tm.mu.Lock()\n    // é¦–å…ˆå†æ¬¡æ£€æŸ¥ä¸€ä¸‹read\n\tread, _ = m.read.Load().(readOnly)\n\tif e, ok := read.m[key]; ok {\n        // readä¸­çš„valå·²ç»è¢«åˆ é™¤äº†ï¼ŒåŒæ—¶ä¿å­˜åˆ°dirtyä¸­\n\t\tif e.unexpungeLocked() {\n\t\t\t// The entry was previously expunged, which implies that there is a\n\t\t\t// non-nil dirty map and this entry is not in it.\n\t\t\tm.dirty[key] = e\n\t\t}\n\t\te.storeLocked(&value)\n        // if m.dirty == nil, then ok == false\n\t} else if e, ok := m.dirty[key]; ok {\n\t\te.storeLocked(&value)\n\t} else {\n        // dirtyä¸­æ²¡æœ‰åŒ…å«readä¸­æ²¡æœ‰çš„keyï¼Œä½†æ˜¯readä¸­å¯èƒ½åŒ…å«dirtyä¸­æ²¡æœ‰çš„key\n        // è¿™æ—¶å€™çš„dirtyåº”è¯¥è¿˜æ²¡æœ‰åˆå§‹åŒ–\n\t\tif !read.amended {\n            // åˆå§‹åŒ–dirtyï¼Œå¹¶å°†readä¸­æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤çš„kvæ‹·è´åˆ°dirtyä¸­\n \t\t\tm.dirtyLocked()\n            // æ›´æ–°readï¼Œåº”è¯¥readOnlyæ˜¯åªè¯»çš„ï¼Œè¿™é‡Œé‡æ–°åˆ›å»ºä¸€ä¸ªreadOnly\n\t\t\tm.read.Store(readOnly{m: read.m, amended: true})\n\t\t}\n        // æŠŠæ–°çš„kvä¿å­˜åˆ°dirtyä¸­\n\t\tm.dirty[key] = newEntry(value)\n\t}\n\tm.mu.Unlock()\n}\n```\n\n```go\n// Delete deletes the value for a key.\nfunc (m *Map) Delete(key interface{}) {\n\t// å…ˆå°è¯•ç›´æ¥ä»readä¸­æŸ¥æ‰¾\n    read, _ := m.read.Load().(readOnly)\n\te, ok := read.m[key]\n    // readä¸­ä¸å­˜åœ¨ï¼Œå¹¶ä¸”å¯èƒ½åœ¨dirtyä¸­\n\tif !ok && read.amended {\n\t\tm.mu.Lock()\n        // å†æ¬¡æ£€æŸ¥read\n\t\tread, _ = m.read.Load().(readOnly)\n\t\te, ok = read.m[key]\n\t\tif !ok && read.amended {\n            // ç›´æ¥ä»dirtyä¸­åˆ é™¤\n\t\t\tdelete(m.dirty, key)\n\t\t}\n\t\tm.mu.Unlock()\n\t}\n    // readä¸­å­˜åœ¨ï¼Œç›´æ¥æ ‡è®°ä¸ºå·²ç»åˆ é™¤\n\tif ok {\n\t\te.delete()\n\t}\n}\n```\n\n```go\nfunc (m *Map) Range(f func(key, value interface{}) bool) {\n\tread, _ := m.read.Load().(readOnly)\n\t// dirtyä¸­åŒ…å«readä¸­ä¸å­˜åœ¨çš„kv\n    if read.amended {\n\t\tm.mu.Lock()\n\t\tread, _ = m.read.Load().(readOnly)\n\t\tif read.amended {\n\t\t\t// æ›¿æ¢readä¸ºdirty\n            read = readOnly{m: m.dirty}\n\t\t\tm.read.Store(read)\n\t\t\tm.dirty = nil\n\t\t\tm.misses = 0\n\t\t}\n\t\tm.mu.Unlock()\n\t}\n    \n\t// éå†read\n\tfor k, e := range read.m {\n\t\tv, ok := e.load()\n        // å¦‚æœå·²ç»æ ‡è®°ä¸ºåˆ é™¤ï¼Œè·³è¿‡\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif !f(k, v) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n\n\n","tags":["go"]},{"title":"mapä¸­çš„hash","url":"/2019/06/22/mapä¸­çš„hash/","content":"\n### é—®é¢˜å¼•å…¥\n\n```go\ntype Key struct {\n\ta     int\n\tIface interface{}\n}\n\nfunc main() {\n\tm := map[Key]bool{}\n\tm[Key{a: 10, Iface: 10}] = true // è¿è¡Œé€šè¿‡\n\tm[Key{a: 10, Iface: map[string]interface{}{}}] = true // panic\n}\n```\n\nè¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªpanicï¼š\n\n```sh\npanic: runtime error: hash of unhashable type map[string]interface {}\n```\n\nåŸå› æ˜¯å› ä¸ºï¼Œå½“ä½¿ç”¨mapå­˜å‚¨æ—¶ï¼Œ`key`è¦æ±‚æ˜¯å¯ä»¥è®¡ç®—`hash`å€¼çš„ï¼Œè€Œåœ¨`go`ä¸­ï¼Œ`map`ã€`slice`ã€`channel`å’Œ`func`ç±»å‹éƒ½æ˜¯ä¸èƒ½è®¡ç®—hashå€¼çš„ï¼Œå› æ­¤å½“ä½¿ç”¨è¿™äº›ç±»å‹ä½œä¸º`map`çš„`key`æ—¶ä¼šå‘ç”Ÿpanicï¼Œè€Œå½“keyæ˜¯å¤åˆç±»å‹ï¼Œå¹¶ä¸”åŒ…å«äº†è¿™å››ç§ç±»å‹ï¼Œä¹Ÿä¼šå‘ç”Ÿpanicï¼Œå¦‚ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå¦‚æœåŒ…å«äº†æ¥å£ç±»å‹ï¼Œé‚£ä¹ˆåœ¨è¿è¡Œæ—¶ä¼šåŠ¨æ€æ£€æŸ¥å…¶ç±»å‹ã€‚\n\n### å…·ä½“å®ç°\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å…¶èƒŒåçš„å®ç°é€»è¾‘ã€‚\n\né¦–å…ˆï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹mapä¸­å…³äºhashçš„è®¡ç®—é€»è¾‘ï¼š\n\n```go\nalg := t.key.alg // è¿™é‡Œçš„keyæ˜¯maptype\nhash := alg.hash(key, uintptr(h.hash0)) \n```\n\næ¥ä¸‹æ¥çœ‹ä¸€ä¸‹`maptype`çš„ç»“æ„å®šä¹‰ï¼š\n\n```go\ntype maptype struct {\n\ttyp        _type\n\tkey        *_type\n\telem       *_type\n\tbucket     *_type // internal type representing a hash bucket\n\tkeysize    uint8  // size of key slot\n\tvaluesize  uint8  // size of value slot\n\tbucketsize uint16 // size of bucket\n\tflags      uint32\n}\n\ntype _type struct {\n\tsize       uintptr\n\tptrdata    uintptr // size of memory prefix holding all pointers\n\thash       uint32\n\ttflag      tflag\n\talign      uint8\n\tfieldalign uint8\n\tkind       uint8\n\talg        *typeAlg \n\t// gcdata stores the GC type data for the garbage collector.\n\t// If the KindGCProg bit is set in kind, gcdata is a GC program.\n\t// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n\tgcdata    *byte\n\tstr       nameOff\n\tptrToThis typeOff\n}\n\ntype typeAlg struct {\n\t// function for hashing objects of this type\n\t// (ptr to object, seed) -> hash\n\thash func(unsafe.Pointer, uintptr) uintptr\n\t// function for comparing objects of this type\n\t// (ptr to object A, ptr to object B) -> ==?\n\tequal func(unsafe.Pointer, unsafe.Pointer) bool\n}\n```\n\nå®é™…ä¸Šï¼Œæ¯ä¸ªç±»å‹éƒ½ä¼šåŒ…å«`_type`ï¼Œè€Œ`_type`ä¸­çš„`alg`å­—æ®µåˆ™å®šä¹‰äº†è¯¥ç±»å‹å¯¹è±¡çš„`hash`å’Œ`equal`æ–¹æ³•\n\nè€Œåœ¨`runtime`åŒ…ä¸­ï¼Œå·²ç»å£°æ˜äº†ä¸€äº›åŸºæœ¬çš„`alg`ï¼š\n\n```go\nvar algarray = [alg_max]typeAlg{\n\talg_NOEQ:     {nil, nil}, // è¡¨ç¤ºæ²¡æœ‰hashæ–¹æ³•å’Œequalæ–¹æ³• \n\talg_MEM0:     {memhash0, memequal0},\n\talg_MEM8:     {memhash8, memequal8},\n\talg_MEM16:    {memhash16, memequal16},\n\talg_MEM32:    {memhash32, memequal32},\n\talg_MEM64:    {memhash64, memequal64},\n\talg_MEM128:   {memhash128, memequal128},\n\talg_STRING:   {strhash, strequal},\n\talg_INTER:    {interhash, interequal}, // ç”¨äºè®¡ç®—ifaceç±»å‹\n\talg_NILINTER: {nilinterhash, nilinterequal}, // ç”¨äºè®¡ç®—efaceç±»å‹\n\talg_FLOAT32:  {f32hash, f32equal},\n\talg_FLOAT64:  {f64hash, f64equal},\n\talg_CPLX64:   {c64hash, c64equal},\n\talg_CPLX128:  {c128hash, c128equal},\n}\n```\n\næˆ‘ä»¬å°±çœ‹å…¶ä¸­çš„`nilinterhash`çš„å®ç°ï¼š\n\n```go\nfunc nilinterhash(p unsafe.Pointer, h uintptr) uintptr {\n\ta := (*eface)(p) // på®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªç©ºæ¥å£æŒ‡é’ˆ\n\tt := a._type \n\tif t == nil { \n\t\treturn h\n\t}\n\tfn := t.alg.hash \n\tif fn == nil { // å¦‚æœæ²¡æœ‰æŒ‡å®šhashæ–¹æ³•ï¼Œè¡¨æ˜è¯¥ç±»å‹ä¸æ”¯æŒè®¡ç®—hash\n        // è¿™é‡Œçš„panicä¸å°±è·Ÿä¸Šé¢ä¾‹å­ä¸­çš„panicä¸€æ ·å˜›\n\t\tpanic(errorString(\"hash of unhashable type \" + t.string()))\n\t}\n\tif isDirectIface(t) {\n\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0)\n\t} else {\n\t\treturn c1 * fn(a.data, h^c0)\n\t}\n}\n```\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹æ–‡ç« å¼€å¤´ä¾‹å­åç¼–è¯‘åçš„æ±‡ç¼–ä»£ç ï¼Œæˆ‘ä»¬ä¸»è¦æ˜¯è¦çœ‹ä¸€ä¸‹`Key`ç±»å‹çš„`hash`æ–¹æ³•\n\né¦–å…ˆï¼Œçœ‹ä¸€ä¸‹`Key`ç±»å‹çš„`type`ï¼š\n\n```go\ntype.\"\".Key SRODATA size=144\n\t0x0000 18 00 00 00 00 00 00 00 18 00 00 00 00 00 00 00  ................\n\t0x0010 18 cb 58 54 07 08 08 19 00 00 00 00 00 00 00 00  ..XT............\n\t0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0040 02 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................\n\t0x0050 00 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ........@.......\n\t0x0060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0080 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00  ................\n\trel 24+8 t=1 type..alg.\"\".Key+0 // 24+8åç§»é‡å¯¹åº”çš„å°±æ˜¯_type.alg\n\trel 32+8 t=1 runtime.gcbits.04+0\n\trel 40+4 t=5 type..namedata.*main.Key.+0\n\trel 44+4 t=5 type.*\"\".Key+0\n\trel 48+8 t=1 type..importpath.\"\".+0\n\trel 56+8 t=1 type.\"\".Key+96\n\trel 80+4 t=5 type..importpath.\"\".+0\n\trel 96+8 t=1 type..namedata.a-+0\n\trel 104+8 t=1 type.int+0\n\trel 120+8 t=1 type..namedata.Iface.+0\n\trel 128+8 t=1 type.interface {}+0\n\n// keyçš„algåŒ…å«äº†ä¸¤ä¸ªå­—æ®µï¼Œhashfuncå’Œeqfunc\ntype..alg.\"\".Key SRODATA dupok size=16\n\t0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\trel 0+8 t=1 type..hashfunc.\"\".Key+0 \n\trel 8+8 t=1 type..eqfunc.\"\".Key+0\n\ntype..hashfunc.\"\".Key SRODATA dupok size=8\n\t0x0000 00 00 00 00 00 00 00 00                          ........\n\trel 0+8 t=1 type..hash.\"\".Key+0\n```\n\næ¥ç€æ¥çœ‹ä¸€ä¸‹æ±‡ç¼–ç”Ÿæˆçš„`type..hash.\"\".Key`æ–¹æ³•ï¼Œåªä¿ç•™ä¸»è¦é€»è¾‘\n\n```assembly\n// é¦–å…ˆè¯¥å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•°på’Œhï¼Œpè¡¨ç¤ºè¦hashçš„å¯¹è±¡æŒ‡é’ˆï¼Œhè¡¨ç¤ºhash seekï¼Œè¿”å›ä¸€ä¸ªhashå€¼\nTEXT\ttype..hash.\"\".Key(SB), DUPOK|ABIInternal, $40-24\n\tMOVQ\t\"\".p+48(SP), AX // å°†è¦hashçš„é•€é”¡æŒ‡é’ˆmovåˆ°ax\n\tMOVQ\tAX, (SP) // memhashç¬¬ä¸€ä¸ªå‚æ•°\n\tMOVQ\t\"\".h+56(SP), CX\n\tMOVQ\tCX, 8(SP) // memhashç¬¬äºŒä¸ªå‚æ•°\n\tMOVQ\t$8, 16(SP) // memhashç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œè¿™é‡Œ8è¡¨ç¤ºåªå¯¹å‰8ä¸ªå­—èŠ‚è¿›è¡Œhashè®¡ç®—\n\tCALL\truntime.memhash(SB) // è°ƒç”¨memhashè®¡ç®—hashå€¼\n\tMOVQ\t24(SP), AX // å°†è¿”å›å€¼ä¿å­˜åˆ°axä¸­\n\tMOVQ\t\"\".p+48(SP), CX\n\tADDQ\t$8, CX // è¿™é‡ŒæŒ‡é’ˆè®¡ç®—ï¼Œp+8å¯¹åº”çš„å°±æ˜¯Key.Iface\n\tMOVQ\tCX, (SP) // nilinterhashç¬¬ä¸€ä¸ªå‚æ•°\n\tMOVQ\tAX, 8(SP) // å°†memhashçš„ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºnilinterhashç¬¬äºŒä¸ªå‚æ•°\n\tCALL\truntime.nilinterhash(SB) // è°ƒç”¨nilinterhash\n\tMOVQ\t16(SP), AX // è¿”å›å€¼movåˆ°ax\n\tMOVQ\tAX, \"\".~r2+64(SP) // è®¾ç½®è¿”å›å€¼\n\tRET\n```\n\nç›´æ¥çœ‹ä¸Šé¢çš„é€»è¾‘ï¼Œå½“è®¡ç®—`Key`çš„`hash`æ—¶ï¼Œä¼šå…ˆè®¡ç®—å‰8ä¸ªå­—èŠ‚çš„hashå€¼ï¼Œç„¶ååœ¨è°ƒç”¨`nilinterhash`æ¥è®¡ç®—`Iface`çš„hashå€¼ã€‚\n\né‚£ä¹ˆå¼€å¤´æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿è¡Œçš„ç»“æœæ˜¯`panic`ï¼Œå› æ­¤è¯´æ˜åœ¨`nilinterhash`ä¸­ï¼Œå› æ­¤å¯¹åº”çš„typeæ²¡æœ‰hashæ–¹æ³•è€Œå¯¼è‡´panicï¼Œä¸ºäº†éªŒè¯æˆ‘ä»¬çš„ç»“è®ºï¼Œæˆ‘ä»¬çœ‹ä¸‹`map[string]interface{}{}`å¯¹åº”çš„`_type`ä¸­çš„`alg`\n\n```go\nfunc main() {\n\tm := map[string]interface{}{}\n\tm[\"a\"] = nil\n}\n```\n\næŸ¥çœ‹ç¼–è¯‘åçš„æ±‡ç¼–ä»£ç ï¼š\n\n```go\ntype.map[string]interface {} SRODATA dupok size=80\n\t0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00  ................\n\t0x0010 86 62 71 0e 02 08 08 35 00 00 00 00 00 00 00 00  .bq....5........\n\t0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0040 00 00 00 00 00 00 00 00 10 10 10 01 0c 00 00 00  ................\n\t// çœ‹è¿™é‡Œï¼Œruntime.algarrayå¯¹åº”å°±æ˜¯runtime.algarray[0]\n\t// è¿™ä¸ªæ•°ç»„ä¸Šé¢æåˆ°è¿‡ï¼Œalgarray[0]å¯¹åº”çš„hashå’Œeqéƒ½æ˜¯nil\n\trel 24+8 t=1 runtime.algarray+0\n\trel 32+8 t=1 runtime.gcbits.01+0\n\trel 40+4 t=5 type..namedata.*map[string]interface {}-+0\n\trel 44+4 t=6 type.*map[string]interface {}+0\n\trel 48+8 t=1 type.string+0\n\trel 56+8 t=1 type.interface {}+0\n\trel 64+8 t=1 type.noalg.map.bucket[string]interface {}+0\n```\n\n","tags":["go"]},{"title":"ast","url":"/2019/06/19/ast/","content":"\n# go ast\n\n`go`çš„å®˜æ–¹åº“æä¾›äº†å‡ ä¸ªåŒ…ï¼Œå¯ä»¥å¸®æˆ‘ä»¬è§£æ`go`çš„æºæ–‡ä»¶ï¼Œä¸»è¦æœ‰ï¼š\n\n- [go/scanner](<https://github.com/golang/go/blob/master/src/go/scanner/scanner.go>)ï¼šè¯æ³•è§£æï¼Œå°†æºä»£ç åˆ†å‰²æˆä¸€ä¸ªä¸ªtoken\n- [go/token](<https://github.com/golang/go/blob/master/src/go/token/token.go>)ï¼štokenç±»å‹åŠç›¸å…³ç»“æ„ä½“å®šä¹‰\n- [go/ast](<https://github.com/golang/go/blob/master/src/go/ast/ast.go>)ï¼šastçš„ç»“æ„å®šä¹‰\n- [go/parser](<https://github.com/golang/go/blob/master/src/go/parser/parser.go#L17>)ï¼šè¯­æ³•åˆ†æï¼Œè¯»å–tokenæµç”Ÿæˆast\n\n\n\né€šè¿‡è§£ææºæ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°`ast`(æŠ½è±¡è¯­æ³•æ ‘)ã€‚\n\nè€Œé€šè¿‡éå†`ast`ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°æºç ä¸­å£°æ˜çš„ç»“æ„ä½“ã€æ–¹æ³•ã€ç±»å‹ç­‰ç­‰ä¿¡æ¯ï¼Œå¹¶æ ¹æ®å®é™…éœ€è¦[ç”Ÿæˆå…·ä½“çš„ä»£ç ](<https://github.com/ymcvalu/enhance/tree/master/enhance>)ï¼Œæ¯”å¦‚è‡ªåŠ¨ç”Ÿæˆ`tag`ï¼Œæ¨¡æ¿æ–¹æ³•ã€æ‰‹åŠ¨å®ç°æ³›å‹æ•ˆæœç­‰ã€‚è€Œä¸”ï¼Œgoçš„æ³¨é‡Šåœ¨è§£ææ—¶æ˜¯å¯ä»¥ä¿ç•™çš„ï¼Œè¿™å°±å¯ä»¥å®ç°`java`ä¸­ç±»ä¼¼`annotation`çš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ ¹æ®æ³¨é‡Šè‡ªåŠ¨ç”Ÿæˆæ¥å£æ–‡æ¡£ï¼ˆ[beegoçš„swaggeræ–‡æ¡£ç”Ÿæˆ](<https://github.com/beego/bee/blob/develop/generate/swaggergen/g_docs.go>)ï¼‰ï¼Œæ ¹æ®æ³¨é‡Šæå–æ¥å£æƒé™ä¿¡æ¯å®ç°ç»Ÿä¸€æƒé™æ ¡éªŒç­‰ã€‚\n\n\n\nè§£æè¿‡ç¨‹ï¼š\n\nè¯æ³•åˆ†æï¼Œå°†æºä»£ç åˆ†å‰²æˆä¸€ä¸ªä¸ªtoken -> è¯­æ³•åˆ†æï¼Œæ ¹æ®[goè¯­è¨€çš„æ–‡æ³•](<https://golang.org/ref/spec>)å¯¹tokenæµè¿›è¡Œè§„çº¦/æ¨å¯¼ -> ç”Ÿæˆast\n\n\n\n### ast: æŠ½è±¡è¯­æ³•æ ‘\n\nastæ˜¯æºä»£ç ç»“æ„çš„ä¸€ç§æŠ½è±¡è¡¨ç¤ºï¼Œä»¥æ ‘çŠ¶å½¢å¼æ¥è¡¨è¾¾ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•ç»“æ„ã€‚\n\næ¯”å¦‚è¡¨è¾¾å¼ `a+b`ï¼Œå¯¹åº”çš„astä¸ºï¼š\n\n![](/img/ast1.png)\n\nå¯¹åº”ä½¿ç”¨goè¡¨ç¤ºçš„ç»“æ„ï¼š\n\n```go\n*ast.BinaryExpr { // a+bæ˜¯ä¸€ä¸ªäºŒå…ƒè¡¨è¾¾å¼\n.  X: *ast.Ident { // Xè¡¨ç¤ºç¬¬ä¸€ä¸ªæ“ä½œæ•°\n.  .  Name: \"a\"\n.  .  }\n.  }\n.  Op: + // æ“ä½œç¬¦\n.  Y: *ast.Ident { // Yè¡¨ç¤ºç¬¬äºŒä¸ªæ“ä½œæ•°\n.  .  Name: \"b\"\n.  }\n}\n```\n\n\n\n### æºç è§£æ\n\né¦–å…ˆè¦çŸ¥é“å…·ä½“çš„æ¥å£æ€ä¹ˆç”¨ï¼Œæ‰çŸ¥é“æºç ä»å“ªä¸ªå…¥å£å¼€å§‹çœ‹æ˜¯å§\n\n```go\npackage main\n\nimport (\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"log\"\n)\n\nfunc main() {\n\t// åˆ›å»ºFileSet\n\tfset := token.NewFileSet()\n\t// è§£ææºæ–‡ä»¶main.goï¼Œè¿”å›ast.Fileä»£è¡¨ä¸€ä¸ªæºæ–‡ä»¶çš„node\n\tf, err := parser.ParseFile(fset, \"./main.go\", nil, parser.ParseComments)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// æ‰“å°AST\n\tast.Print(fset, f)\n}\n```\n\né¦–å…ˆæ¥çœ‹ç¬¬12è¡Œä»£ç ï¼Œè¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ª`FileSet`ï¼Œé¡¾åæ€ä¹‰ï¼Œ`FileSet`å°±æ˜¯æºæ–‡ä»¶é›†åˆï¼Œå› ä¸ºæˆ‘ä»¬ä¸€æ¬¡è§£æå¯èƒ½ä¸æ­¢è§£æä¸€ä¸ªæ–‡ä»¶ï¼Œè€Œæ˜¯ä¸€ç³»åˆ—æ–‡ä»¶ã€‚\n\n`FileSet`æœ€ä¸»è¦çš„ç”¨é€”æ˜¯ç”¨æ¥ä¿å­˜`token`çš„ä½ç½®ä¿¡æ¯ï¼Œæ¯ä¸ªtokenåœ¨å½“å‰æ–‡ä»¶çš„ä½ç½®å¯ä»¥ç”¨è¡Œå·ï¼Œåˆ—å·ï¼Œtokenåœ¨å½“å‰æ–‡ä»¶ä¸­çš„åç§»é‡è¿™ä¸‰ä¸ªå±æ€§æ¥æè¿°ï¼Œä½¿ç”¨[`Position`](<https://github.com/golang/go/blob/master/src/go/token/position.go#L20>)è¿™ä¸ªç»“æ„ä½“æ¥æè¿°ï¼Œ`FileSet`ä¸­ä¿å­˜æ‰€æœ‰`token`çš„`Position`ä¿¡æ¯ï¼Œè€Œåœ¨`ast`ä¸­ï¼Œåªä¿å­˜ä¸€ä¸ª[`Pos`](<https://github.com/golang/go/blob/master/src/go/token/position.go#L76>)ç´¢å¼•ã€‚å½“éå†`ast`çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨`Pos`ç´¢å¼•å‘[`FileSet`]()è·å–`Position`ã€‚\n\nç°åœ¨æ¥çœ‹ä¸€ä¸‹14è¡Œ`parser.ParseFile`è¿™ä¸ªæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å®ç°äº†è¯­æ³•åˆ†æï¼š\n```go\nfunc ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (f *ast.File, err error) {\n\t// å¿…é¡»è¦ä¼ å…¥fsetï¼Œç”¨æ¥ä¿å­˜Positionä¿¡æ¯\n    if fset == nil {\n\t\tpanic(\"parser.ParseFile: no token.FileSet provided (fset == nil)\")\n\t}\n\n\t// è¯»å–æºæ–‡ä»¶ï¼Œå¦‚æœsrcä¸ä¸ºç©ºï¼Œåˆ™ä»srcè¯»å–ï¼Œå¦åˆ™è¯»å–filenameæŒ‡å®šçš„æ–‡ä»¶\n\ttext, err := readSource(filename, src)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar p parser \n\tdefer func() {\n\t\t...\n\t}()\n\n\t// parse source\n\tp.init(fset, filename, text, mode) // åˆå§‹åŒ–parser\n\tf = p.parseFile() // è§£ææºæ–‡ä»¶ï¼Œç”ŸæˆAST\n\n\treturn\n}\n```\n\nå…ˆæ¥ç®€å•çœ‹ä¸€ä¸‹`parser.init`æ–¹æ³•ï¼š\n\n```go\nfunc (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) {\n\t// æ·»åŠ å½“å‰æ–‡ä»¶åˆ°FileSetä¸­\n    p.file = fset.AddFile(filename, -1, len(src))\n\tvar m scanner.Mode\n    // è®¾ç½®scannerçš„modeï¼Œå¦‚æœæŒ‡å®šäº†astéœ€è¦ä¿ç•™æ³¨é‡Šï¼Œé‚£ä¹ˆè¯æ³•è§£æçš„æ—¶å€™éœ€è¦è§£ææ³¨é‡Š\n\tif mode&ParseComments != 0 {\n\t\tm = scanner.ScanComments\n\t}\n    // é”™è¯¯å¤„ç†\n\teh := func(pos token.Position, msg string) { p.errors.Add(pos, msg) }\n\t// åˆå§‹åŒ–è¯æ³•è§£æå™¨\n    p.scanner.Init(p.file, src, eh, m)\n\tp.mode = mode\n\tp.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)\n\t// parser.nextä¼šå‰è¿›åˆ°ä¸‹ä¸€ä¸ªéæ³¨é‡Šçš„tokenï¼Œå…¶ä¸­æ³¨é‡Šä¼šè¢«ä¿ç•™\n\tp.next()\n}\n```\n\nå…¶ä¸­ï¼Œæ³¨é‡Šæœ‰ä¸¤ç§ï¼š\n\n```go\n// this\n// is\n// doc\nfunc foo(){\n    \n}\n```\n\n```go\nvar globalNum int // this is a comment\n```\n\nç¬¬ä¸€ç§æ˜¯æ³¨é‡Šç‹¬è‡ªè‡ªå·±å ä¸€åˆ°å¤šè¡Œçš„ï¼Œåä¸€ç§åˆ™æ˜¯è·Ÿè¯­å¥åœ¨åŒä¸€è¡Œã€‚`parser.next`æ–¹æ³•ä¸­ï¼Œè¯»å–`token`æ—¶ï¼Œå¦‚æœé‡åˆ°ç¬¬ä¸€ç§æ³¨é‡Šï¼Œä¼šä¿å­˜åˆ°`parser.leadComment`ï¼Œå¦‚æœæ˜¯ç¬¬äºŒç§æ³¨é‡Šï¼Œåˆ™ä¿å­˜åˆ°`parser.lineComment`ä¸­ï¼Œæœ€ç»ˆä¼šä¿ç•™åˆ°å…·ä½“çš„`ast`ä¸­çš„èŠ‚ç‚¹ä¸­ã€‚\n\næ¥ç€æ¥çœ‹ä¸€ä¸‹[`parser.parseFile`](<https://github.com/golang/go/blob/master/src/go/parser/parser.go#L2500>)æ–¹æ³•\n\n```go\nfunc (p *parser) parseFile() *ast.File {\n\t// å¦‚æœæ‰§è¡Œparser.nextæ—¶æœ‰é”™è¯¯å‘ç”Ÿ\n\tif p.errors.Len() != 0 {\n\t\treturn nil\n\t}\n\n\t// package clause\n\tdoc := p.leadComment // packageå‰é¢çš„æ³¨é‡Šè¢«è®¤ä¸ºæ˜¯å½“å‰æ–‡ä»¶çš„doc\n    // æœŸå¾…ç¬¬ä¸€ä¸ªtokenæ˜¯`package`å…³é”®å­—ï¼Œè¯¥æ–¹æ³•å†…ä¼šæ‰§è¡Œparser.nextæ–¹æ³•ï¼Œå‰è¿›åˆ°ä¸‹ä¸€ä¸ªtoken\n\tpos := p.expect(token.PACKAGE) \n\t// è§£æå½“å‰çš„tokenä¸ºæ ‡è¯†ç¬¦ï¼Œä¹Ÿå°±æ˜¯åŒ…å\n\tident := p.parseIdent()\n\tif ident.Name == \"_\" && p.mode&DeclarationErrors != 0 {\n\t\tp.error(p.pos, \"invalid package name _\")\n\t}\n    // è¯»å–`;`ï¼Œå¦‚æœæ²¡æœ‰çš„è¯ï¼Œéœ€è¦æ’å…¥ä¸€ä¸ª`;`\n    // ä¹Ÿå°±æ˜¯è¯´goä¼šè‡ªåŠ¨åœ¨è¯­å¥æœ«å°¾æ’å…¥`;`\n\tp.expectSemi()\n\n\t// å¦‚æœå‰é¢è§£ææ ‡è¯†ç¬¦æ—¶å¤±è´¥\n\tif p.errors.Len() != 0 {\n\t\treturn nil\n\t}\n\n    // è®¾ç½®topScope\n    // scopeç”¨äºä¿å­˜å½“å‰ä½œç”¨åŸŸå†…å£°æ˜çš„ç¬¦å·å¼•ç”¨ï¼Œæ¯”å¦‚å£°æ˜çš„æ–¹æ³•ã€ç±»å‹æˆ–å¸¸/å˜é‡ç­‰\n\tp.openScope()\n    // è®¾ç½®åŒ…ä½œç”¨åŸŸ\n\tp.pkgScope = p.topScope\n    // ä¸€ä¸ªæºæ–‡ä»¶æ˜¯ç”±ä¸€ç³»åˆ—å£°æ˜ç»„æˆçš„:\n    // importå£°æ˜\n    // æ–¹æ³•å£°æ˜\n    // ç±»å‹å£°æ˜\n    // å…¨å±€å¸¸é‡/å˜é‡å£°æ˜\n    // è¿™é‡Œçš„ast.Declæ˜¯è¿™äº›å£°æ˜çš„å…¬å…±æ¥å£\n\tvar decls []ast.Decl\n\t// å¦‚æœä¸æ˜¯åªè§£æåŒ…å\n    if p.mode&PackageClauseOnly == 0 {\n\t\t// è§£æå¯¼å…¥å£°æ˜\n        // ç¡®ä¿å½“å‰tokençš„`import`\n\t\tfor p.tok == token.IMPORT {\n            // p.parserImportSpecè§£æå…·ä½“çš„å¯¼å…¥å£°æ˜\n\t\t\tdecls = append(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))\n\t\t}\n\t\t// å¦‚æœä¸æ˜¯åªè§£æå¯¼å…¥å£°æ˜\n\t\tif p.mode&ImportsOnly == 0 {\n\t\t\t// è§£ææºä»£ç åé¢çš„å…¶ä»–å†…å®¹\n\t\t\tfor p.tok != token.EOF {\n\t\t\t\tdecls = append(decls, p.parseDecl(declStart))\n\t\t\t}\n\t\t}\n\t}\n    \n    // å…³é—­ä½œç”¨åŸŸ\n\tp.closeScope()\n    // ç¡®ä¿topScopeä¸ºnilï¼Œå¦åˆ™è¯´æ˜æœ‰å¤šä½™çš„`{}`æ²¡æœ‰åŒ¹é…\n\tassert(p.topScope == nil, \"unbalanced scopes\")\n\tassert(p.labelScope == nil, \"unbalanced label scopes\")\n\n\t// resolve global identifiers within the same file\n\ti := 0\n    // åœ¨åŒ…ä½œç”¨åŸŸå†…æŸ¥æ‰¾æœªè§£æçš„ç¬¦å·å¼•ç”¨ï¼Œæ¯”å¦‚åœ¨æ–¹æ³•å†…å¼•ç”¨äº†å…¨å±€çš„æ–¹æ³•ï¼Œå˜é‡ç­‰\n\tfor _, ident := range p.unresolved {\n\t\t// i <= index for current ident\n\t\tassert(ident.Obj == unresolved, \"object already resolved\")\n\t\tident.Obj = p.pkgScope.Lookup(ident.Name) // also removes unresolved sentinel\n        // æœ‰çš„æ˜¯åœ¨åŒä¸€ä¸ªåŒ…çš„å…¶ä»–æ–‡ä»¶ä¸­å£°æ˜çš„\n\t\tif ident.Obj == nil {\n\t\t\tp.unresolved[i] = ident\n\t\t\ti++\n\t\t}\n\t}\n\n\treturn &ast.File{\n\t\tDoc:        doc,\n\t\tPackage:    pos,\n\t\tName:       ident,\n\t\tDecls:      decls,\n\t\tScope:      p.pkgScope,\n\t\tImports:    p.imports,\n\t\tUnresolved: p.unresolved[0:i],\n\t\tComments:   p.comments,\n\t}\n}\n```\nä¸Šé¢çš„`decl`ï¼ŒåŒ…æ‹¬å…¨å±€çš„å˜é‡å£°æ˜ï¼Œç±»å‹å£°æ˜ï¼Œå‡½æ•°å£°æ˜ç­‰ï¼Œå…·ä½“å°±ä¸å±•å¼€äº†ã€‚\n\n### æ¥ä¸ªä¾‹å­\n\nç°åœ¨æ¥å®ç°ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆ`tag`çš„ä¾‹å­\n\n```go\nfunc main() {\n    // ä½¿ç”¨æ—¶éœ€è¦ä¼ å…¥ç›®æ ‡æºä»£ç è·¯å¾„ï¼Œç›®æ ‡ç»“æ„ä½“åŒ…å«çš„æŸä¸ªè¡Œå·å’Œåˆ—å·\n\targs := os.Args[:len(os.Args)]\n\tif len(args) < 4 {\n\t\tlog.Fatal(\"å‚æ•°ï¼šæ–‡ä»¶è·¯å¾„ï¼Œè¡Œå·ï¼Œåˆ—å·\")\n\t}\n\tfpath := args[1]\n\tlineNum, err := strconv.Atoi(args[2])\n\tif err != nil {\n\t\tlog.Fatal(\"incorrect line number\")\n\t}\n\t// columnNum, err := strconv.Atoi(args[3])\n\tif err != nil {\n\t\tlog.Fatal(\"incorrect column number\")\n\t}\n\t// åˆ›å»ºFileSet\n\tfset := token.NewFileSet()\n\n\t// è§£ææºæ–‡ä»¶\n\tf, err := parser.ParseFile(fset, fpath, nil, parser.ParseComments)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to parse file: \", err.Error())\n\t}\n\t// å…¨å±€å˜é‡ï¼Œç”¨æ¥ä¿å­˜æ‰¾åˆ°çš„ç›®æ ‡ç»“æ„ä½“å£°æ˜çš„å…·ä½“node\n\tvar target *ast.StructType\n    // ä½¿ç”¨Inspectæ–¹æ³•éå†ast\n\tast.Inspect(f, func(node ast.Node) bool {\n\t\t// å¦‚æœä¸æ˜¯ç»“æ„ä½“ç±»å‹å£°æ˜ï¼Œè·³è¿‡ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªéå†\n\t\tst, ok := node.(*ast.StructType)\n        // å¦‚æœä¸æ˜¯ç»“æ„ä½“ç±»å‹æˆ–è€…ç±»å‹å£°æ˜æœªå®Œæˆ\n\t\tif !ok || st.Incomplete {\n\t\t\treturn true\n\t\t}\n\t\t// å¦‚æœæ˜¯ç»“æ„ä½“å£°æ˜ï¼Œéœ€è¦åŒ…å«æŒ‡å®šçš„è¡Œå’Œåˆ—ï¼Œè¿™é‡Œå®é™…ä¸Šåªè¦åŒ…å«å®é™…è¡Œå°±è¡Œ\n\t\tbegin := fset.Position(st.Pos())\n\t\tend := fset.Position(st.End())\n\n\t\t// æ‰¾åˆ°ç›®æ ‡structï¼Œè¿”å›falseï¼Œç»“æŸéå†\n\t\tif begin.Line <= lineNum && end.Line >= lineNum {\n\t\t\ttarget = st // è®¾ç½®ç›®æ ‡target\n \t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t})\n\n    // å¦‚æœæ‰¾åˆ°äº†ç›®æ ‡trget\n\tif target != nil {\n        // ç”Ÿæˆtagï¼Œå› ä¸ºç»“æ„ä½“å£°æ˜æ˜¯å¯ä»¥åµŒå¥—çš„ï¼Œè¯¥æ–¹æ³•ä¼šé€’å½’è°ƒç”¨\n\t\tgenTag(target)\n        // æ‰“å¼€ç›®æ ‡æ–‡ä»¶\n\t\tfd, err := os.OpenFile(fpath, os.O_TRUNC|os.O_RDWR, 0777)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer fd.Close()\n        // ä½¿ç”¨format.Nodeæ–¹æ³•å°†astè½¬æ¢ä¸ºæºæ–‡ä»¶\n\t\terr = format.Node(fd, fset, f)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n```\n\næ¥ç€æ¥çœ‹ä¸€ä¸‹`genTag`æ–¹æ³•ï¼Œè¯¥æ”¾æ–¹æ³•ä¸»è¦å°±æ˜¯éå†å£°æ˜çš„å­—æ®µï¼Œä¸ºå…¶ç”Ÿæˆtagç„¶åè®¾ç½®åˆ°astä¸­å¯¹åº”çš„nodeä¸Š\n\n```go\nfunc genTag(st *ast.StructType) {\n    // éå†ç»“æ„ä½“å£°æ˜çš„å­—æ®µåˆ—è¡¨\n\tfs := st.Fields.List\n\tfor i := range fs {\n\t\tvar (\n\t\t\ttag string\n\t\t)\n\n\t\tfd := fs[i]\n        // å¦‚æœæœ‰æŒ‡å®šå­—æ®µå\n\t\tif len(fd.Names) > 0 {\n\t\t\tname := fd.Names[0].Name\n            // åªæœ‰å¯¼å‡ºå­—æ®µæ‰éœ€è¦ç”Ÿæˆtag\n\t\t\tif !isExport(name) {\n\t\t\t\tcontinue\n\t\t\t}\n            // æ ¹æ®å­—æ®µåç”Ÿæˆtagä¸­çš„åå­—ï¼Œæ¯”å¦‚NodeIdå˜æˆnode_id\n\t\t\ttag = genKey(name)\n\t\t}\n\t\t// åˆ¤æ–­å­—æ®µçš„ç±»å‹\n\t\tswitch t := fd.Type.(type) {\n        // å¦‚æœæ˜¯æ ‡è¯†ç¬¦æ ‡è¯†å¼•ç”¨äº†å…¶ä»–å£°æ˜ç±»å‹\n\t\tcase *ast.Ident:\n            // å¦‚æœtag==\"\"è¡¨ç¤ºæ²¡æœ‰å­—æ®µåï¼Œè¿™æ—¶å€™é»˜è®¤å­—æ®µåå°±æ˜¯ç±»å‹å\n            // å¦‚æœç±»å‹å¯¼å‡ºï¼Œåˆ™ç”Ÿæˆtag\n\t\t\tif tag == \"\" && isExport(t.Name) {\n\t\t\t\ttag = genKey(t.Name)\n\t\t\t}\n        // åµŒå¥—ç»“æ„ä½“å£°æ˜\n\t\tcase *ast.StructType:\n\t\t\t// é€’å½’ç”Ÿæˆtag\n            genTag(t)\n\t\t}\n\n\t\tvar tagStr string\n        // è·å–åŸæ¥çš„tag\n\t\tif fd.Tag != nil {\n\t\t\ttagStr = fd.Tag.Value\n\t\t}\n\t\n        // è§£ætagå­—ç¬¦ä¸²ï¼š`json:\"sdf\" form:\"sdf\"`æˆtagåˆ‡ç‰‡\n\t\ttags, err := parseTag(tagStr)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\n\t\tchange := false\n\t\t// å¦‚æœå·²ç»å­˜åœ¨jsonè¿™ä¸ªtagï¼Œåˆ™è·³è¿‡è‡ªåŠ¨ç”Ÿæˆ\n        if _, ok := tags.Lookup(\"json\"); !ok {\n\t\t\ttags.Append(\"json\", tag)\n\t\t\tchange = true\n\t\t}\n        // å¦‚æœå·²ç»ç”Ÿæˆformè¿™ä¸ªtagï¼Œè·³è¿‡\n\t\tif _, ok := tags.Lookup(\"form\"); !ok {\n\t\t\ttags.Append(\"form\", tag)\n\t\t\tchange = true\n\t\t}\n\t\n        // å¦‚æœè‡ªåŠ¨ç”Ÿæˆäº†tag\n\t\tif change {\n            // æ ¹æ®æ–°çš„tagåˆ‡ç‰‡ç”Ÿæˆtagå­—ç¬¦ä¸²\n\t\t\ttagStr = tags.TagStr()\n\t\t\tif fd.Tag == nil {\n\t\t\t\tfd.Tag = &ast.BasicLit{}\n\t\t\t}\n            // è®¾ç½®åˆ°ç›®æ ‡nodeä¸­\n\t\t\tfd.Tag.Kind = token.STRING\n\t\t\tfd.Tag.Value = tagStr\n\t\t}\n\t}\n}\n```\n\n[å®Œæ•´ä»£ç ](<https://github.com/ymcvalu/auto-tag>)","tags":["golang"]},{"title":"åç¨‹æŠ¢å ","url":"/2019/05/25/åç¨‹æŠ¢å /","content":"\n\n\n# åç¨‹æŠ¢å \n\n### åä½œå¼æŠ¢å \n\n##### morestackï¼šæ‰§è¡ŒæŠ¢å \n\nç›®å‰`go`å®ç°æ˜¯çš„åä½œæŠ¢å ï¼šåœ¨æ¯ä¸ªå‡½æ•°å¼€å¤´æ’å…¥`morestack`æ£€æŸ¥ï¼Œé™¤äº†æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å¼ æ ˆï¼ŒåŒæ—¶è¿˜æ£€æŸ¥æ˜¯å¦å½“å‰åç¨‹éœ€è¦æŠ¢å ã€‚é‚£ä¹ˆæ€ä¹ˆåˆ¤æ–­ä¸€ä¸ªåç¨‹æ˜¯å¦éœ€è¦æŠ¢å å‘¢ï¼Ÿåå°çº¿ç¨‹ä¼šå®šæ—¶æ‰«æå½“å‰è¿è¡Œä¸­çš„åç¨‹ï¼Œå¦‚æœå‘ç°ä¸€ä¸ªåç¨‹è¿è¡Œæ¯”è¾ƒä¹…ï¼Œä¼šå°†å…¶æ ‡è®°ä¸ºæŠ¢å çŠ¶æ€ã€‚\n\næˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹ä¸€ä¸ª`main`å‡½æ•°çš„æ±‡ç¼–ä»£ç ï¼š\n\n```go\n\t0x0000 00000 (morestack.go:5)\tTEXT\t\"\".main(SB), $64-0\n\t0x0000 00000 (morestack.go:5)\tMOVQ\tTLS, CX\n\t0x0009 00009 (morestack.go:5)\tMOVQ\t(CX)(TLS*2), CX // è·å–å½“å‰g\n\t// æ¯”è¾ƒå½“å‰SPå’Œg.stackguard0ï¼Œå¦‚æœå°äºåˆ™éœ€è¦è§¦å‘morestarck\n\t0x0010 00016 (morestack.go:5)\tCMPQ\tSP, 16(CX) \n\t0x0014 00020 (morestack.go:5)\tJLS\t110\n\t0x0016 00022 (morestack.go:5)\tSUBQ\t$64, SP    // SP-64ï¼Œç›¸å½“äºè®¾ç½®æ ˆå¸§å¤§å°64å­—èŠ‚\n\t0x001a 00026 (morestack.go:5)\tMOVQ\tBP, 56(SP) // ä¿å­˜callerçš„BPï¼Œå¯ä»¥çœ‹åˆ°BPæ˜¯ä¿å­˜åˆ°å½“å‰å‡½æ•°çš„æ ˆå¸§ä¸­çš„ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°æ ˆå¸§å¤§å°ä¸º0ï¼Œåˆ™ä¸éœ€è¦ä¿å­˜BP\n\t0x001f 00031 (morestack.go:5)\tLEAQ\t56(SP), BP // è®¾ç½®å½“å‰BP\n    ...\n\t0x0064 00100 (morestack.go:7)\tMOVQ\t56(SP), BP // è¿˜åŸBP\n\t0x0069 00105 (morestack.go:7)\tADDQ\t$64, SP    // SP+64ï¼Œç›¸å½“äºé”€æ¯æ ˆå¸§\n\t0x006d 00109 (morestack.go:7)\tRET\n\t0x006e 00110 (morestack.go:7)\tNOP\n\t0x006e 00110 (morestack.go:5)\tCALL\truntime.morestack_noctxt(SB)\n\t0x0073 00115 (morestack.go:5)\tJMP\t0\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¿›å…¥å‡½æ•°ä¹‹åï¼Œé¦–å…ˆä¼šæ£€æŸ¥å½“å‰å‡½æ•°çš„`SP`å¯„å­˜å™¨æ˜¯å¦å·²ç»è¾¾åˆ°`g.stackguard0`ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œåˆ™éœ€è¦å…ˆè°ƒç”¨`runtime.morestack_noctxt`æ–¹æ³•æ‰©å¼ å½“å‰å‡½æ•°æ ˆï¼ˆç°åœ¨çš„å®ç°æ˜¯é‡æ–°åˆ†é…ä¸€ä¸ªæ›´å¤§çš„å‡½æ•°æ ˆï¼Œç„¶åæŠŠæ—§çš„å‡½æ•°æ ˆå†…å®¹æ‹·è´è¿‡å»ï¼‰ï¼Œç„¶åå†æ ¹æ®æ ˆå¸§å¤§å°è®¾ç½®`SP`å’Œ`BP`æŒ‡é’ˆï¼Œè€Œåœ¨å‡½æ•°è¿”å›å‰éœ€è¦å…ˆæ¢å¤`BP`å’Œ`SP`æŒ‡é’ˆã€‚**ä¸Šé¢çš„BPå’ŒSPå¯„å­˜å™¨çš„ç›¸å…³è®¾ç½®æ˜¯åœ¨morestackä¹‹åï¼Œä¹Ÿå°±æ˜¯åœ¨æ‰§è¡Œmorestackçš„æ—¶å€™ï¼Œ0(SP)ä¸ºå‡½æ•°è¿”å›åœ°å€**\n\næˆ‘ä»¬æ¥ç€æ¥çœ‹ä¸€ä¸‹`runtimeÂ·morestack_noctxt`çš„å®ç°ï¼š\n\n```go\n// morestack but not preserving ctxt.\n// è¿™é‡Œnoctxtè¡¨ç¤ºè°ƒç”¨æ–¹æ³•æ²¡æœ‰contextï¼Œå³æ²¡æœ‰é—­åŒ…æˆ–è€…receiver\nTEXT runtimeÂ·morestack_noctxt(SB),NOSPLIT,$0\n\tMOVL\t$0, DX // æ¸…ç©ºDXçš„ä½32ä½ï¼ŒDXå¯„å­˜å™¨ç”¨äºä¿å­˜å‡½æ•°ä¸Šä¸‹æ–‡\n\tJMP\truntimeÂ·morestack(SB) // è·³è½¬åˆ°morestackæ–¹æ³•ï¼Œè¿™é‡Œç”¨çš„æ˜¯JMPï¼Œä¸æ˜¯CALL\n\n/*\n * support for morestack\n */\n\n// Called during function prolog when more stack is needed.\n//\n// The traceback routines see morestack on a g0 as being\n// the top of a stack (for example, morestack calling newstack\n// calling the scheduler calling newm calling gc), so we must\n// record an argument size. For that purpose, it has no arguments.\nTEXT runtimeÂ·morestack(SB),NOSPLIT,$0-0\n\t// Cannot grow scheduler stack (m->g0).\n    get_tls(CX)            // è¿™é‡Œget_tls(r)æ˜¯ä¸€ä¸ªå®ï¼šMOVQ TLS, r \n\tMOVQ\tg(CX), BX      // ä¿å­˜å½“å‰çš„gåˆ°BX\n\tMOVQ\tg_m(BX), BX    // ä¿å­˜måˆ°BX\n\tMOVQ\tm_g0(BX), SI   // ä¿å­˜g0åˆ°SI\n\tCMPQ\tg(CX), SI // å¦‚æœå½“å‰å¤„äºg0æ ˆ\n\tJNE\t3(PC)  // PC+3\n\tCALL\truntimeÂ·badmorestackg0(SB) // g0æ ˆä¸å…è®¸æ‰©å¼ \n\tCALL\truntimeÂ·abort(SB)\n\n\t// Cannot grow signal stack (m->gsignal).\n\tMOVQ\tm_gsignal(BX), SI  // gsignalç”¨äºå¤„ç†ä¿¡å·é‡çš„æ ˆ\n\tCMPQ\tg(CX), SI\n\tJNE\t3(PC)\n\tCALL\truntimeÂ·badmorestackgsignal(SB) // gsignalæ ˆä¸å…è®¸æ‰©å¼ \n\tCALL\truntimeÂ·abort(SB)\n\n\t// Called from fï¼šæŠŠè°ƒç”¨morestackçš„å‡½æ•°è®°ä¸ºf\n\t// ä¿å­˜ f's callerçš„ä¿¡æ¯åˆ°m.morebufä¸­\n    // 8(SP)ä¿å­˜fçš„è¿”å›åœ°å€ï¼Œå³f's callerçš„PC\n\tMOVQ\t8(SP), AX\n\tMOVQ\tAX, (m_morebuf+gobuf_pc)(BX) // è®¾ç½®m.morebuf.pcä¸ºf's callerçš„PC\n    // 16(SP)çš„åœ°å€ä¸ºf's callerçš„SP\n\tLEAQ\t16(SP), AX\t// f's caller's SP\n\tMOVQ\tAX, (m_morebuf+gobuf_sp)(BX)\n\tget_tls(CX)\n\tMOVQ\tg(CX), SI\n\tMOVQ\tSI, (m_morebuf+gobuf_g)(BX)\n\n\t// Set g->sched to context in f.\n    MOVQ\t0(SP), AX // f's PCï¼Œmorestackçš„frameSizeä¸º0ï¼Œæ­¤æ—¶0(SP)ä¸ºfçš„è¿”å›åœ°å€\n\tMOVQ\tAX, (g_sched+gobuf_pc)(SI) // è®¾ç½®g.sched.pcä¸ºfçš„PC\n\tMOVQ\tSI, (g_sched+gobuf_g)(SI)\n    // 8(SP)çš„åœ°å€å³ä¸ºfçš„SP\n\tLEAQ\t8(SP), AX // f's SP\n\tMOVQ\tAX, (g_sched+gobuf_sp)(SI) // ä¿å­˜fçš„SP\n\tMOVQ\tBP, (g_sched+gobuf_bp)(SI) // ä¿å­˜fçš„BP\n\tMOVQ\tDX, (g_sched+gobuf_ctxt)(SI)  // ä¿å­˜fçš„DX\n\n\t// Call newstack on m->g0's stack.\n\tMOVQ\tm_g0(BX), BX  // è·å–g0\n\tMOVQ\tBX, g(CX)     // è®¾ç½®å½“å‰gä¸ºg0\n\tMOVQ\t(g_sched+gobuf_sp)(BX), SP // è®¾ç½®SPå¯„å­˜å™¨ä¸ºg0.sched.sp\n\tCALL\truntimeÂ·newstack(SB)       // è°ƒç”¨newstackï¼Œè¯¥æ–¹æ³•ä¸ä¼šè¿”å›\n\tCALL\truntimeÂ·abort(SB)\t// crash if newstack returns\n\tRET\n```\n\næˆ‘ä»¬æ¥ç€æ¥çœ‹ä¸€ä¸‹`runtime.newstack`è¿™ä¸ªæ–¹æ³•ï¼š\n\n```go\nfunc newstack() {\n\tthisg := getg() // è¿™é‡Œè·å–çš„æ˜¯å½“å‰æ‰§è¡Œçš„gï¼Œå®é™…å°±æ˜¯g0\n\t...\n    // è¿™é‡Œçš„curgæ˜¯è§¦å‘äº†morestackçš„gï¼Œä¸æ˜¯g0\n\tgp := thisg.m.curg\n\t...\n\tmorebuf := thisg.m.morebuf\n\tthisg.m.morebuf.pc = 0\n\tthisg.m.morebuf.lr = 0\n\tthisg.m.morebuf.sp = 0\n\tthisg.m.morebuf.g = 0\n\n    // æ£€æŸ¥æ˜¯å¦éœ€è¦æŠ¢å ï¼Œå½“å‘ç°ä¸€ä¸ªåç¨‹éœ€è¦è¢«æŠ¢å æ—¶ï¼Œä¼šå°†å…¶g.stackguard0è®¾ç½®æˆstackPreemptï¼Œä»è€Œè§¦å‘morestackçš„æ‰§è¡Œ\n\tpreempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt\n    // è§¦å‘äº†æŠ¢å \n \tif preempt {\n        // We are interested in preempting user Go code, not runtime code.\n\t\t// If we're holding locks, mallocing, or preemption is disabled, don't\n\t\t// preempt.\n\t\tif thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != \"\" || thisg.m.p.ptr().status != _Prunning {\n\t\t\t// è¿˜åŸgp.stackguard0\n            // gp->preempt is set, so it will be preempted next time.\n\t\t\tgp.stackguard0 = gp.stack.lo + _StackGuard\n            // restore state from Gobuf; longjmp\n\t\t\tgogo(&gp.sched) // never return\n\t\t}\n\t}\n\n\tsp := gp.sched.sp\n\tif sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 || sys.ArchFamily == sys.WASM {\n\t\t// The call to morestack cost a word.\n\t\tsp -= sys.PtrSize\n\t}\n \t\n    // å†æ¬¡æ£€æŸ¥æŠ¢å \n\tif preempt {\n        // g0ä¸å…è®¸è¢«æŠ¢å \n\t\tif gp == thisg.m.g0 {\n\t\t\tthrow(\"runtime: preempt g0\")\n\t\t}\n\t\tif thisg.m.p == 0 && thisg.m.locks == 0 {\n\t\t\tthrow(\"runtime: g is running but p is not\")\n\t\t}\n\t\t// Synchronize with scang.\n        // æ›´æ–°çŠ¶æ€ä¸º_Gwaiting\n\t\tcasgstatus(gp, _Grunning, _Gwaiting)\n\t\t// gcç›¸å…³ï¼ŒæŠ¢å gæ‰«æ\n        if gp.preemptscan {\n\t\t\tfor !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) {\n\t\t\t\t// Likely to be racing with the GC as\n\t\t\t\t// it sees a _Gwaiting and does the\n\t\t\t\t// stack scan. If so, gcworkdone will\n\t\t\t\t// be set and gcphasework will simply\n\t\t\t\t// return.\n\t\t\t}\n\t\t\tif !gp.gcscandone {\n\t\t\t\t// gcw is safe because we're on the\n\t\t\t\t// system stack.\n\t\t\t\tgcw := &gp.m.p.ptr().gcw\n                // æ‰«ægpçš„æ ˆ\n\t\t\t\tscanstack(gp, gcw)\n\t\t\t\tif gcBlackenPromptly {\n\t\t\t\t\tgcw.dispose()\n\t\t\t\t}\n\t\t\t\tgp.gcscandone = true\n\t\t\t}\n\t\t\tgp.preemptscan = false\n\t\t\tgp.preempt = false\n\t\t\tcasfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)\n\t\t\t// This clears gcscanvalid.\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunning)\n\t\t\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\t\t\tgogo(&gp.sched) // never return\n\t\t}\n\n\t\t// Act like goroutine called runtime.Gosched.\n\t\tcasgstatus(gp, _Gwaiting, _Grunning)\n        // è¿™é‡Œæ‰§è¡ŒæŠ¢å ï¼Œå®é™…ä¸Šå°±æ˜¯è°ƒç”¨scheduleæ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸ä¼šè¿”å›\n\t\tgopreempt_m(gp) // never return\n\t}\n\n\t// å¦‚æœä¸æ˜¯ç”±äºæŠ¢å è€Œæ‰§è¡Œmorestackï¼Œé‚£ä¹ˆå°±æ˜¯çœŸçš„å› ä¸ºæ ˆä¸å¤Ÿç”¨äº†ï¼Œéœ€è¦æ‰©å®¹æ ˆ\n\toldsize := gp.stack.hi - gp.stack.lo\n\tnewsize := oldsize * 2 // æ–°çš„æ ˆæ˜¯åŸæ¥çš„ä¸¤å€\n\tif newsize > maxstacksize { // æ ˆæ˜¯æœ‰é™åˆ¶çš„å“¦ï¼š1<<20\n\t\tprint(\"runtime: goroutine stack exceeds \", maxstacksize, \"-byte limit\\n\")\n\t\tthrow(\"stack overflow\") // æ ˆæº¢å‡ºäº†\n\t}\n\n\t// The goroutine must be executing in order to call newstack,\n\t// so it must be Grunning (or Gscanrunning).\n    // è®¾ç½®gçš„çŠ¶æ€\n\tcasgstatus(gp, _Grunning, _Gcopystack)\n\n\t// The concurrent GC will not scan the stack while we are doing the copy since\n\t// the gp is in a Gcopystack status.\n    // coypstackä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ ˆï¼Œç„¶åæŠŠæ—§çš„æ ˆçš„å†…å®¹æ‹·åˆ°æ–°çš„æ ˆä¸­\n\tcopystack(gp, newsize, true)\n\tif stackDebug >= 1 {\n\t\tprint(\"stack grow done\\n\")\n\t}\n    // å¯ä»¥å¼€å§‹è·‘äº†\n\tcasgstatus(gp, _Gcopystack, _Grunning)\n\tgogo(&gp.sched) // gogoå¼€å§‹è·‘äº†\n}\n```\n\n##### sysmonï¼šæŠ¢å æ ‡è®°\n\né‚£ä¹ˆï¼Œæˆ‘ä»¬çš„åç¨‹æ˜¯ä»€ä¹ˆæ—¶å€™è¢«æ ‡è®°ä¸ºå¯æŠ¢å çš„å‘¢ï¼Ÿå½“ç„¶æ˜¯åå°çº¿ç¨‹`sysmon`çš„åŠŸåŠ³äº†ï¼Œ`sysmon`çš„å·¥ä½œä¹‹ä¸€å°±æ˜¯æ‰¾å‡ºæŒç»­è¿è¡Œå¾ˆä¹…çš„åç¨‹ï¼Œç„¶åæŠŠä»–æ ‡è®°ä¸ºå¯æŠ¢å ï¼š\n\n```go\n// Always runs without a P, so write barriers are not allowed.\n//\n//go:nowritebarrierrec\nfunc sysmon() {\n\tlock(&sched.lock)\n\tsched.nmsys++\n\tcheckdead()\n\tunlock(&sched.lock)\n\n\t// If a heap span goes unused for 5 minutes after a garbage collection,\n\t// we hand it back to the operating system.\n\tscavengelimit := int64(5 * 60 * 1e9)\n\n\tif debug.scavenge > 0 {\n\t\t// Scavenge-a-lot for testing.\n\t\tforcegcperiod = 10 * 1e6\n\t\tscavengelimit = 20 * 1e6\n\t}\n\n\tlastscavenge := nanotime()\n\tnscavenge := 0\n\n\tlasttrace := int64(0)\n\tidle := 0 // how many cycles in succession we had not wokeup somebody\n\tdelay := uint32(0)\n\tfor {\n\t\tif idle == 0 { // start with 20us sleep...\n\t\t\tdelay = 20\n\t\t} else if idle > 50 { // start doubling the sleep after 1ms...\n\t\t\tdelay *= 2\n\t\t}\n\t\tif delay > 10*1000 { // up to 10ms\n\t\t\tdelay = 10 * 1000\n\t\t}\n\t\tusleep(delay)\n \t\t...\n        // æ³¨é‡Šå¾ˆæ¸…æ¥šäº†\n\t\t// retake P's blocked in syscalls\n\t\t// and preempt long running G's\n\t\tif retake(now) != 0 {\n\t\t\tidle = 0\n\t\t} else {\n\t\t\tidle++\n\t\t}\n\t\t...\n\t}\n}\n\nfunc retake(now int64) uint32 {\n\tn := 0\n\t// åŠ é”\n\tlock(&allpLock)\n\t// éå†påˆ—è¡¨\n\tfor i := 0; i < len(allp); i++ {\n\t\t_p_ := allp[i]\n\t\tif _p_ == nil {\n\t\t\t// This can happen if procresize has grown\n\t\t\t// allp but not yet created new Ps.\n\t\t\tcontinue\n\t\t}\n\t\tpd := &_p_.sysmontick\n\t\ts := _p_.status\n\t\tif s == _Psyscall {\n\t\t\t// è¿™é‡Œæ˜¯å¤„ç†ç³»ç»Ÿè°ƒç”¨æ—¶çš„P\n            // å¦‚æœç³»ç»Ÿè°ƒç”¨é˜»å¡åˆ°ä¸€å®šæ—¶é•¿ï¼Œå¹¶ä¸”å½“å‰æœ‰å…¶ä»–gå¯æ‰§è¡Œæ—¶ï¼Œè€ƒè™‘å°†_Psyscallçš„på¤ºå›è¿‡æ¥ï¼Œæ ‡è®°ä¸º_Pidle\n            ...\n\t\t} else if s == _Prunning { \n            // å¦‚æœå½“å‰På·²ç»åœ¨åŒä¸€ä¸ªGä¸Šè¿è¡Œå¾ˆä¹…äº†ï¼Œæ ‡è®°æŠ¢å \n\t\t\t// Preempt G if it's running for too long.\n\t\t\tt := int64(_p_.schedtick)\n\t\t\tif int64(pd.schedtick) != t {\n\t\t\t\tpd.schedtick = uint32(t)\n\t\t\t\tpd.schedwhen = now\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pd.schedwhen+forcePreemptNS > now {\n\t\t\t\tcontinue\n\t\t\t}\n            // æŠ¢å \n\t\t\tpreemptone(_p_)\n\t\t}\n\t}\n\tunlock(&allpLock)\n\treturn uint32(n)\n}\n\n\nfunc preemptone(_p_ *p) bool {\n\tmp := _p_.m.ptr()\n\tif mp == nil || mp == getg().m {\n\t\treturn false\n\t}\n\tgp := mp.curg\n\tif gp == nil || gp == mp.g0 {\n\t\treturn false\n\t}\n\n    // è®¾ç½®æŠ¢å æ ‡å¿—ä½\n\tgp.preempt = true\n\n\t// Every call in a go routine checks for stack overflow by\n\t// comparing the current stack pointer to gp->stackguard0.\n\t// Setting gp->stackguard0 to StackPreempt folds\n\t// preemption into the normal stack overflow check.\n    // è®¾ç½®gp.stackguard0 = stackPreemptï¼Œä»è€Œèƒ½å¤Ÿè§¦å‘morestack\n\tgp.stackguard0 = stackPreempt\n\treturn true\n}\n```\n\nè‡³æ­¤ï¼Œæˆ‘ä»¬å¯¹`go`ä¸­çš„åä½œå¼æŠ¢å æœºåˆ¶å·²ç»å¾ˆæ˜äº†äº†ï¼Œä½†æ˜¯ï¼ŒæŠ¢å åªæ˜¯æ ‡è®°ä¸€ä¸‹ï¼Œä½ è¯´ä»»ä½ è¯´ï¼Œæˆ‘ä¸ä¸€å®šç…§åšå•Šã€‚\n\n##### ç¼ºé™·\n\nä¹‹æ‰€ä»¥åœ¨å‡½æ•°è°ƒç”¨çš„æ—¶å€™æ‰§è¡Œæ£€æŸ¥æ˜¯å› ä¸ºå‡½æ•°åˆ‡æ¢çš„æ—¶å€™æ˜¯ä¸€ä¸ª`safe point`ï¼Œè¿™æ—¶å€™çš„é€šç”¨å¯„å­˜å™¨æ˜¯ç©ºçš„ï¼Œåˆ‡æ¢åç¨‹ä¸éœ€è¦ä¿å­˜è¿™äº›å¯„å­˜å™¨ï¼Œè€Œä¸”æ ˆä¸­çš„`root pointer`æ˜¯ç¡®å®šçš„ï¼Œèƒ½å¤Ÿç²¾ç¡®æ‰§è¡Œ`gc`æ‰«æã€‚\n\nç„¶è€Œï¼Œå¦‚æœæœ‰ä¸€ä¸ªåç¨‹æ²¡æœ‰å‘ç”Ÿå‡½æ•°è°ƒç”¨ï¼Œæ¯”å¦‚ä¸‹é¢è¿™æ®µä»£ç ï¼š\n\n```go\ni:=0\nfor {\n    i++\n}\n```\n\nè¿™ä¸ªåç¨‹å°±æ²¡æœ‰æœºä¼šè¢«æŠ¢å ï¼Œä¹Ÿå°±ä¸ä¼šè®©å‡º`cpu`ã€‚\n\nå¼€å§‹æ‰§è¡Œ`gc`çš„æ—¶å€™å…ˆæš‚åœæ‰€æœ‰åç¨‹çš„æ‰§è¡Œï¼Œç„¶åå†æ‰§è¡Œ`stop the world`å¼€å¯å†™å±éšœã€‚è¿™æ—¶å€™å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªåç¨‹è·‘çš„æ˜¯ç±»ä¼¼ä¸Šé¢çš„ä»£ç ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç¨‹åºå°±ä¼šç›´æ¥å¡æ­»ï¼š\n\n```go\nfunc main() {\n\tgo func() {\n\t\ti := 0\n\t\t// è¯¥ä»£ç å¯¼è‡´å½“å‰åç¨‹ä¸ä¼šè®©å‡ºcpu\n\t\tfor {\n\t\t\ti++\n\t\t}\n\t}()\n    // sleep 1sï¼Œç¡®ä¿å­åç¨‹å¼€å§‹æ‰§è¡Œ\n\ttime.Sleep(time.Second)\n\tlog.Println(\"å¼€å§‹è§¦å‘gc\")\n\t// è§¦å‘gc\n\truntime.GC()\n\tlog.Println(\"æ‰‹åŠ¨gcå®Œæˆ\")\n}\n```\n\nå› ä¸ºå…¶ä»–åç¨‹å·²ç»è¢«æš‚åœï¼Œè€Œæœ€åè¿™ä¸ªåç¨‹ç”±äºæ²¡æœ‰å‘ç”Ÿå‡½æ•°è°ƒç”¨ï¼Œæ— æ³•æ‰§è¡ŒæŠ¢å æ“ä½œï¼Œä»è€Œåƒåœ¾æ”¶é›†å™¨ä¼šä¸€ç›´å¤„äºç­‰å¾…ï¼Œ`gc`ä¹Ÿä¸€ç›´ä¸ä¼šè¢«è§¦å‘ã€‚å½“ç„¶æˆ‘ä»¬å¹³æ—¶çš„ä¸šåŠ¡ä»£ç ä¸€èˆ¬ä¸ä¼šæœ‰è¿™ç§æƒ…å†µå‘ç”Ÿï¼Œä½†æ˜¯å¦‚æœæœ‰ä¸€ä¸ªå‡½æ•°éœ€è¦æ‰§è¡Œæ¯”è¾ƒä¹…æ‰ä¼šè¢«æŠ¢å ï¼Œé‚£ä¹ˆå°±ä¼šå¯¼è‡´`gc`çš„å»¶æ—¶ï¼ŒåŒæ—¶ä¹Ÿä¼šä¸¥é‡å½±å“ç¨‹åºçš„ååé‡ã€‚\n\n##### go:nosplit\n\nTODO\n\n\n\n### éåä½œå¼æŠ¢å \n\nå› ä¸ºåä½œå¼æŠ¢å å­˜åœ¨å¾ˆæ˜æ˜¾çš„ç¼ºç‚¹ï¼šæŠ¢å ä¸åŠæ—¶ï¼Œæœ‰ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯åœ¨å‡½æ•°ä¸­æ’å…¥ä¸€äº›ç»†ç²’åº¦æ›´å°çš„æŠ¢å æ£€æŸ¥ç‚¹ï¼Œä½†æ˜¯è¿™ä¼šå¯¹æ€§èƒ½äº§ç”Ÿå½±å“ï¼Œæ¯”å¦‚æ¯æ¬¡å¾ªç¯éƒ½éœ€è¦é¢å¤–æ‰§è¡Œä¸€æ¬¡åˆ†æ”¯åˆ¤æ–­ã€‚\n\nå› æ­¤æœ‰äººæå‡ºæ¥éåä½œå¼æŠ¢å æ¥å¼¥è¡¥è¿™ä¸ªç¼ºé™·ï¼Œèƒ½å¤Ÿåœ¨ä»»æ„æŒ‡ä»¤è§¦å‘æŠ¢å ã€‚éåä½œå¼æŠ¢å çš„ä¸»è¦éš¾ç‚¹åœ¨äºå¦‚ä½•æ»¡è¶³`gc`å®‰å…¨ï¼ŒæŠ¢å åº”è¯¥å‘ç”Ÿåœ¨`safe point`ã€‚\n\n","tags":["golang"]},{"title":"ä¸€ç§diffç®—æ³•ï¼šMyers","url":"/2019/05/23/diffç®—æ³•/","content":"\n\n\n# ä¸€ç§diffç®—æ³•ï¼šMyers\n\n### diff\n\n`git`æ˜¯æˆ‘ä»¬æ—¥å¸¸å·¥ä½œä¸­æœ€ç»å¸¸ä½¿ç”¨åˆ°çš„å·¥å…·ï¼Œè€Œå…¶ä¸­`diff`åˆæ˜¯æœ€å¸¸ç”¨åˆ°çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½å»æŸ¥çœ‹ä»£ç çš„å˜æ›´ä¿¡æ¯ï¼Œä»Šå¤©æˆ‘ä»¬å°±æ¥å­¦ä¹ ä¸€ä¸‹`diff`ç®—æ³•çš„å®ç°ã€‚\n\n`diff`ç®—æ³•å¯ä»¥å¯¹ä¸€ä¸ªæ–‡ä»¶ç¼–è¾‘å‰åçš„çŠ¶æ€è¿›è¡Œæ¯”è¾ƒï¼Œè®¡ç®—å‡ºå…¶ä¸­åˆ é™¤å’Œæ–°å¢çš„å†…å®¹ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¤Ÿç›´è§‚çœ‹å‡ºè¯¥æ–‡ä»¶çš„å˜æ›´æƒ…å†µã€‚\n\næˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š\n\n- a = ABCABBA\n- b = CBABAC\n\nå‡è®¾æˆ‘ä»¬å¯¹æ–‡æœ¬`a`è¿›è¡Œä¸€ç³»åˆ—ç¼–è¾‘æ“ä½œä¹‹åï¼Œå¾—åˆ°äº†æ–‡æœ¬`b`ï¼Œè€Œ`diff`æ“ä½œå°±æ˜¯è¦è®¡ç®—å‡ºè¿™äº›ç¼–è¾‘æ“ä½œã€‚\n\nä¸€ç§å¯èƒ½çš„ç¼–è¾‘åºåˆ—æ˜¯å…ˆæŠŠåŸæ¥çš„å†…å®¹å…¨éƒ¨åˆ é™¤ï¼Œç„¶åæ’å…¥æ–°çš„å†…å®¹ï¼Œä½¿ç”¨é€šç”¨çš„`diff`è¡¨ç¤ºç¬¦å·å¦‚ä¸‹ï¼š\n\n```diff\n- A\n- B\n- C\n- A\n- B\n- B\n- A\n+ C\n+ B\n+ A\n+ B\n+ A\n+ C\n```\n\nç„¶è€Œï¼Œä¸Šé¢çš„ä¿¡æ¯æ— æ³•æœ‰æ•ˆå±•ç¤º`a`æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥å˜æ›´åˆ°`b`çš„ï¼Œå› æ­¤ä¸Šé¢çš„`diff`å¹¶æ²¡æœ‰ä»€ä¹ˆå®é™…æ„ä¹‰ã€‚é€šå¸¸æºä»£ç çš„å˜æ›´ï¼Œä¼šä¿ç•™åŸæ¥çš„å¤§éƒ¨åˆ†å†…å®¹ï¼Œè€Œåªå¯¹å…¶ä¸­éƒ¨åˆ†å†…å®¹åšåˆ é™¤å’Œæ·»åŠ ï¼Œæˆ‘ä»¬é€šè¿‡`diff`æ“ä½œæ˜¯å¸Œæœ›çœ‹åˆ°å…¶ä¸­è¢«åˆ é™¤æˆ–è€…æ’å…¥çš„ä»£ç æ®µï¼Œè€Œä¸æ˜¯åƒä¸Šé¢è¿™æ ·ï¼Œå…¨éƒ¨åˆ é™¤ç„¶åæ›¿æ¢æˆæ–°çš„å†…å®¹ã€‚\n\næˆ‘ä»¬æ›´å¸Œæœ›çœ‹åˆ°æ˜¯`diff`æ˜¯ä¸‹é¢è¿™ç§ï¼š\n\n```diff\n- A\n- B\n  C\n+ B\n  A\n  B\n- B\n  A\n+ C\n```\n\nè¿™ç§ä½¿ç”¨æœ€å°‘çš„å˜æ›´æŠŠ`a`è½¬æ¢æˆ`b`ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹å‡º`a`æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥è½¬å˜åˆ°`b`çš„ã€‚ç„¶åè¿™å¹¶ä¸æ˜¯å”¯ä¸€ï¼š\n\n```diff\n1.  - A       2.  - A       3.  + C\n    - B           + C           - A\n      C             B             B\n    - A           - C           - C\n      B             A             A\n    + A             B             B\n      B           - B           - B\n      A             A             A\n    + C           + C           + C\n```\n\nä¸Šé¢å‡ ç§éƒ½æ˜¯ç»è¿‡æœ€å°‘çš„å˜æ›´ã€‚æˆ‘çœ‹å¯ä»¥çœ‹åˆ°ï¼Œä¸€æ®µæ–‡æœ¬ä»`a`å˜æ›´åˆ°`b`çš„ç¼–è¾‘è¿‡ç¨‹å¹¶ä¸æ˜¯å”¯ä¸€çš„ã€‚\n\n`diff`ç®—æ³•çš„ç›®çš„æ˜¯æä¾›ä¸€ç§åœ¨æŸäº›æ–¹æ³•æ¯”è¾ƒç†æƒ³çš„`diff`ç”Ÿæˆç­–ç•¥ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬é™¤äº†å¸Œæœ›`diff`çš„å˜æ›´å°½é‡å°‘ä¹‹å¤–ï¼Œä¹Ÿæœ‰å…¶ä»–æ–¹é¢çš„è€ƒé‡ï¼Œæˆ‘ä»¬å¸Œæœ›ç”Ÿæˆçš„`diff`æ›´å¤Ÿå°½é‡ç›´è§‚ï¼Œç¬¦åˆæˆ‘ä»¬çš„æ“ä½œé€»è¾‘ã€‚\n\næ¯”å¦‚ï¼Œå½“æˆ‘ä»¬ä¿®æ”¹æ–‡ä»¶çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ€»æ˜¯å…ˆåˆ é™¤ä¸€äº›æ—§çš„å†…å®¹ï¼Œç„¶åå†æ·»åŠ ä¸€äº›æ–°çš„å†…å®¹ï¼Œå› æ­¤åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä¼šè§‰å¾—ç¬¬2ç§ä¼šæ¯”ç¬¬3ç§æ›´åŠ ç›´è§‚\n\nè€Œå½“æˆ‘ä»¬æ›´æ–°ä¸€ä¸ªä»£ç å—çš„æ—¶å€™ï¼Œæ€»æ•°å…ˆå…¨éƒ¨åˆ æ‰ç„¶åå†æ’å…¥æ–°çš„å†…å®¹ï¼Œè€Œä¸æ˜¯åˆ æ’äº¤æ›¿ã€‚\n\n```diff\nGood:   - one         Bad:    - one\n        - two                 + four\n        - three               - two\n        + four                + five\n        + five                + six\n        + six                 - three\n```\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œç¬¬ä¸€ç§ä¼šæ¯”ç¬¬äºŒç§æ›´åŠ ç›´è§‚ã€‚\n\nè€Œå¦‚æœå¯¹äºä»£ç çš„å˜æ›´ï¼Œæˆ‘ä»¬ä¹Ÿæ›´å¸Œæœ›èƒ½å¤Ÿç¬¦åˆä»£ç çš„ç»“æ„é€»è¾‘ï¼š\n\n```diff\nGood:   class Foo                   Bad:    class Foo\n          def initialize(name)                def initialize(name)\n            @name = name                        @name = name\n          end                             +   end\n      +                                   +\n      +   def inspect                     +   def inspect\n      +     @name                         +     @name\n      +   end                                 end\n        end                                 end\n```\n\næ¯”å¦‚ä¸Šé¢çš„ä¾‹å­ç§ï¼Œæˆ‘ä»¬æ–°å¢äº†ä¸€ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å¸Œæœ›æ–°å¢çš„`end`æ˜¯å±äºæ–°å¢å‡½æ•°çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯åŸæ¥å‡½æ•°çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¤Ÿå¾ˆç›´è§‚çš„çœ‹å‡ºè¿™é‡Œæ˜¯æ–°å¢äº†ä¸€ä¸ªæ–¹æ³•ã€‚\n\nè€Œ`Myers`ç®—æ³•å°±æ˜¯ä¸€ä¸ªèƒ½å¤Ÿç¬¦åˆè¿™äº›è€ƒé‡çš„ç”Ÿæˆç­–ç•¥ã€‚\n\n### Myersç®—æ³•\n\n`myers`é€šè¿‡è´ªå¿ƒç­–ç•¥ï¼Œåœ¨å‘ç°ä¸€ä¸ªæ–‡æœ¬å·®å¼‚ä¹‹å‰å°½å¯èƒ½å¤šçš„æ¶ˆè´¹ç›¸åŒçš„å†…å®¹ï¼Œå› æ­¤åœ¨ä¸Šé¢æ–°å¢`inspect`æ–¹æ³•çš„ä¾‹å­ä¸­ï¼Œç¬¬ä¸€æ¬¡å‡ºç°çš„`end`ä¸ä¼šè¢«è¯†åˆ«ä¸ºæ–°å¢ï¼Œè¿™èƒ½æœ‰æ•ˆé˜²æ­¢ç¬¬äºŒç§`diff`æƒ…å†µçš„å‘ç”Ÿã€‚å¹¶ä¸”ï¼Œåˆ é™¤æ“ä½œæ€»æ˜¯ä¼˜äºæ’å…¥æ“ä½œï¼Œå› æ­¤ç”Ÿæˆçš„diffä¸­ï¼Œåˆ é™¤æ“ä½œæ€»æ•°èƒ½å¤Ÿå…ˆå‡ºç°ï¼ˆé™¤éæ²¡æœ‰å†…å®¹è¢«åˆ é™¤ï¼‰ã€‚\n\n`Myers`ç®—æ³•æ˜¯åŸºäºæŸ¥æ‰¾æœ€çŸ­ç¼–è¾‘è„šæœ¬ï¼ˆ*shortest edit script*, SESï¼‰çš„æ€æƒ³æå‡ºçš„ã€‚\n\næœ€çŸ­ç¼–è¾‘è„šæœ¬æŸ¥æ‰¾é—®é¢˜å¯ä»¥è¢«å»ºæ¨¡æˆå›¾æœç´¢é—®é¢˜ã€‚\n\næˆ‘ä»¬ç»§ç»­æ‹¿ä¸Šé¢çš„æ–‡æœ¬`a = ABCABBA`å’Œæ–‡æœ¬`b = CBABAC`æ¥è¯´æ˜ã€‚\n\né¦–å…ˆæˆ‘ä»¬æ„å»ºè¿™æ ·ä¸€ä¸ªå›¾ï¼š\n\n![](/img/ses_graph.jpg)\n\nåœ¨ä¸Šé¢çš„åæ ‡ç³»ä¸­ï¼Œå½“æˆ‘ä»¬ä½äºåŸç‚¹`(0,0)`æ—¶ï¼Œè¡¨ç¤ºæˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²`a`ï¼›\n\nå½“æˆ‘ä»¬å‘å³èµ°ï¼Œä¹Ÿå°±æ˜¯å¢åŠ `x`åæ ‡çš„æ—¶å€™ï¼Œå¯¹åº”çš„ä»`a`ä¸­åˆ é™¤ä¸€ä¸ªå­—ç¬¦ï¼Œæ¯”å¦‚æˆ‘ä»¬ä»`(0,0) - > (1,0)`æ—¶ï¼Œæˆ‘ä»¬ä»`a`ä¸­åˆ é™¤å­—ç¬¦`A`ï¼Œè¿™æ—¶å€™æˆ‘ä»¬å½“å‰çš„æ–‡æœ¬å°±å˜æˆäº†`BCABBA`ï¼› \n\nè€Œå½“æˆ‘ä»¬å‘ä¸‹èµ°ï¼Œä¹Ÿå°±æ˜¯å¢åŠ `y`åæ ‡çš„æ—¶å€™ï¼Œå¯¹åº”çš„ä»`b`ä¸­æ’å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œæ¯”å¦‚æˆ‘ä»¬ä»`(1,0) -> (1,1)`çš„æ—¶å€™ï¼Œå¯¹åº”çš„æ’å…¥`b`ä¸­çš„å­—ç¬¦`C`ï¼Œè¿™æ—¶å€™çš„æ–‡æœ¬å˜æˆäº†`CBCABBA`ï¼›\n\nåœ¨ä¸Šé¢çš„æŸäº›ä½ç½®ä¸Šé¢è¿˜æœ‰æ–œå‘ä¸‹çš„è™šçº¿ï¼Œæ¯”å¦‚ä»`(1,1) -> (2,2)`ï¼Œè¿™æ—¶å€™è¡¨ç¤º`a[1]==b[1]`ï¼Œè¿™æ—¶å€™ä¿ç•™è¯¥å­—ç¬¦ï¼Œå¹¶ä¸”åŒæ—¶å¢åŠ `x`åæ ‡å’Œ`y`åæ ‡ï¼›\n\nè€Œå½“æˆ‘ä»¬æ²¿æŸä¸€æ¡è·¯çº¿ä»`(0,0)`èµ°åˆ°`(7,6)`ï¼Œå°±ä»£è¡¨å­—ç¬¦ä¸²`a`ç»è¿‡ä¸€ç³»åˆ—ç¼–è¾‘æ“ä½œä¹‹åè½¬æ¢æˆäº†å­—ç¬¦ä¸²`b`ã€‚\n\næˆ‘ä»¬æŠŠä¸Šé¢çš„å‘å³èµ°è®°ä½œ`del`æ“ä½œï¼Œå‘ä¸‹èµ°è®°ä¸º`ins`æ“ä½œï¼Œæ²¿è™šçº¿èµ°è®°ä¸º`mov`æ“ä½œï¼Œåªæœ‰æ‰§è¡Œ`del`æ“ä½œå’Œ`ins`æ“ä½œæ‰ä¼šè®©å­—ç¬¦ä¸²å‘ç”Ÿå˜æ›´ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä»`(0,0)`åˆ°`(7,6)`æœ‰å¾ˆå¤šæ¡è·¯å¾„å¯è¾¾ï¼Œæœ€å¤šéœ€è¦`7+6`æ¬¡`del`å’Œ`ins`æ“ä½œï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œå…¨åˆ å…¨å¢æ“ä½œã€‚\n\n`myers`ç®—æ³•çš„æ€æƒ³å¾ˆç®€å•ï¼Œå°±æ˜¯è¦æ‰¾å‡ºä¸€æ¡ä»`(0,0)`åˆ°`(7,6)`çš„è·¯å¾„ï¼Œè®©è¿™æ¡è·¯å¾„ä¸­çš„`del`å’Œ`ins`æ“ä½œå°½é‡çš„å°‘ï¼Œè¿™å°±è¦æ±‚è¦å°½é‡æ‰§è¡Œ`mov`æ“ä½œï¼Œå¹¶ä¸”å½“å‡ºç°åˆ†æ”¯é€‰æ‹©çš„æ—¶å€™ï¼Œ`del`æ“ä½œèƒ½å¤Ÿä¼˜å…ˆäº`ins`æ“ä½œã€‚\n\næˆ‘ä»¬å¯¹ä¸Šé¢çš„å›¾ï¼Œä»`(0,0)`å¼€å§‹ï¼ŒæŒ‰ç…§æ¬¡åºè¿›è¡Œéå†ï¼Œæœ€ç»ˆå¯ä»¥å¯åˆ°ä¸‹é¢çš„éå†ç»“æœï¼š\n\n![](/img/ses_graph_s.jpg)\n\né¦–å…ˆæ‰§è¡Œç¬¬ä¸€æ¬¡ç¼–è¾‘æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä»`(0,0) -> (1,0)`ï¼Œæˆ–è€…ä»`(0,0) - > (0,1)`\n\næ¥ç€æ‰§è¡Œç¬¬äºŒæ¬¡ç¼–è¾‘æ“ä½œï¼Œæˆ‘ä»¬è¦åœ¨ç¬¬ä¸€æ¬¡æ“ä½œçš„åŸºç¡€ä¸Šè¿›è¡Œï¼Œå› ä¸º`del`æ“ä½œä¼˜å…ˆäº`ins`æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬è¦ä¼˜å…ˆæ‰©å±•`(1,0)`è¿™ä¸ªç‚¹ï¼Œä»`(1,0)`å¯ä»¥èµ°åˆ°`(1,1)`å’Œ`(2,0)`ï¼Œåˆå› ä¸º`(1,1)`åˆ°`(2,2)`ä»¥åŠ`(2,0)`åˆ°`(3,1)`å­˜åœ¨è™šçº¿ï¼Œ`mov`æ“ä½œä¸ä¼šä»¤æ–‡æœ¬å†…å®¹å‘ç”Ÿå˜æ›´ï¼Œå¹¶ä¸æ˜¯ç¼–è¾‘æ“ä½œï¼Œè¿˜è®°å¾—ä¸Šé¢è¯´çš„è´ªå¿ƒç­–ç•¥å—ï¼Ÿ`myers`å°½å¯èƒ½çš„æ¶ˆè´¹ç›¸åŒæ–‡æœ¬å†…å®¹ï¼Œå› æ­¤ä»`(1,0)`æœ€ç»ˆèµ°åˆ°äº†`(2,2)`å’Œ`(3,1)`ï¼›æ¥ç€æ‰©å±•`(0,1)`è¿™ä¸ªç‚¹ï¼Œ`(0,1)`å¯ä»¥èµ°åˆ°`(2,2)`å’Œ`(2,4)`\n\næ¥ç€æ‰§è¡Œç¬¬ä¸‰æ¬¡ã€ç¬¬å››æ¬¡...æ“ä½œï¼Œç›´åˆ°ç¬¬ä¸€æ¬¡è¾¾åˆ°`(7,6)`è¿™ä¸ªåæ ‡ï¼Œç¬¬ä¸€æ¬¡åˆ°è¾¾è¯´æ˜è¿™æ—¶å€™çš„ç¼–è¾‘æ¬¡æ•°æ˜¯æœ€å°‘çš„ï¼Œæœ€ç»ˆçš„éå†ç»“æœå¦‚ä¸Šå›¾æ‰€ç¤ºã€‚\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸€æ¬¡çš„ç¼–è¾‘éƒ½æ˜¯åŸºäºä¸Šæ¬¡çš„ç¼–è¾‘ç»“æœè¿›è¡Œçš„ï¼Œæˆ‘ä»¬åœ¨æ¯æ¬¡ç¼–è¾‘ä¸­ï¼Œéƒ½åŸºäºä¸Šæ¬¡çš„ç»“æœé€‰æ‹©å‘å³æˆ–è€…å‘ä¸‹èµ°ä¸€æ­¥ï¼Œç„¶åå†æ‰§è¡Œ`0`æ¬¡æˆ–è€…å¤šæ¬¡`mov`æ“ä½œï¼Œä»è€Œè¾¾åˆ°å½“å‰ç¼–è¾‘ç»“æœã€‚\n\nä¸ºäº†æ›´ç›´è§‚çš„å‘ç°ç®—æ³•çš„è§„å¾‹ï¼Œæˆ‘ä»¬æŠŠä¸Šå›¾é€†æ—¶é’ˆæ—‹è£…45Â°ï¼š\n\n![](/img/ses_graph_d.jpg)\n\nåœ¨ä¸Šå›¾ä¸­ï¼Œæ¨ªåæ ‡`d`è¡¨ç¤ºç¼–è¾‘æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯ç›®å‰ä¸ºæ­¢å·²ç»æ‰§è¡Œäº†å¤šå°‘æ¬¡`del`æˆ–è€…`ins`ç¼–è¾‘æ“ä½œï¼Œä¹Ÿå³å›¾çš„æœç´¢æ·±åº¦ï¼›è€Œçºµåæ ‡`k = x - y`ï¼Œå½“æˆ‘ä»¬å‘ç”±ç§»åŠ¨æ—¶ï¼Œ`k`å€¼ä¼šåŠ 1ï¼Œå½“å‘ä¸‹ç§»åŠ¨æ—¶ï¼Œ`k`å€¼ä¼šå‡1ï¼Œè€Œå½“æ²¿ç€è™šçº¿ç§»åŠ¨æ—¶ï¼Œ`k`å€¼å¹¶ä¸ä¼šå˜åŒ–ã€‚æˆ‘ä»¬éœ€è¦è®°å½•æŒ‡å®š`d`æ—¶ï¼Œæ¯ä¸ª`k`å€¼å¯ä»¥è¾¾åˆ°çš„æœ€è¿œè®°å½•ï¼Œåªéœ€è¦è®°å½•å½“å‰ç»™å®š`d`å’Œ`k`æ—¶ï¼Œå¯¹åº”çš„`x`å°±è¡Œäº†ï¼Œå› ä¸º`y = x - k`ã€‚\n\nç°åœ¨æˆ‘ä»¬å¯ä»¥æ¥çœ‹ä¸€ä¸‹`myers`ç®—æ³•çš„æ‰§è¡Œè¿‡ç¨‹ï¼š\n\n1. æˆ‘ä»¬é¦–å…ˆä»`0`åˆ°`(len(a)+len(b))`éå†`d`\n2. æ¯æ¬¡è¿­ä»£`b`æ—¶ï¼Œæˆ‘ä»¬ä»¥æ­¥é•¿ä¸º`2`ä»`-d`åˆ°`d`éå†`k`ï¼›è¿™é‡Œä¸ºä»€ä¹ˆæ­¥é•¿æ˜¯`2`å‘¢ï¼Ÿä»”ç»†è§‚å¯Ÿä¸Šå›¾ï¼Œå½“å‰`d`çš„èŠ‚ç‚¹éƒ½æ˜¯ä»`d-1`çš„èŠ‚ç‚¹æ‰©å±•è€Œæ¥ï¼Œ`d-1`çš„èŠ‚ç‚¹è¦ä¹ˆå‘å³èµ°ï¼Œ`k`åŠ `1`ï¼Œè¦ä¹ˆå‘ä¸‹èµ°ï¼Œ`k`å‡`1`ï¼Œè¿™æ—¶å€™åŒä¸€ä¸ª`d`çš„ç›¸é‚»çš„ä¸¤ä¸ª`k`ä¹‹é—´å·®å€¼å°±æ˜¯`2`ã€‚\n3. å¯¹äºç»™å®šçš„`d`å’Œ`k`å€¼ï¼Œæˆ‘ä»¬æ ¹æ®ä¸Šä¸€è½®éå†çš„ç»“æœï¼Œå†³å®šå½“å‰çš„æœ€ä½³ä½ç½®ï¼Œè¿™é‡Œçš„æœ€ä½³ä½ç½®æ„å‘³ç€å–`x`å€¼æœ€å¤§çš„ç‚¹ï¼Œå› ä¸ºè¿™å°±æ„å‘³ç€ä¼˜å…ˆæ‰§è¡Œ`del`æ“ä½œã€‚å½“å‰`(d,k)`çš„ç‚¹å¯ä»¥ä»`(d-1,k-1)`å‘å³èµ°ä¸€æ­¥ï¼Œä¹Ÿå¯ä»¥ä»`(d-1,k+1)`å‘ä¸‹èµ°ä¸€æ­¥ã€‚å½“`(d-1,k+1)`çš„`x`å€¼æ¯”`(d-1,k-1)`çš„å¤§ï¼Œåˆ™å…¶ä¼˜å…ˆçº§æ›´é«˜ï¼Œå› ä¸ºå®ƒå·²ç»æ‰§è¡Œäº†æ›´å¤šçš„åˆ é™¤æ“ä½œï¼Œè€Œå½“å…·æœ‰ç›¸åŒçš„`x`å€¼æ—¶ï¼Œåº”è¯¥é€‰æ‹©`(d-1,k-1)`ï¼Œè¿™æ—¶å€™å‘å³èµ°æ‰§è¡Œ`del`æ“ä½œã€‚\n\n\n\n### Code\n\n```go\ntype Diffable interface {\n\tLenA() int           // length of src\n\tLenB() int           // length of dest\n\tEqual(int, int) bool // compare src[ai] and dest[bi]\n}\n\nfunc Myers(ab Diffable) EditScript {\n\taLen := ab.LenA() // è·å–åŸæ–‡æœ¬açš„é•¿åº¦\n\tbLen := ab.LenB() // ç›®æ ‡æ–‡æœ¬bçš„é•¿åº¦\n\tmax := aLen + bLen // æœ€å¤§çš„ç¼–è¾‘æ¬¡æ•°æ˜¯aLen+bLenï¼Œå³å®Œå…¨æ›¿æ¢å†…å®¹\n    // è¿™é‡Œvæ˜¯ä¸€ä¸ªç¨€ç–æ•°ç»„ï¼Œå¹¶ä¸”è¿™é‡Œç©ºé—´åˆ†é…å®é™…ä¸Šä¹Ÿè¿‡å¤§ï¼Œå¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–\n    v := make([]int, 2*max+1) // ä¿å­˜æŒ‡å®šdæ—¶ï¼Œå¯¹åº”kçš„xå€¼ï¼Œå› ä¸ºkå¯èƒ½æ˜¯è´Ÿæ•°ï¼Œè¿™é‡Œå®é™…ä½¿ç”¨maxä½œä¸º0\n\ttrace := make([][]int, 0) // ä¿å­˜æ¯ä¸ªdçš„v\nsearch:\n\t// myers\n    // ä»0åˆ°maxéå†d\n    // d==0çš„æ—¶å€™ï¼Œå¯èƒ½æ‰§è¡ŒMOVæ“ä½œï¼Œå³(d,v)=(0,0)çš„æ—¶å€™ï¼Œxä¸ä¸€å®šä¸º0\n\tfor d := 0; d <= max; d++ {\n        // ä¿å­˜ä¸Šä¸€è½®è¿­ä»£çš„v\n        // ç¬¬ä¸€æ¬¡è¿­ä»£çš„æ—¶å€™ï¼Œä¿å­˜ä¸€ä¸ªç©ºçš„vï¼Œæ–¹ä¾¿åé¢çš„å›æº¯\n\t\tvc := make([]int, 2*max+1)\n\t\tcopy(vc, v)\n        // trace[d]ä¿å­˜çš„æ˜¯d-1è½®çš„v\n\t\ttrace = append(trace, vc)\n\t\t// æŒ‰ç…§æ­¥é•¿ä¸º2ä»-dåˆ°dè¿­ä»£k\n\t\tfor k := -d; k <= d; k += 2 {\n            // å¾ˆå®¹æ˜“å‘ç°ï¼Œkæœ€å°æ˜¯-bLen,æœ€å¤§æ˜¯aLenï¼Œå› æ­¤è¿™é‡Œå¯ä»¥æœ‰ä¸€ä¸ªåˆ¤æ–­ï¼Œè·³è¿‡æ— æ•ˆçš„kå€¼\n\t\t\tif k < -bLen || k > aLen {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar x int\n            // å¦‚æœk==-dï¼Œè¿™æ—¶å€™åªèƒ½ç”±(d-1,k+1)å‘ä¸‹èµ°\n            // å¦‚æœk==dï¼Œè¿™æ—¶å€™åªèƒ½ç”±(d-1,k-1)å‘å³èµ°\n            // å¦‚æœ (d-1,k+1)çš„xå€¼å¤§äº(d-1,k-1)ï¼Œåˆ™è¯´æ˜ä¼˜å…ˆçº§å¤§ï¼Œå¾€ä¸‹èµ°\n            // å¦åœ¨ (d-1,k-1)å¾€å³èµ°\n\t\t\tif k == -d || (k != d && v[max+k-1] < v[max+k+1]) {\n\t\t\t\tx = v[max+k+1]\n\t\t\t} else {\n\t\t\t\tx = v[max+k-1] + 1\n\t\t\t}\n\n            // k=x-yï¼Œå› æ­¤y=x-k\n\t\t\ty := x - k\n            // åˆ¤æ–­æ˜¯å¦å¯ä»¥æ‰§è¡ŒMOVæ“ä½œ\n\t\t\tfor x < aLen && y < bLen && ab.Equal(x, y) {\n\t\t\t\tx++\n\t\t\t\ty++\n\t\t\t}\n\n            // è®¾ç½®å½“å‰(d,k)çš„xå€¼\n\t\t\tv[max+k] = x\n\t\t\t// åˆ¤æ–­æ˜¯å·²ç»åˆ°åˆ°ç›®æ ‡\n\t\t\tif x == aLen && y == bLen {\n\t\t\t\tbreak search\n\t\t\t}\n\t\t}\n\t}\n \t\n    // å›æº¯\n\tfor d := len(trace) - 1; d >= 0; d-- {\n\t\tv := trace[d] // è·å–å‰ä¸€è½®çš„v\n\t\tk := x - y // å½“å‰k\n\n\t\tvar prevk int\n\t\t// è®¡ç®—å‰é©±ç»“ç‚¹çš„kå€¼\n\t\tif k == -d || (k != d && v[max+k-1] < v[max+k+1]) {\n\t\t\tprevk = k + 1\n\t\t} else {\n\t\t\tprevk = k - 1\n\t\t}\n\t\t// ä»å†å²çŠ¶æ€è·å–xå€¼å¹¶è®¡ç®—yå€¼\n\t\tprevx := v[max+prevk]\n\t\tprevy := prevx - prevk\n        // åˆ¤æ–­æ˜¯å¦æ‰§è¡Œäº†movæ“ä½œ\n\t\tfor x > prevx && y > prevy {\n\t\t\tscript = append(script, OpMov)\n\t\t\tx--\n\t\t\ty--\n\t\t}\n\t\t// å¦‚æœå½“å‰d>0\n\t\tif d > 0 {\n            // å¦‚æœxæ²¡æœ‰å˜åŒ–ï¼Œåˆ™è¯´æ˜å‘ä¸‹èµ°ï¼Œinsæ“ä½œ\n\t\t\tif x == prevx {\n\t\t\t\tscript = append(script, OpInsert)\n\t\t\t} else {\n                // å¦åœ¨å°±æ˜¯delæ“ä½œ\n\t\t\t\tscript = append(script, OpDel)\n\t\t\t}\n\t\t}\n\t\t// æ›´æ–°x,yçš„å€¼\n\t\tx, y = prevx, prevy\n\t}\n\t// å›æº¯è·å–åˆ°çš„ç¼–è¾‘é¡ºåºæ˜¯é€†åºçš„\n\treturn script.reverse()\n}\n```\n\n\n\n[å®Œæ•´ä»£ç ](<https://github.com/ymcvalu/godiff>)\n\n### å‚è€ƒ\n\n- **[the-myers-diff-algorithm](<https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/>)**\n- **[pkg-diff](<https://github.com/pkg/diff>)**\n- [Gitæ˜¯æ€æ ·ç”Ÿæˆdiffçš„ï¼šMyersç®—æ³•](<https://cjting.me/misc/how-git-generate-diff/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io>)\n\n\n\n","tags":["diff","myers"]},{"title":"goæ€§èƒ½åˆ†æ","url":"/2019/05/12/goæ€§èƒ½åˆ†æ/","content":"\næœ¬æ–‡æ€»ç»“ä¸€ä¸‹goä¸­ç”¨æ¥è¿›è¡Œæ€§èƒ½è°ƒè¯•çš„æ–¹æ³•ï¼Œå…ˆå ä¸ªå‘ï¼Œåé¢æ…¢æ…¢å®Œå–„\\~\\~\\~\n\n### go tool pprof\n\n### go tool trace \n\n### GODEBUG\n\n\n\n### å‚è€ƒæ–‡æ¡£\n\n- [high-performance-go-workshop](<https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html>)","tags":["go","æ€§èƒ½åˆ†æ"]},{"title":"goçš„æ¥å£å€¼","url":"/2019/05/11/goä¸­çš„iface/","content":"# iface\n\n### ç»“æ„\n\n```go\ntype iface struct {\n\ttab  *itab\n\tdata unsafe.Pointer \n}\n\n// layout of Itab known to compilers\n// allocated in non-garbage-collected memory\n// Needs to be in sync with\n// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.\ntype itab struct {\n\tinter *interfacetype // æ¥å£ç±»å‹\n\t_type *_type         // å®é™…ç±»å‹\n\thash  uint32         // copy of _type.hash. Used for type switches.\n\t_     [4]byte        // 4å­—èŠ‚å¡«å……ï¼Œä¸ä¸Šé¢çš„4å­—èŠ‚hashå‡‘æˆ8å­—èŠ‚ï¼Œä¸nå†…å­˜å¯¹é½ç›¸å…³\n    // itabæœ«å°¾æ˜¯å®ç°æ–¹æ³•çš„å¼•ç”¨ï¼Œå¦‚æœå¤šä½™1ä¸ªï¼Œåˆ™å…¶ä½™æ–¹æ³•å¼•ç”¨ç´§è·Ÿitabå†…å­˜ä¹‹ååˆ†é…\n\tfun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.\n}\n\ntype interfacetype struct {\n\ttyp     _type // æ¥å£ç±»å‹ä¿¡æ¯\n\tpkgpath name\t \n\tmhdr    []imethod // æ¥å£å£°æ˜çš„æ–¹æ³•\n}\n\n\n// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,\n// ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and\n// ../reflect/type.go:/^type.rtype.\ntype _type struct {\n\tsize       uintptr\n\tptrdata    uintptr  // size of memory prefix holding all pointers\n\thash       uint32   // ç±»å‹hashå€¼\n\ttflag      tflag    // ç±»å‹ç›¸å…³ä¸€äº›flagï¼Œå¯ä»¥åœ¨åå°„åŒ…ä¸­ä½¿ç”¨\n\talign      uint8    // å†…å­˜å¯¹é½\n\tfieldalign uint8    // å­—æ®µå¯¹é½\n\tkind       uint8    // ç±»å‹kind\n\talg        *typeAlg // ç±»å‹çš„hashå’Œequalæ–¹æ³•\n\t// gcdata stores the GC type data for the garbage collector.\n\t// If the KindGCProg bit is set in kind, gcdata is a GC program.\n\t// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n\tgcdata    *byte\n\tstr       nameOff   // offset of name\n\tptrToThis typeOff   \n}\n```\n\nè¿™é‡Œçš„`_type`æ˜¯æœ€åŸºæœ¬çš„ç±»å‹ä¿¡æ¯ï¼Œè€Œå®é™…æˆ‘ä»¬å£°æ˜çš„ç±»å‹è¿˜æœ‰åŒ…å«å­—æ®µã€æ–¹æ³•ç­‰ä¿¡æ¯ï¼ŒæŸ¥çœ‹ä¸‹é¢ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°`_type`åªæ˜¯å®é™…ç±»å‹ç»“æ„çš„ä¸€éƒ¨åˆ†\n\n```go\ntype uncommontype struct {\n\tpkgpath nameOff\n\tmcount  uint16 // number of methods\n\txcount  uint16 // number of exported methods\n\tmoff    uint32 // offset from this uncommontype to [mcount]method\n\t_       uint32 // unused\n}\n\nfunc (t *_type) uncommon() *uncommontype {\n\tif t.tflag&tflagUncommon == 0 {\n\t\treturn nil\n\t}\n\tswitch t.kind & kindMask {\n\tcase kindStruct:\n\t\ttype u struct {\n\t\t\tstructtype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindPtr:\n\t\ttype u struct {\n\t\t\tptrtype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindFunc:\n\t\ttype u struct {\n\t\t\tfunctype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindSlice:\n\t\ttype u struct {\n\t\t\tslicetype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindArray:\n\t\ttype u struct {\n\t\t\tarraytype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindChan:\n\t\ttype u struct {\n\t\t\tchantype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindMap:\n\t\ttype u struct {\n\t\t\tmaptype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tcase kindInterface:\n\t\ttype u struct {\n\t\t\tinterfacetype\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\tdefault:\n\t\ttype u struct {\n\t\t\t_type\n\t\t\tu uncommontype\n\t\t}\n\t\treturn &(*u)(unsafe.Pointer(t)).u\n\t}\n}\n```\n\n\n\n### é€šè¿‡æ±‡ç¼–çœ‹iface\n\n```go\nfunc main() {\n\tvar r io.Reader = Arr{}\n\tr.Read(nil)\n}\n\ntype Arr []byte\n\nfunc (Arr) Read(n []byte) (int, error) {\n\treturn 0, nil\n}\n```\n\n```sh\n$ go tool compile -S main.go > main.s\n```\n\n```assembly\n\t0x0000 00000 (test.go:7)\tTEXT\t\"\".main(SB), $88-0\n\t...\n\t0x0024 00036 (test.go:8)\tLEAQ\ttype.[0]uint8(SB), AX  // newobjectæ–¹æ³•å‚æ•°\n\t0x002b 00043 (test.go:8)\tMOVQ\tAX, (SP)\n\t0x002f 00047 (test.go:8)\tCALL\truntime.newobject(SB)\n\t0x0034 00052 (test.go:8)\tMOVQ\t8(SP), AX // è¿™é‡ŒæŠŠè¿”å›çš„æŒ‡é’ˆä¿å­˜åˆ°AX\n\t0x0039 00057 (test.go:8)\tMOVQ\tAX, \"\"..autotmp_1+56(SP) // Arrå¯¹è±¡\n\t0x003e 00062 (test.go:8)\tXORPS\tX0, X0\n\t0x0041 00065 (test.go:8)\tMOVUPS\tX0, \"\"..autotmp_1+64(SP)\n\t0x0046 00070 (test.go:8)\tLEAQ\tgo.itab.\"\".Arr,io.Reader(SB), AX // itab\n\t0x004d 00077 (test.go:8)\tMOVQ\tAX, (SP)\n\t0x0051 00081 (test.go:8)\tLEAQ\t\"\"..autotmp_1+56(SP), AX // Arrå¯¹è±¡æŒ‡é’ˆ\n\t0x0056 00086 (test.go:8)\tMOVQ\tAX, 8(SP)\n\t0x005b 00091 (test.go:8)\tCALL\truntime.convT2Islice(SB) // ç”Ÿæˆiface\n\t0x0060 00096 (test.go:8)\tMOVQ\t24(SP), AX // æ¥å£çš„dataå­—æ®µ\n\t0x0065 00101 (test.go:8)\tMOVQ\t16(SP), CX // æ¥å£çš„tabå­—æ®µï¼Œå³itabè¡¨\n\t0x006a 00106 (test.go:9)\tMOVQ\t24(CX), CX // itabçš„24~32ä¸ºå®é™…æ–¹æ³•Readåœ°å€\n\t// 110~127æ„é€ ä¸€ä¸ª Arr{0 0 data}ç»“æ„ï¼Œæ¥è°ƒç”¨æ–¹æ³•Read\n\t// å®é™…ä¸Šæ–¹æ³•çš„æ¥æ”¶è€…å°±æ˜¯æ–¹æ³•ç¬¬ä¸€ä¸ªå‚æ•°\n\t0x006e 00110 (test.go:9)\tMOVQ\t$0, 8(SP) // 0\n\t0x0077 00119 (test.go:9)\tXORPS\tX0, X0 \n\t0x007a 00122 (test.go:9)\tMOVUPS\tX0, 16(SP) // 0\n\t0x007f 00127 (test.go:9)\tMOVQ\tAX, (SP) // data\n\t0x0083 00131 (test.go:9)\tCALL\tCX // è°ƒç”¨Readæ–¹æ³•\n\t0x008e 00142 (test.go:10)\tRET\n\n// æœ‰äº›itabåœ¨ç¼–è¯‘æœŸé—´å¯ä»¥è‡ªåŠ¨ç”Ÿæˆ\n// å¯èƒ½åœ¨aæ–‡ä»¶å£°æ˜äº†Arrï¼Œbæ–‡ä»¶ä¸­å£°æ˜äº†æ¥å£Readerï¼Œåœ¨CåŒ…æ–‡ä»¶cå’ŒDåŒ…æ–‡ä»¶déƒ½ç”¨åˆ°äº†Arråˆå§‹åŒ–æ¥å£Readerï¼Œ\n// åˆ™ä¼šåœ¨cæ–‡ä»¶å’Œdæ–‡ä»¶éƒ½ç”Ÿæˆè¿™ä¸ªitabè¡¨ï¼Œå› æ­¤å£°æ˜ä¸ºdupokï¼Œç”±é“¾æ¥å™¨ä»»æ„é€‰æ‹©ä¸€ä¸ª\ngo.itab.\"\".Arr,io.Reader SRODATA dupok size=32\n\t0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\t0x0010 d6 ed 1d 4e 00 00 00 00 00 00 00 00 00 00 00 00  ...N............\n\trel 0+8 t=1 type.io.Reader+0\n\trel 8+8 t=1 type.\"\".Arr+0\n\trel 24+8 t=1 \"\".(*Arr).Read+0 // è¿™é‡Œrelå‘Šè¯‰é“¾æ¥å™¨è¦å°†24~32çš„ç¬¦å·å¼•ç”¨æ›¿æ¢æˆæ–¹æ³•çš„é€»è¾‘åœ°å€\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œå®ç°æ¥å£çš„æ–¹æ³•å¼•ç”¨åˆ—è¡¨ä¼šä¿å­˜åœ¨itabæœ«å°¾ï¼Œè°ƒç”¨æ—¶ï¼Œéœ€è¦å…ˆè®¡ç®—å…·ä½“è°ƒç”¨å‡½æ•°çš„åç§»è·å–å®é™…æ–¹æ³•å¼•ç”¨\n\nä¸Šé¢ç”Ÿæˆæ¥å£å€¼çš„æ—¶å€™ï¼Œè°ƒç”¨äº†`runtime.convT2Islice`æ–¹æ³•ï¼Œå…¶å®åœ¨`runtime.iface.go`ä¸­å£°æ˜äº†ä¸€ç³»åˆ—`runtime.convT2IXXX`çš„æ–¹æ³•ï¼Œè¡¨ç¤ºå°†`XXX`ç±»å‹çš„å€¼è½¬æ¢æˆä¸€ä¸ªæ¥å£å€¼ï¼Œå› ä¸ºè¿™é‡Œçš„ä¾‹å­ä¸­ï¼Œ`Arr`çš„`Kind`æ˜¯`slice`ï¼Œå› æ­¤è°ƒç”¨çš„æ˜¯`runtime.convT2Islice`è¿™ä¸ªæ–¹æ³•ã€‚\n\nä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`convT2Islice`å’Œ`convT2I`è¿™ä¸¤ä¸ªæ–¹æ³•çš„å®ç°ã€‚\n\nå…ˆæ¥çœ‹`convT2Islice`ï¼š\n\n```go\n// å‚æ•°elemå®é™…ä¸Šæ˜¯ä¸€ä¸ªsliceçš„æŒ‡é’ˆ\n// å°†ä¸€ä¸ªå®é™…ç±»å‹çš„å€¼è½¬æ¢æˆæ¥å£å€¼è¿™ç§æƒ…å†µï¼Œitabç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆ\nfunc convT2Islice(tab *itab, elem unsafe.Pointer) (i iface) {\n\tt := tab._type //è¿™é‡Œçš„_typeå°±æ˜¯è¯¥æ¥å£èƒŒåçš„çœŸå®æ•°æ®ç±»å‹\n\tif raceenabled {\n\t\traceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2Islice))\n\t}\n\tif msanenabled {\n\t\tmsanread(elem, t.size)\n\t}\n\tvar x unsafe.Pointer\n    // å¦‚æœåˆ‡ç‰‡çš„åº•å±‚æ•°ç»„æ˜¯nil\n\tif v := *(*slice)(elem); uintptr(v.array) == 0 {\n\t\tx = unsafe.Pointer(&zeroVal[0])\n\t} else {\n\t\tx = mallocgc(t.size, t, true) // åˆ†é…ä¸€ä¸ªslice\n\t\t*(*slice)(x) = *(*slice)(elem) // èµ‹å€¼\n\t}\n\ti.tab = tab\n\ti.data = x // è¿”å›çš„æ¥å£å€¼ä¸­çš„dataæŒ‡å‘çš„å†…å­˜æ˜¯elemçš„æ‹·è´\n\treturn\n}\n```\n\nç„¶åæ˜¯`convT2I`ï¼Œè¿™ä¸ªæ˜¯æ¯”è¾ƒé€šç”¨çš„è½¬æ¢æ–¹æ³•ï¼š\n\n```go\n// è¿™é‡Œçš„elemæ˜¯è¦è½¬æ¢æˆæ¥å£å€¼çš„å®é™…å€¼çš„æŒ‡é’ˆ\n// ç”±å®é™…ç±»å‹è½¬æ¢æˆæ¥å£ç±»å‹çš„æƒ…å†µï¼Œitabç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆ\nfunc convT2I(tab *itab, elem unsafe.Pointer) (i iface) {\n\tt := tab._type \n\tif raceenabled {\n\t\traceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I))\n\t}\n\tif msanenabled {\n\t\tmsanread(elem, t.size)\n\t}\n\tx := mallocgc(t.size, t, true) // è¿™é‡Œæ ¹æ®*elemçš„å¤§å°åˆ†é…ä¸€å—å†…å­˜\n\ttypedmemmove(t, x, elem) // å†…å­˜æ‹·è´\n\ti.tab = tab\n\ti.data = x\n\treturn\n}\n```\n\nå½“æˆ‘ä»¬æŠŠä¸€ä¸ª**éæŒ‡é’ˆå€¼**èµ‹ç»™ä¸€ä¸ªæ¥å£ç±»å‹çš„å˜é‡æ—¶ï¼Œå°±ä¼šè°ƒç”¨è¯¥æ–¹æ³•ã€‚**è¿™é‡Œæˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œ`iface.data`ä¸æ˜¯ç›´æ¥æŒ‡å‘æ¥å£èƒŒåçš„å®é™…å€¼ï¼Œè€Œæ˜¯æŒ‡å‘å…¶æ‹·è´ï¼Œå› ä¸ºè¿™ä¸ªåŸå› ï¼Œä¹Ÿå°±å¾ˆå¥½ç†è§£ä¸ºä»€ä¹ˆæ–¹æ³•æ¥æ”¶è€…æ˜¯æŒ‡é’ˆçš„è¯ï¼Œå€¼ç±»å‹å°±ä¸ä¼šå®ç°å¯¹åº”çš„æ¥å£ç±»å‹äº†ï¼Œå› ä¸ºè®¿é—®çš„æ ¹æœ¬ä¸æ˜¯åŒä¸€ä¸ªå˜é‡ã€‚**\n\nè€Œå½“æŠŠä¸€ä¸ªæŒ‡é’ˆå€¼èµ‹ç»™ä¸€ä¸ªæ¥å£ç±»å‹çš„å˜é‡å‘¢ï¼Ÿç¼–è¯‘å™¨ä¼šç›´æ¥ç”Ÿæˆä»£ç ï¼Œè¿™ä¸ªæ—¶å€™`iface.data`å°±æ˜¯è¯¥æŒ‡é’ˆå€¼ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸ªå°`demo`éªŒè¯ä¸€ä¸‹ï¼š\n```go\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\ntype eface struct {\n\ttyp  uintptr\n\tdata unsafe.Pointer\n}\n\nfunc main() {\n\tn := struct {\n\t\tT int\n\t}{}\n\n\tpi := interface{}(&n)\n\tvi := interface{}(n)\n\n\t_pi := *(*eface)(unsafe.Pointer(&pi))\n\t_vi := *(*eface)(unsafe.Pointer(&vi))\n\n\tfmt.Printf(\"%p %p %p\\n\", &n, _pi.data, _vi.data) // 0xc000060090 0xc000060090 0x597500\n}\n```\nä»£ç ä¸­æˆ‘ä»¬ä½¿ç”¨ç©ºæ¥å£ï¼Œå®é™…ä¸Šç©ºæ¥å£å¯¹åº”çš„å®šä¹‰`eface`å’Œ`iface`çš„å·®åˆ«åªæœ‰ç¬¬ä¸€ä¸ªå­—æ®µï¼Œå› ä¸ºå®ƒæ²¡æœ‰æ–¹æ³•è¡¨ï¼Œç›´æ¥å­˜å‚¨çš„å°±æ˜¯å€¼çš„ç±»å‹ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ¥å£å€¼`vi`å®é™…å­˜å‚¨çš„æ˜¯å˜é‡`n`çš„åœ°å€ï¼Œè€Œ`vi.data`æ­¤æ—¶å­˜çš„å°±æ˜¯`n`çš„åœ°å€ã€‚\nçœ‹ä¸€ä¸‹å¯¹åº”çš„æ±‡ç¼–ç‰‡æ®µï¼š\n```\n LEAQ\ttype.struct { T int }(SB), AX\n MOVQ\tAX, (SP)\n CALL\truntime.newobject(SB)  // ä»£ç é‡Œé¢ç”¨çš„unsafe.Pointerï¼Œå› ä¸ºä¼ åˆ°fmt.Printfé‡Œé¢ï¼Œé€ƒé€¸åˆ†æè®¤ä¸ºè¯¥å˜é‡é€ƒé€¸äº†\n MOVQ\t8(SP), AX              // newobjectè¿”å›çš„åœ°å€\n MOVQ\tAX, \"\"..autotmp_41+80(SP) // ä¿å­˜åˆ°æ ˆä¸Šçš„ä¸´æ—¶å˜é‡ä¸­\n LEAQ\ttype.*struct { T int }(SB), CX  // *struct{T int}çš„ _type\n MOVQ\tCX, \"\".pi+88(SP)                // è®¾ç½®piçš„ _type\n MOVQ\tAX, \"\".pi+96(SP)                //  è®¾ç½®piçš„dataï¼Œè¿™é‡Œdataå°±æ˜¯nçš„åœ°å€\n```\n\n### æ¥å£ç±»å‹è½¬æ¢\n\n```go\n// æ¥å£è½¬æ¢\nfunc convI2I(inter *interfacetype, i iface) (r iface) {\n   tab := i.tab\n   if tab == nil {\n      return\n   }\n   if tab.inter == inter {\n      r.tab = tab\n      r.data = i.data\n      return\n   }\n   r.tab = getitab(inter, tab._type, false)\n   r.data = i.data\n   return\n}\n```\n\n**å°†æ¥å£å€¼Aå¼ºåˆ¶è½¬æ¢æˆæ¥å£Bæ—¶ï¼Œéœ€è¦æ»¡è¶³ï¼šæ¥å£Açš„æ–¹æ³•é›†åŒ…å«æˆ–è€…ç­‰äºæ¥å£Bçš„æ–¹æ³•é›†**\n\næ¥å£å€¼ä¹‹é—´çš„ç±»å‹è½¬æ¢ï¼Œä¸ä¼šè€ƒè™‘å®é™…ç±»å‹çš„æ–¹æ³•é›†ï¼Œè€Œæ˜¯ç®€å•çš„å¯¹æ¥å£çš„æ–¹æ³•é›†è¿›è¡Œåˆ¤æ–­ï¼Œè¿™ä¸ªåœ¨ç¼–è¯‘æ—¶å°±å¯ä»¥è¿›è¡Œæ£€æŸ¥\n\n```go\nvar r io.ReadCloser = XXX{}\nr.Read(nil)\n_ = io.Reader(r) // ok\n_ = io.ReadCloser(r) // ok\n_ = io.Writer(r) // no\nvar rc io.Reader = XXX{}\n_ = io.ReaderCloser(rc) // no\n```\n\n### æ¥å£ç±»å‹æ–­è¨€\n\n**æ¥å£æ–­è¨€ï¼šæ ¹æ®æ¥å£å€¼çš„å®é™…ç±»å‹ï¼Œåˆ¤æ–­æ˜¯å¦å®ç°äº†ç›®æ ‡æ¥å£**\n\nç±»å‹æ–­è¨€æ—¶ï¼Œå¯èƒ½éœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆitab\n\n```go\n// æ¥å£æ–­è¨€\nfunc assertI2I(inter *interfacetype, i iface) (r iface) {\n   tab := i.tab\n   if tab == nil {\n      // explicit conversions require non-nil interface value.\n      panic(&TypeAssertionError{nil, nil, &inter.typ, \"\"})\n   }\n    \n   // å¦‚æœç›®æ ‡æ¥å£ç±»å‹å°±æ˜¯å½“å‰æ¥å£ç±»å‹ï¼Œç›´æ¥è¿”å›\n   if tab.inter == inter {\n      r.tab = tab\n      r.data = i.data\n      return\n   }\n   r.tab = getitab(inter, tab._type, false) // è·å–itabï¼Œå¦‚æœå¤±è´¥ç›´æ¥panic\n   r.data = i.data\n   return\n}\n\nfunc assertI2I2(inter *interfacetype, i iface) (r iface, b bool) {\n\ttab := i.tab\n\tif tab == nil {\n\t\treturn\n\t}\n\tif tab.inter != inter {\n\t\ttab = getitab(inter, tab._type, true) // trueè¡¨ç¤ºå®¹å¿å¤±è´¥\n\t\tif tab == nil { // ä¸ç¬¦åˆï¼Œè¿”å›false\n\t\t\treturn\n\t\t}\n\t}\n\tr.tab = tab\n\tr.data = i.data\n\tb = true\n\treturn\n}\n\nfunc getitab(inter *interfacetype, typ *_type, canfail bool) *itab {\n\tif len(inter.mhdr) == 0 {\n\t\tthrow(\"internal error - misuse of itab\")\n\t}\n\n\t// easy case\n\tif typ.tflag&tflagUncommon == 0 {\n\t\tif canfail {\n\t\t\treturn nil\n\t\t}\n\t\tname := inter.typ.nameOff(inter.mhdr[0].name)\n\t\tpanic(&TypeAssertionError{nil, typ, &inter.typ, name.name()})\n\t}\n\n\tvar m *itab\n\n\t// First, look in the existing table to see if we can find the itab we need.\n\t// This is by far the most common case, so do it without locks.\n\t// Use atomic to ensure we see any previous writes done by the thread\n\t// that updates the itabTable field (with atomic.Storep in itabAdd).\n    // å…ˆæŸ¥è¡¨æ˜¯å¦å·²ç»å­˜åœ¨éœ€è¦çš„itab\n\tt := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))\n\tif m = t.find(inter, typ); m != nil {\n\t\tgoto finish\n\t}\n\n\t// Not found.  Grab the lock and try again.\n\tlock(&itabLock)\n    // åŒé‡é”æ£€æŸ¥\n\tif m = itabTable.find(inter, typ); m != nil {\n\t\tunlock(&itabLock)\n\t\tgoto finish\n\t}\n\n\t// Entry doesn't exist yet. Make a new entry & add it.\n    // åˆ†é…itabå†…å­˜ï¼Œitabçš„å†…å­˜åˆ†é…åœ¨gcå †ä¹‹å¤–ï¼Œä¸ä¼šè¢«åƒåœ¾æ‰«æã€å›æ”¶\n\tm = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))\n\tm.inter = inter\n\tm._type = typ\n\tm.init() // åˆå§‹åŒ–\n\titabAdd(m) // æ·»åŠ åˆ°itabTableä¸­ï¼Œåç»­ç›´æ¥æŸ¥è¡¨ï¼Œä¸éœ€è¦é‡æ–°æ„é€ \n\tunlock(&itabLock)\nfinish:\n\tif m.fun[0] != 0 { // itabåˆå§‹åŒ–æˆåŠŸ\n\t\treturn m\n\t}\n\tif canfail {\n\t\treturn nil\n\t}\n\t// this can only happen if the conversion\n\t// was already done once using the , ok form\n\t// and we have a cached negative result.\n\t// The cached result doesn't record which\n\t// interface function was missing, so initialize\n\t// the itab again to get the missing function name.\n\tpanic(&TypeAssertionError{concrete: typ, asserted: &inter.typ, missingMethod: m.init()})\n}\n\n\n// init fills in the m.fun array with all the code pointers for\n// the m.inter/m._type pair. If the type does not implement the interface,\n// it sets m.fun[0] to 0 and returns the name of an interface function that is missing.\n// It is ok to call this multiple times on the same m, even concurrently.\nfunc (m *itab) init() string {\n\tinter := m.inter\n\ttyp := m._type\n\tx := typ.uncommon() \n\n\t// both inter and typ have method sorted by name,\n\t// and interface names are unique,\n\t// so can iterate over both in lock step;\n\t// the loop is O(ni+nt) not O(ni*nt).\n    // æ¥å£å’Œç±»å‹çš„æ–¹æ³•åˆ—è¡¨æ˜¯æŒ‰ç…§åå­—æ’åºçš„ï¼Œå› æ­¤å®é™…å¾ªç¯æ—¶é—´å¤æ‚åº¦æ˜¯O(ni+nt)\n\tni := len(inter.mhdr) // ç›®æ ‡æ¥å£æ–¹æ³•æ€»æ•°\n\tnt := int(x.mcount) // å®é™…ç±»å‹æ–¹æ³•æ€»æ•°\n    // è®¡ç®—å®é™…ç±»å‹çš„æ–¹æ³•å¼•ç”¨åˆ—è¡¨çš„åç§»\n\txmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]\n\tj := 0\nimethods:\n\tfor k := 0; k < ni; k++ {\n\t\ti := &inter.mhdr[k]\n\t\titype := inter.typ.typeOff(i.ityp) // ç›®æ ‡æ¥å£æ–¹æ³•ç±»å‹ï¼Œä¸å‚æ•°å’Œè¿”å›å€¼ç›¸å…³\n\t\tname := inter.typ.nameOff(i.name)  // ç›®æ ‡æ¥å£æ–¹æ³•å\n\t\tiname := name.name()\n\t\tipkg := name.pkgPath() // æ¥å£çš„åŒ…å\n\t\tif ipkg == \"\" {\n\t\t\tipkg = inter.pkgpath.name()\n\t\t}\n\t\tfor ; j < nt; j++ {\n\t\t\tt := &xmhdr[j]\n\t\t\ttname := typ.nameOff(t.name) \n            // å¦‚æœå®é™…æ–¹æ³•ç±»å‹å’Œæ–¹æ³•åä¸ç›®æ ‡æ–¹æ³•çš„ä¸€è‡´\n\t\t\tif typ.typeOff(t.mtyp) == itype && tname.name() == iname {\n\t\t\t\tpkgPath := tname.pkgPath()\n\t\t\t\tif pkgPath == \"\" {\n\t\t\t\t\tpkgPath = typ.nameOff(x.pkgpath).name()\n\t\t\t\t}\n                // å¦‚æœæ–¹æ³•æ˜¯å¯¼å‡ºçš„æˆ–è€…åŒ…åä¸€è‡´\n                // å¦‚æœæ¥å£æœ‰æœªå¯¼å‡ºæ–¹æ³•ï¼Œåªèƒ½åœ¨åŒä¸€ä¸ªåŒ…å†…è¢«å®ç°ï¼Œå¯ä»¥ç”¨æ¥é™åˆ¶å…¶ä»–åŒ…å®ç°è¯¥æ¥å£\n\t\t\t\tif tname.isExported() || pkgPath == ipkg {\n\t\t\t\t\tif m != nil {\n\t\t\t\t\t\tifn := typ.textOff(t.ifn) //å®é™…å‡½æ•°å…¥å£PC\n                        // ä¿å­˜åˆ°itabçš„æ–¹æ³•åˆ—è¡¨ä¸­\n\t\t\t\t\t\t*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn\n\t\t\t\t\t}\n\t\t\t\t\tcontinue imethods\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// didn't find method\n\t\tm.fun[0] = 0 // æ²¡æœ‰æ‰¾åˆ°æ–¹æ³•ï¼Œå³ç›®æ ‡ç±»å‹æ²¡æœ‰å®ç°è¯¥æ–¹æ³•\n\t\treturn iname\n\t}\n\tm.hash = typ.hash\n\treturn \"\"\n}\n```\n\n\n\n### å…¶ä»–\n\nå› ä¸ºgoä¸­çš„æ¥å£æ˜¯éšå¼å®ç°çš„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å£°æ˜ç±»å‹çš„æ—¶å€™ï¼Œä½¿ç”¨ä¸€äº›æ–­è¨€æ¥åŠ å…¥ç¼–è¯‘æ—¶çš„æ£€æŸ¥ï¼Œå¹¶ä¸”ä¹Ÿå¯ä»¥æç¤ºå…¶ä»–äººè¯¥ç±»å‹å®ç°äº†æŸä¸ªæ¥å£ï¼Œæ¯”å¦‚æˆ‘ä»¬å£°æ˜äº†ç±»å‹`T`å®ç°äº†æ¥å£`I`ï¼Œæˆ‘ä»¬å¯ä»¥ï¼š\n\n```go\ntype I interface{}\n\nvar _ I = new(T) // è¿™é‡Œæ–­è¨€Tå®ç°äº†æ¥å£I\ntype T struct{}\n\n```\n\n\n\n### å‚è€ƒ\n\n<https://github.com/teh-cmc/go-internals/tree/master/chapter2_interfaces>\n\n","tags":["go","interface"]},{"title":"iptableså…¥é—¨","url":"/2019/05/06/iptableså…¥é—¨/","content":"\n# iptables\n\n### Doc\n\n- [iptables tutorial](<https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html>)\n- `iptables -h`\n- `man iptables`\n\n### Tables & Chains\n\nè¡¨ç”±é“¾ç»„æˆï¼Œé“¾æ˜¯ä¸€äº›æŒ‰é¡ºåºæ’åˆ—çš„è§„åˆ™çš„åˆ—è¡¨ã€‚æ¯”å¦‚ï¼Œé»˜è®¤çš„ `filter` è¡¨åŒ…å« `INPUT`ï¼Œ `OUTPUT` å’Œ `FORWARD` 3æ¡å†…å»ºçš„é“¾ï¼Œè¿™3æ¡é“¾ä½œç”¨äºæ•°æ®åŒ…è¿‡æ»¤è¿‡ç¨‹ä¸­çš„ä¸åŒæ—¶é—´ç‚¹ã€‚\n\nå„ä¸ªè¡¨å’ŒåŒ…å«çš„é“¾å…³ç³»å¦‚ä¸‹ï¼š\n\n| table      | chain                                                        | desc                                                        |\n| ---------- | ------------------------------------------------------------ | ----------------------------------------------------------- |\n| `raw`      | `PREROUTING`ã€`OUTPUT`                                       | å…³é—­natè¡¨ä¸Šä½¿ç”¨çš„è¿æ¥è¿½è¸ªæœºåˆ¶ï¼›å†…æ ¸æ¨¡å—ï¼š`iptable_raw`      |\n| `filter`   | `INPUT`ã€`OUTPUT`ã€`FORWARD`                                 | è´Ÿè´£è¿‡æ»¤åŠŸèƒ½ï¼Œé˜²ç«å¢™ï¼›å†…æ ¸æ¨¡å—ï¼š`iptable_filter`            |\n| `nat`      | `PREROUTING`ã€ `POSTROUTING`ã€ `OUTPUT`ã€ `INPUT(éƒ¨åˆ†æ”¯æŒ)`  | ç½‘ç»œåœ°å€è½¬æ¢ï¼›å†…æ ¸æ¨¡å—ï¼š`iptable_nat`                       |\n| `mangle`   | `PREROUTING`ã€ `INPUT`ã€ `FORWARD`ã€ `OUTPUT `ã€`POSTROUTING` | æ‹†è§£ã€ä¿®æ”¹ã€é‡å°è£…æŠ¥æ–‡ï¼›å†…æ ¸æ¨¡å—ï¼š`iptable_mangle`          |\n| `security` |                                                              | ç”¨äºå¼ºåˆ¶[è®¿é—®æ§åˆ¶ç½‘ç»œ](http://lwn.net/Articles/267140/)è§„åˆ™ |\n\né»˜è®¤æƒ…å†µä¸‹ï¼Œä»»ä½•é“¾ä¸­éƒ½æ²¡æœ‰è§„åˆ™ã€‚å¯ä»¥å‘é“¾ä¸­æ·»åŠ è‡ªå·±æƒ³ç”¨çš„è§„åˆ™ã€‚é“¾çš„é»˜è®¤è§„åˆ™é€šå¸¸è®¾ç½®ä¸º `ACCEPT`ï¼Œå¦‚æœæƒ³ç¡®ä¿ä»»ä½•åŒ…éƒ½ä¸èƒ½é€šè¿‡è§„åˆ™é›†ï¼Œé‚£ä¹ˆå¯ä»¥é‡ç½®ä¸º `DROP`ã€‚é»˜è®¤çš„è§„åˆ™æ€»æ˜¯åœ¨ä¸€æ¡é“¾çš„æœ€åç”Ÿæ•ˆï¼Œæ‰€ä»¥åœ¨é»˜è®¤è§„åˆ™ç”Ÿæ•ˆå‰æ•°æ®åŒ…éœ€è¦é€šè¿‡æ‰€æœ‰å­˜åœ¨çš„è§„åˆ™ã€‚ç”¨æˆ·å¯ä»¥åŠ å…¥è‡ªå·±å®šä¹‰çš„é“¾ï¼Œä»è€Œä½¿è§„åˆ™é›†æ›´æ–¹ä¾¿ç®¡ç†ï¼Œè‡ªå®šä¹‰é“¾éœ€è¦è¢«å†…ç½®çš„é“¾å¼•ç”¨æ‰èƒ½ç”Ÿæ•ˆã€‚æ¯ä¸ªé“¾ä¸‹é¢å¯ä»¥è®¾ç½®ä¸€ç»„è§„åˆ™ï¼Œæ‰§è¡Œé“¾æ—¶å°±æ˜¯æ‰§è¡Œè¿™ç»„è§„åˆ™ã€‚\n\n\n\n### Traversing Chains\n\n\n\n![å›¾1](/img/iptables_traverse.jpg)\n\nä¸Šå›¾æè¿°é“¾äº†åœ¨ä»»ä½•æ¥å£ä¸Šæ”¶åˆ°çš„ç½‘ç»œæ•°æ®åŒ…æ˜¯æŒ‰ç…§æ€æ ·çš„é¡ºåºç©¿è¿‡è¡¨çš„äº¤é€šç®¡åˆ¶é“¾ã€‚ç¬¬ä¸€ä¸ªè·¯ç”±ç­–ç•¥åŒ…æ‹¬å†³å®šæ•°æ®åŒ…çš„ç›®çš„åœ°æ˜¯æœ¬åœ°ä¸»æœºï¼ˆè¿™ç§æƒ…å†µä¸‹ï¼Œæ•°æ®åŒ…ç©¿è¿‡ `INPUT` é“¾ï¼‰ï¼Œè¿˜æ˜¯å…¶ä»–ä¸»æœºï¼ˆæ•°æ®åŒ…ç©¿è¿‡ `FORWARD` é“¾ï¼‰ï¼›ä¸­é—´çš„è·¯ç”±ç­–ç•¥åŒ…æ‹¬å†³å®šç»™ä¼ å‡ºçš„æ•°æ®åŒ…ä½¿ç”¨é‚£ä¸ªæºåœ°å€ã€åˆ†é…å“ªä¸ªæ¥å£ï¼›æœ€åä¸€ä¸ªè·¯ç”±ç­–ç•¥å­˜åœ¨æ˜¯å› ä¸ºå…ˆå‰çš„` mangle` ä¸ `nat` é“¾å¯èƒ½ä¼šæ”¹å˜æ•°æ®åŒ…çš„è·¯ç”±ä¿¡æ¯ã€‚æ•°æ®åŒ…é€šè¿‡è·¯å¾„ä¸Šçš„æ¯ä¸€æ¡é“¾æ—¶ï¼Œé“¾ä¸­çš„æ¯ä¸€æ¡è§„åˆ™æŒ‰é¡ºåºåŒ¹é…ï¼›æ— è®ºä½•æ—¶åŒ¹é…äº†ä¸€æ¡è§„åˆ™ï¼Œç›¸åº”çš„` target` åŠ¨ä½œå°†ä¼šæ‰§è¡Œã€‚å†…ç½®çš„é“¾æœ‰é»˜è®¤çš„ç­–ç•¥ï¼Œä½†æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„é“¾æ²¡æœ‰é»˜è®¤çš„ç­–ç•¥ã€‚åœ¨` jump` åˆ°çš„è‡ªå®šä¹‰é“¾ä¸­ï¼Œè‹¥æ¯ä¸€æ¡è§„åˆ™éƒ½ä¸èƒ½æä¾›å®Œå…¨åŒ¹é…ï¼Œé‚£ä¹ˆæ•°æ®åŒ…åƒä¸‹å›¾æè¿°çš„ä¸€æ ·è¿”å›åˆ°è°ƒç”¨é“¾ã€‚åœ¨ä»»ä½•æ—¶å€™ï¼Œè‹¥ `DROP` çš„è§„åˆ™å®ç°å®Œå…¨åŒ¹é…ï¼Œé‚£ä¹ˆè¢«åŒ¹é…çš„æ•°æ®åŒ…ä¼šè¢«ä¸¢å¼ƒï¼Œä¸ä¼šè¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ã€‚å¦‚æœä¸€ä¸ªæ•°æ®åŒ…åœ¨é“¾ä¸­è¢« `ACCEPT`ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ…å°±ä¼šè¢«`ACCEPT`ï¼Œä¸ä¼šå†éå†åé¢çš„è§„åˆ™ã€‚\n\nç„¶è€Œï¼Œè¦æ³¨æ„çš„æ˜¯ï¼Œæ•°æ®åŒ…è¿˜ä¼šä»¥æ­£å¸¸çš„æ–¹å¼ç»§ç»­éå†å…¶ä»–è¡¨ä¸­çš„å…¶ä»–é“¾ã€‚\n\n![å›¾2](/img/iptable_subtraverse.jpg)\n\n\n\n### Command\n\n```sh\n$ iptables -t è¡¨å <-A/I/D/R> è§„åˆ™é“¾å [è§„åˆ™å·] <-i/o ç½‘å¡å> -p åè®®å <-s æºIP/æºå­ç½‘> --sport æºç«¯å£ <-d ç›®æ ‡IP/ç›®æ ‡å­ç½‘> --dport ç›®æ ‡ç«¯å£ -j åŠ¨ä½œ\n```\n\n###### è§„åˆ™ç®¡ç†å‘½ä»¤\n\n- `-A` or `--append` ï¼šå°†è§„åˆ™åŠ åˆ°`chain`æœ«å°¾\n\n  ```sh\n  $ iptables -t filter -A INPUT -i lo -j DROP #åœ¨INPUTé“¾æœ«å°¾æ·»åŠ è§„åˆ™ï¼Œæ‹’ç»æ‰æ¥è‡ªloç½‘å¡çš„åŒ…\n  ```\n\n- `-I` or `--insert` ï¼šåœ¨æŒ‡å®šä½ç½®æ·»åŠ è§„åˆ™ï¼ŒåŸæ¥ä½ç½®çš„è§„åˆ™åç§»\n\n  ```sh\n  $ iptables -t filter -I INPUT 1 -i lo -j DROP #åœ¨INPUTé“¾å¤´éƒ¨æ·»åŠ è§„åˆ™ï¼Œæ’å…¥ä½ç½®ä»1å¼€å§‹è®¡ç®—\n  ```\n\n- `-R` or `--replace` ï¼šæ›¿æ¢æŒ‡å®šä½ç½®è§„åˆ™\n\n  ```sh\n  $ iptables -t filter -R INPUT 1 -i lo -j ACCEPT #ä¿®æ”¹INPUTé“¾å¤´éƒ¨è§„åˆ™\n  ```\n\n- `-D` or `--delete`ï¼šåˆ é™¤æŒ‡å®šä½ç½®è§„åˆ™\n\n  ```sh\n  $ iptables -t filter -D INPUT 2 #åˆ é™¤INPUTé“¾ç¬¬äºŒæ¡è§„åˆ™\n  ```\n\n###### é“¾ç®¡ç†å‘½ä»¤\n\n- `-P` or `--policy`ï¼šæ”¹å˜æŒ‡å®šé“¾çš„é»˜è®¤ç­–ç•¥ï¼Œåªæœ‰å†…ç½®çš„é“¾æ‰æœ‰é»˜è®¤ç­–ç•¥ï¼Œè‡ªå®šä¹‰é“¾æ²¡æœ‰é»˜è®¤ç­–ç•¥\n\n  ```sh\n  $ iptables -P INPUT ACCEPT\n  ```\n\n- `-F` or `--flush` ï¼šæ¸…ç©ºè§„åˆ™é“¾çš„æ‰€æœ‰è§„åˆ™ï¼Œå¦‚æœçœç•¥è§„åˆ™é“¾ï¼Œåˆ™æ¸…ç©ºè¡¨ä¸Šæ‰€æœ‰é“¾çš„è§„åˆ™\n\n- `-N` or `--new`ï¼šåˆ›å»ºè‡ªå®šä¹‰é“¾\n\n- `-X` or `--delete-chain`ï¼šåˆ é™¤æŒ‡å®šçš„é“¾ï¼Œè¿™ä¸ªé“¾å¿…é¡»æ²¡æœ‰è¢«å…¶å®ƒä»»ä½•è§„åˆ™å¼•ç”¨ï¼Œè€Œä¸”è¿™æ¡ä¸Šå¿…é¡»æ²¡æœ‰ä»»ä½•è§„åˆ™ã€‚å¦‚æœæ²¡æœ‰æŒ‡å®šé“¾åï¼Œåˆ™ä¼šåˆ é™¤è¯¥è¡¨ä¸­æ‰€æœ‰éå†…ç½®çš„é“¾ã€‚\n\n- `-E` or `--rename-chain`ï¼šç”¨æŒ‡å®šçš„æ–°åå­—å»é‡å‘½åæŒ‡å®šçš„é“¾ã€‚è¿™å¹¶ä¸ä¼šå¯¹é“¾å†…éƒ¨ç…§æˆä»»ä½•å½±å“ã€‚\n\n  ```sh\n  $ iptables -E oldName newName\n  ```\n\n- `-Z` or `--zero`ï¼šæŠŠæŒ‡å®šé“¾ï¼Œæˆ–è€…è¡¨ä¸­çš„æ‰€æœ‰é“¾ä¸Šçš„æ‰€æœ‰è®¡æ•°å™¨æ¸…é›¶ï¼Œè®¡æ•°å™¨æ˜¯è§„åˆ™å‘½ä¸­è®¡æ•°ã€‚\n\n- `-L` or `--list`ï¼šæŸ¥çœ‹æŒ‡å®šé“¾æˆ–è€…æŒ‡å®šè¡¨ä¸Šçš„æ‰€æœ‰è§„åˆ™\n\n###### è§„åˆ™å‚æ•°\n\n- `-t` or `--table`ï¼šæŒ‡å®šæ“ä½œçš„è¡¨ï¼Œ**å¦‚æœä¸æŒ‡å®šæ­¤é€‰é¡¹ï¼Œé»˜è®¤æ“ä½œçš„æ˜¯ `filter` è¡¨**\n\n- `-p` or `--protocol`ï¼šæŒ‡å®šåè®®\n\n- `-i` or `--in-interface`ï¼šnetwork interface nameï¼ŒåŒ¹é…æµé‡æµå…¥çš„ç½‘ç»œæ¥å£ï¼Œåªå¯¹`PREROUTING`ã€`INPUT`æˆ–è€…`FORWARD`ç”Ÿæ•ˆï¼›è¿™é‡Œçš„ç½‘ç»œæ¥å£ä¸ä¸€å®šæ˜¯ç½‘å¡ï¼Œæ¯”å¦‚`docker0`ç­‰è™šæ‹Ÿç½‘æ¡¥ä¹Ÿå¯ä»¥ï¼›å‰ç¼€`!`è¡¨ç¤ºéï¼Œæ¯”å¦‚`! -i 127.0.0.1`è¡¨ç¤ºéæœ¬æœºå‘é€è¿‡æ¥çš„æ•°æ®åŒ…ã€‚\n\n- `-o` or `--out-interface`ï¼šnetwork interface nameï¼ŒåŒ¹é…æµé‡è¾“å‡ºçš„ç½‘ç»œæ¥å£ï¼Œåªå¯¹`OUTPUT`ã€`FORWARD`æˆ–`POSTROUTING`ç”Ÿæ•ˆ\n\n- `-s` or `--source`ï¼šæºåœ°å€ï¼Œ`ip`åœ°å€æˆ–è€…`CIDR`è¡¨ç¤ºæŒ‡å®šèŒƒå›´åœ°å€\n\n- `--sport `ï¼šåŒ¹é…æ¥æºç«¯å£\n\n- `-d` or `--destination`ï¼šç›®æ ‡åœ°å€ï¼Œ`ip`åœ°å€æˆ–è€…`CIDR`è¡¨ç¤ºæŒ‡å®šèŒƒå›´åœ°å€\n\n- `--dport`ï¼šåŒ¹é…ç›®æ ‡ç«¯å£\n\n- `-j` or `--jump`ï¼šè§„åˆ™ç›®æ ‡ï¼Œå³æ»¡è¶³è§„åˆ™æ—¶åº”è¯¥æ‰§è¡Œä»€ä¹ˆæ ·çš„åŠ¨ä½œã€‚ç›®æ ‡å¯ä»¥æ˜¯å†…ç½®ç›®æ ‡ï¼Œä¹Ÿå¯ä»¥æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„é“¾ï¼Œå†…ç½®çš„ç›®æ ‡æœ‰ï¼š\n\n  - `ACCEPT`ï¼šæ¥æ”¶æ•°æ®åŒ…ï¼Œå¦‚æœå½“å‰è§„åˆ™åŒ¹é…æˆåŠŸåˆ™ç»“æŸå½“å‰é“¾åŠçˆ¶é“¾ï¼ˆå¦‚æœå½“å‰æ˜¯è‡ªå®šä¹‰å­é“¾ï¼‰\n  - `DROP`ï¼šä¸¢å¼ƒæ•°æ®åŒ…ï¼Œä¸åšä»»ä½•å“åº”ã€‚\n  - `REJECT`ï¼šæ‹’ç»å½“å‰åŒ…ï¼Œä¼šè¿”å›æ‹’ç»æ•°æ®åŒ…ã€‚\n  - `REDIRECT`ï¼šé‡å®šå‘ã€æ˜ å°„ã€é€æ˜ä»£ç†ã€‚\n  - `SNAT`ï¼šæºåœ°å€è½¬æ¢ã€‚\n  - `DNAT`ï¼šç›®æ ‡åœ°å€è½¬æ¢ã€‚\n  - `MASQUERADE`ï¼š`IP`ä¼ªè£…ï¼ˆ`NAT`ï¼‰ï¼Œç”¨äº`ADSL`ã€‚\n  - `LOG`ï¼šæ—¥å¿—è®°å½•ï¼Œç»§ç»­åŒ¹é…ä¸‹ä¸€ä¸ªè§„åˆ™ï¼Œä¸ä¼šç»“æŸå½“å‰é“¾ã€‚\n\n- `-m` or `--match`ï¼šä½¿ç”¨æ‰©å±•åŒ…åŒ¹é…æ¨¡å—ï¼Œå¯ä»¥ä½¿ç”¨`man iptables-extensions`å‘½ä»¤æŸ¥çœ‹æ‰©å±•æ¨¡å—\n\n  > iptables can use extended packet matching modules. **These are loaded in two ways: implicitly, when -p or --protocol is specified, or with the -m or --match options, followed by the matching module name**; after these, various extra command line options become available, depending on the specific module. You can specify multiple extended match modules in one line, and you can use the -h or --help options after the module has been specified to receive help specific to that module.\n\n  - `statistic`ï¼šåŸºäºä¸€äº›ç»Ÿè®¡æ¡ä»¶åŒ¹é…\n\n    ```sh\n    $ iptables -A INPUT -m statistic --mode random --probability 0.5 -s 127.0.0.1 -p icmp -j DROP # æ¥è‡ªæœ¬æœºçš„pingåŒ…ï¼Œæœ‰50%çš„å‡ ç‡è¢«ä¸¢å¼ƒ\n    ```\n\n  - `comment`ï¼šå…è®¸æ·»åŠ æ³¨é‡Šï¼ˆæœ€å¤š256ç»™å­—ç¬¦ï¼‰\n\n    ```sh\n    $ iptables -A INPUT -m comment --comment \"a comment demo\" -j ACCEPT\n    ```\n\n\n\n### DNAT & SNAT\n\n##### SNAT\n\n`SNAT`: Source Network Address Translationï¼Œä¿®æ”¹ç½‘ç»œåŒ…æºipåœ°å€ã€‚\n\næ¯”å¦‚å†…ç½‘æœºå™¨åªæœ‰ç§æœ‰ipï¼Œæ— æ³•æ­£å¸¸è®¿é—®å¤–ç½‘ï¼Œå¯ä»¥åœ¨ç½‘å…³è¿›è¡ŒSNATï¼Œå°†ipåŒ…çš„æºåœ°å€æ›¿æ¢ä¸ºç½‘å…³çš„å…¬ç½‘ipï¼Œç­‰è¯·æ±‚è¿”å›çš„æ—¶å€™ï¼Œç½‘å…³å†æŠŠè¿”å›çš„ipåŒ…çš„ç›®æ ‡åœ°å€è¿˜åŸä¸ºåŸæ¥çš„å†…ç½‘ipï¼Œç„¶åç”±ç½‘å…³è½¬å‘ç»™å…·ä½“çš„æœºå™¨ã€‚\n\n`SNAT`æ˜¯å¤šå¯¹ä¸€çš„æ˜ å°„ï¼Œæ¯”å¦‚å¤šä¸ªå†…ç½‘æœºå™¨åŒæ—¶æ˜ å°„åŒä¸€ä¸ªç½‘å…³çš„å…¬ç½‘ipï¼Œä¸åŒå†…ç½‘æœºå™¨å¯èƒ½ä½¿ç”¨åŒä¸€ä¸ªæºç«¯å£ï¼Œç³»ç»Ÿæ˜¯é€šè¿‡æºIPï¼Œæºç«¯å£ï¼Œç›®æ ‡ipå’Œç›®æ ‡ç«¯å£å’Œåè®®ç­‰5å…ƒç»„æ¥åŒºåˆ†ä¸åŒçš„è¿æ¥çš„ï¼Œå› æ­¤æ‰§è¡Œ`SNAT`æ—¶ï¼Œé™¤äº†ä¿®æ”¹æºipï¼Œè¿˜éœ€è¦é‡æ–°åˆ†é…æºç«¯å£å·ã€‚\n\nç³»ç»Ÿéœ€è¦é€šè¿‡`SNAT`è¡¨æ¥ä¿å­˜åŸæ¥çš„ip/ç«¯å£ä¸è½¬æ¢åçš„ip/ç«¯å£ä¹‹é—´çš„æ˜ å°„å…³ç³»ï¼Œä»¥ä¾¿èƒ½å¤Ÿåœ¨æ•°æ®æµå…¥æµå‡ºæ—¶è¿›è¡Œè·Ÿè¸ªã€‚\n\nåœ¨å®¹å™¨ç½‘ç»œä¸­ï¼Œå½“å®¹å™¨å†…éƒ¨ä¸»åŠ¨å‘å¤–éƒ¨å‘èµ·ç½‘ç»œè¯·æ±‚æ—¶ï¼Œéœ€è¦ä½¿ç”¨`SNAT`å°†å®¹å™¨ipæ›¿æ¢æˆä¸»æœºçš„ipã€‚\n\n##### DNAT\n\n`DNAT`ç”¨äºå°†å†…ç½‘æœºå™¨çš„ç«¯å£æ˜ å°„åˆ°å¤–ç½‘ã€‚å½“ç½‘å…³æ¥æ”¶åˆ°æ•°æ®åŒ…æ—¶ï¼Œé€šè¿‡DNATå°†ç›®æ ‡ipå’Œç«¯å£æ›¿æ¢æˆå†…ç½‘æœºå™¨çš„ipå’Œç«¯å£ï¼Œç„¶åè¿›è¡Œè½¬å‘ã€‚\n\nåœ¨å®¹å™¨ç½‘ç»œä¸­ï¼Œå®¹å™¨çš„ç«¯å£æ˜ å°„å°±æ˜¯ä½¿ç”¨`DNAT`å®ç°çš„ã€‚é€šè¿‡å°†å®¹å™¨çš„ç«¯å£æ˜ å°„åˆ°ä¸»æœºç«¯å£ä¸Šï¼Œå½“ç”±æ•°æ®åŒ…å‘é€åˆ°è¯¥ä¸»æœºç«¯å£æ—¶ï¼Œ`netfilter`ä¼šå°†å…¶æ›¿æ¢æˆå®¹å™¨çš„ipå’Œç«¯å£ã€‚","tags":["linux","iptables"]},{"title":"rsçº åˆ ç ","url":"/2019/05/06/rsçº åˆ ç /","content":"\n# RSçº åˆ ç \n\nåœ¨å­˜å‚¨ç³»ç»Ÿä¸­ï¼Œéœ€è¦é‡‡ç”¨æ•°æ®å†—ä½™æŠ€æœ¯æ¥ä¿è¯æ•°æ®çš„å¯é æ€§ï¼Œç›¸æ¯”ä½¿ç”¨å¤šå‰¯æœ¬å¤åˆ¶æœºåˆ¶å¤–ï¼Œä½¿ç”¨çº åˆ ç èƒ½å¤Ÿä»¥æ›´å°çš„æ•°æ®å†—ä½™åº¦è·å¾—æ›´é«˜çš„æ•°æ®å¯é æ€§ã€‚`Reed Solomon Coding`æ˜¯å­˜å‚¨é¢†åŸŸå¸¸ç”¨çš„ä¸€ç§çº åˆ ç ã€‚\n\n### åŸºæœ¬åŸç†\n\nRSçº åˆ ç å°†åŸå§‹æ–‡ä»¶åˆ†æˆnä¸ªæ•°æ®å—ï¼ŒåŒæ—¶ä¸ºè¿™**nä¸ªæ•°æ®å—**ç”Ÿæˆ**mä¸ªæ ¡éªŒå—**ï¼Œè€Œèƒ½å¤Ÿå®¹å¿æœ€å¤šä¸¢å¤±ï¼ˆåªä¿è¯ä¸¢å¤±è€Œä¸ä¿è¯æ•°æ®ç¯¡æ”¹ï¼‰è¿™ï¼ˆn+m)ä¸ªå—ä¸­çš„ä»»æ„mä¸ªæ•°æ®æˆ–è€…æ ¡éªŒå—ã€‚\n\nRSç¼–ç ä»¥wordä¸ºå•ä½è¿›è¡Œç¼–ç å’Œè§£ç ï¼ˆwordå­—é•¿ä¸€èˆ¬ä¸º8æˆ–è€…16ï¼‰ï¼Œè€Œå¤§çš„æ•°æ®å—æ‹†åˆ†æˆä¸€ä¸ªä¸ªwordè¿›è¡Œç¼–è§£ç ã€‚\n\nå‡å¦‚æœ‰æ•°æ®å—å†…å®¹ä¸º`ABCDEFGHIJKLMNOP`ï¼Œå°†å…¶åˆ†ä¸ºå››ä¸ªæ•°æ®å—ï¼Œæ¯ä¸ªæ•°æ®å—åŒ…å«å››ä¸ªwordï¼ˆå­—é•¿ä¸º8ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨çŸ©é˜µæ¥è¡¨ç¤ºè¿™å››ä¸ªæ•°æ®å—ï¼Œå¯¹åº”çš„æ•°æ®çŸ©é˜µå¦‚ä¸‹ï¼š\n\n![](/img/blog-rs-1.png)\n\næ¥ç€ä½¿ç”¨ç¼–ç çŸ©é˜µæ¥å¯¹æ•°æ®çŸ©é˜µè¿›è¡Œç¼–ç ï¼Œäº§ç”Ÿæ•°æ®å—å’Œæ ¡éªŒå—ï¼š\n\n![](/img/blog-rs-2.webp)\n\nä¸Šå›¾å·¦è¾¹çš„çŸ©é˜µä¸ºç¼–ç çŸ©é˜µï¼Œè¯¥çŸ©é˜µç”±ä¸Šé¢ä¸€ä¸ª`4X4`çš„å•ä½çŸ©é˜µå’Œä¸‹é¢ä¸€ä¸ª`2X4`çš„`Vandermonder`çŸ©é˜µç»„æˆã€‚è¿™é‡Œçš„`2`å¯¹åº”ä¸Šé¢çš„`m`ï¼Œè¡¨æ˜éœ€è¦ç”Ÿæˆ2ä¸ªæ ¡éªŒå—ï¼Œ`4`æ˜¯å› ä¸ºåŸæ•°æ®åˆ†æˆäº†4ä¸ªæ•°æ®å—ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å³è¾¹ç»è¿‡ç¼–ç çŸ©é˜µå¤„ç†åçš„ç»“æœï¼Œæ¯”åŸæ¥çš„æ•°æ®çŸ©é˜µå¤šäº†ä¸¤è¡Œï¼Œå³å¯¹åº”ä¸¤ä¸ªæ ¡éªŒå—ã€‚\n\nå› ä¸º`m`å–çš„æ˜¯2ï¼Œå› æ­¤æœ€å¤šå…è®¸ä¸¢å¤±2ä¸ªå—ï¼Œè¿™é‡Œæˆ‘ä»¬å‡è®¾`IJKL`å’Œ`MNOP`ä¸¤ä¸ªå—è¢«ä¸¢å¤±äº†ï¼š\n\n![](/img/blog-rs-3.webp)\n\næˆ‘ä»¬åœ¨ç¼–ç çŸ©é˜µå’Œç»“æœçŸ©é˜µå°†å¯¹åº”çš„ç¬¬3ï¼Œ4è¡Œåˆ é™¤ï¼Œç­‰å¼ä¸¤è¾¹ä»ç„¶æˆç«‹ï¼š\n\n![](/img/RS-post-pic-4.png)\n\nç°åœ¨çš„ç¼–ç çŸ©é˜µæ˜¯åŸæ¥çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å…¶è®°ä¸º`C1`ï¼Œæ¥ç€æˆ‘ä»¬åˆ†åˆ«åœ¨ä¸¤è¾¹ä¹˜ä»¥ç¼–ç çŸ©é˜µçš„é€†çŸ©é˜µï¼š\n\n![](/img/RS-post-pic-5.png)\n\n![](/img/RS-post-pic-5-5.webp)\n\n![](/img/blog-rs-7.png)\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥ä»ç¼–ç äº§ç”Ÿçš„6ä¸ªå—ä¸­çš„ä»»æ„4ä¸ªå—ä¸­æ¢å¤åŸæ•°æ®ã€‚\n\n### VandermonderçŸ©é˜µ\n\n![](/img/Vandermonder.svg)\n\nåœ¨ä¸Šé¢ä¸­ï¼Œä¸ºäº†æ¢å¤åŸæ•°æ®ï¼Œéœ€è¦è®¡ç®—ç¼–ç çŸ©é˜µï¼ˆè¿™é‡ŒæŒ‡çš„æ˜¯`C1`ï¼‰çš„é€†çŸ©é˜µï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¸Šé¢ç¼–ç çŸ©é˜µæ˜¯ç”±ä¸€ä¸ªå•ä½çŸ©é˜µå’Œä¸€ä¸ª`Vandermonder`çŸ©é˜µç»„æˆçš„ï¼Œå› ä¸º`Vandermonder`çŸ©é˜µä»»æ„ä¸¤è¡Œä¹‹é—´éƒ½çº¿æ€§æ— å…³ï¼Œå¯ä»¥æ±‚è§£å‡ºé€†çŸ©é˜µã€‚\n\n### ä¼½ç½—ååŸŸ\n\nRSçº åˆ ç æ˜¯æŒ‰ç…§wordä¸ºå•ä½å¯¹æ•°æ®è¿›è¡Œç¼–è§£ç ï¼Œè¿™ä¹Ÿå°±è¦æ±‚å¯¹ä¸€ä¸ªå­—è¿›è¡Œç¼–ç åï¼Œäº§ç”Ÿçš„ç»“æœä»ç„¶æ˜¯ä¸€ä¸ªå­—ï¼Œå› æ­¤RSçº åˆ ç åŸºäºä¼½ç½—ååŸŸ[GF(2^n)](<http://mcll.top/2019/05/05/%E6%9C%89%E9%99%90%E5%9F%9F/>)åŠå…¶å››åˆ™è¿ç®—æ¥è¿›è¡Œç¼–è§£ç ã€‚\n\n### ä¸¾ä¸ªæ —å­\n\nè¿™é‡Œä½¿ç”¨`GF(2^4)`ï¼Œå¹¶ä¸”å–`n`å’Œ`m`éƒ½ä¸º3æ¥ä¸¾ä¸ªä¾‹å­ã€‚\n\né¦–å…ˆï¼Œ`GF(2^4)`å…±æœ‰0~15è¿™16ä¸ªå…ƒç´ ï¼Œé¦–å…ˆæ„é€ `exp`è¡¨å’Œ`log`è¡¨ï¼š\n\n| i    | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| log  | -    | 0    | 1    | 4    | 2    | 8    | 5    | 10   | 3    | 14   | 9    | 7    | 6    | 13   | 11   | 12   |\n| exp  | 1    | 2    | 4    | 8    | 3    | 6    | 12   | 11   | 5    | 10   | 7    | 14   | 15   | 13   | 9    | 1    |\n\nå‡è®¾åŸå§‹æ•°æ® D, Vandermonde çŸ©é˜µ F, å†—ä½™æ•°æ® Cï¼Œåˆ™ï¼š\n\n![](/img/blog-rs-demo1.png)\n\nä¸Šé¢è®¡ç®—çŸ©é˜µFæ—¶ï¼Œæ ¹æ®`GF(2^4)`çš„è®¡ç®—è§„åˆ™ï¼Œ3^2^ = 3*3 = exp(log(3)+log(3)) = 5\n\nå°†çŸ©é˜µFä¸3*3çš„å•ä½çŸ©é˜µEé›†åˆï¼Œå¯å¾—ï¼š\n\n![](/img/blog-rs-demo2.png)\n\næ ¹æ®ä¸Šé¢çš„å®šä¹‰ï¼Œä»»æ„ä¸¢å¤±3ä»½æ•°æ®ï¼Œéƒ½å¯ä»¥æ¢å¤åŸæ¥çš„æ•°æ®ï¼Œè¿™é‡Œå‡è®¾ä¸¢å¤±äº†D2ï¼ŒD3å’ŒC3ï¼Œåˆ™æ¢å¤è¿‡ç¨‹ï¼š\n\n![](/img/blog-rs-demo3.png)\n\nå¯ä»¥çœ‹åˆ°ï¼ŒæˆåŠŸæ¢å¤åŸæ¥çš„æ•°æ®ã€‚\n\n\n\n\n### å‚è€ƒ\n\n- [RSçº åˆ ç®—æ³•åŸç†](<https://github.com/RobinLiew/RobinLiew.github.io/blob/master/%E7%AE%97%E6%B3%95/RS%E7%BA%A0%E5%88%A0%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81.md>)\n- [Reed-Solomon ç¼–ç ç®—æ³•](<https://www.gaccob.com/publish/2017-08-27-reed-solomon.html>)\n- [reed-solomon](<https://www.backblaze.com/blog/reed-solomon/>)","tags":["rsçº åˆ ç "]},{"title":"æœ‰é™åŸŸ","url":"/2019/05/05/æœ‰é™åŸŸ/","content":"\n# Finite fields - æœ‰é™åŸŸ\n\næœ‰é™åŸŸï¼ˆ`Finite fields`ï¼‰æ˜¯ä»£æ•°çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œåœ¨åŠ å¯†ç®—æ³•ã€æ•°æ®å‹ç¼©ç®—æ³•å’Œçº é”™ç®—æ³•ä¸­éƒ½æœ‰é‡è¦çš„ä½œç”¨ã€‚\n\n### æ¦‚å¿µ\n\n##### åŸŸ - *field*\n\nå¦‚æœé›†åˆ`F`çš„æ‰€æœ‰å…ƒç´ ä¸å®šä¹‰åœ¨å…¶ä¸Šçš„äºŒå…ƒæ“ä½œç¬¦`+`å’Œ` Â· `æ»¡è¶³ä¸‹é¢æ¡ä»¶ï¼Œå³æ„æˆä¸€ä¸ªåŸŸï¼š\n\n- é—­åŒ…ï¼ˆ`Closure`ï¼‰ï¼š å¯¹äºä»»æ„`F`ä¸­çš„å…ƒç´ `x`å’Œ`y`ï¼Œ`x+y`å’Œ`xÂ·y`ä¹Ÿéƒ½æ˜¯`F`ä¸­çš„å…ƒç´ \n- ç»“åˆå¾‹ï¼ˆ`Associative`)ï¼šå¯¹äº`F`ä¸­çš„ä»»æ„`x`ï¼Œ`y`å’Œ`z`ï¼Œæ»¡è¶³`(x+y)+z = x+(y+z)`å’Œ`(xÂ·y)Â·z = xÂ·(yÂ·z)`\n- äº¤æ¢å¾‹ï¼ˆ`Commutative`ï¼‰ï¼šå¯¹äº`F`ä¸­çš„ä»»æ„å…ƒç´ `x`å’Œ`y`ï¼Œæ»¡è¶³`x+y = y+x`å’Œ`xÂ·y = yÂ·x`\n- åˆ†é…ç‡ï¼ˆ`Distributive`ï¼‰ï¼šå¯¹äº`F`ä¸­çš„ä»»æ„å…ƒç´ `x`ï¼Œ`y`å’Œ`z`ï¼Œæ»¡è¶³`xÂ·(y+z) = (xÂ·y)+(xÂ·z)`\n- `Identity`ï¼š`F`ä¸­å­˜åœ¨åŠ æ³•å•ä½å…ƒï¼Œè®°ä½œ`0`ï¼Œå¯¹`F`ä¸­çš„ä»»æ„å…ƒç´ `x`æ»¡è¶³`x+0 = x`ï¼›å­˜åœ¨ä¹˜æ³•å•ä½å…ƒï¼Œè®°ä½œ`1`ï¼Œå¯¹`F`ä¸­çš„ä»»æ„å…ƒç´ `x`æ»¡è¶³`xÂ·1 = x`\n- `Inverse`ï¼šå¯¹`F`ä¸­çš„ä»»æ„å…ƒç´ `x`ï¼Œåœ¨`F`ä¸­éƒ½èƒ½æ‰¾åˆ°å¯¹åº”çš„`y`æ»¡è¶³`x+y = 0`ï¼Œå³`y = -x`ï¼Œ`x`ä¸`y`äº’ä¸ºè´Ÿå…ƒï¼›å¯¹äº`F`ä¸­é™¤`0`å¤–çš„ä»»æ„å…ƒç´ `x`ï¼Œåœ¨`F`ä¸­éƒ½èƒ½æ‰¾åˆ°å¯¹åº”çš„`y`æ»¡è¶³`xÂ·y = 1`ï¼Œå³`y = 1/x`ï¼Œ`x`ä¸`y`äº’ä¸ºé€†å…ƒ\n\næ¯”å¦‚ï¼Œå®æ•°é›†`R`ä¸å®šä¹‰åœ¨å…¶ä¸Šçš„åŠ æ³•å’Œä¹˜æ³•è¿ç®—ï¼Œå°±æ„æˆäº†ä¸€ä¸ªåŸŸã€‚\n\nä½†æ˜¯æ•´æ•°é›†`Z`ä¸æ˜¯ä¸€ä¸ªåŸŸï¼Œå› ä¸º`Z`ä¸­çš„éé›¶å…ƒç´ å¹¶ä¸éƒ½æœ‰ä¹˜æ³•é€†å…ƒï¼Œæ¯”å¦‚`1/2`ä¸åœ¨`Z`ä¸­ã€‚\n\nè™½ç„¶`Z`ä¸æ˜¯ä¸€ä¸ªåŸŸï¼Œä½†æ˜¯**æ•´æ•°æ¨¡ä¸Šä»»æ„ä¸€ä¸ªç´ æ•°çš„é›†åˆå¯ä»¥æ„æˆä¸€ä¸ªåŸŸ**ã€‚æ¯”å¦‚`mod 5`çš„é›†åˆæ˜¯`{0, 1, 2, 3, 4}`ï¼Œè®°ä¸º`Z/5`ï¼Œå¯¹åº”çš„`+`è¿ç®—ä¸º`(x+y)%5`ï¼Œ`Â·`ä¸º`(xÂ·y)%5`ï¼Œè¿™æ—¶å€™åŠ æ³•å•ä½å…ƒæ˜¯`0`ï¼Œä¹˜æ³•å•ä½å…ƒæ˜¯`1`ï¼Œå¯ä»¥å‘ç°ï¼Œ`(2*3)%5 = 1`ï¼Œæ‰€ä»¥`2`çš„ä¹˜æ³•é€†å…ƒä¸º`3`\n\n**å¯¹äºä»»æ„ä¸€ä¸ªç´ æ•°`p`ï¼Œ`Z/p`æ˜¯ä¸€ä¸ªåŸŸï¼Œ`+`è¿ç®—ä¸º`(x+y) % p`ï¼Œ`Â·`è¿ç®—ä¸º`(xÂ·y) %p`**\n\n##### æœ‰é™åŸŸ - *finite field*\n\nå¦‚æœä¸€ä¸ªåŸŸçš„å…ƒç´ ä¸ªæ•°æ˜¯æœ‰é™çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªåŸŸç§°ä¸ºæœ‰é™åŸŸã€‚\n\nä½œä¸ºä¸€ä¸ªç¨‹åºå‘˜ï¼Œæˆ‘ä»¬æ¥è§¦åˆ°æœ€å¤šçš„æœ‰é™åŸŸæ˜¯`Z/2`ï¼ŒåªåŒ…å«`0`å’Œ`1`ä¸¤ä¸ªå…ƒç´ ã€‚`+`è¿ç®—å³ä¸º`XOR`ï¼Œè€Œ`Â·`è¿ç®—ä¸º`AND`ã€‚\n\n### å¤šé¡¹å¼\n\næ—©åœ¨19ä¸–çºªåˆæœŸï¼Œæ•°å­¦å®¶æœ€å¼€å§‹æå‡ºåŸŸçš„æ¦‚å¿µå°±æ˜¯ä¸ºäº†æ„é€ å¤šé¡¹å¼ã€‚\n\næˆ‘ä»¬å¼•å…¥ä¸€ä¸ªç¬¦åˆå˜é‡`x`ï¼Œé‚£ä¹ˆæ‰€æœ‰ä½¿ç”¨åŸŸ`F`å†…çš„å…ƒç´ ä½œä¸ºç³»æ•°ä¸`x`æ„æˆçš„å¤šé¡¹å¼çš„é›†åˆï¼Œè®°ä¸º`F[x]`ã€‚\n\nä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨`R`ä½œä¸ºæ„é€ å¤šé¡¹å¼çš„åŸŸï¼Œé‚£ä¹ˆ`x^2+1`ã€`x+2`ã€`3.14x^2-2.72x+1.41`ç­‰éƒ½å±äº`R[x]`ã€‚åŒæ•´æ•°ä¸€æ ·ï¼Œå¤šé¡¹å¼ä¹Ÿå¯ä»¥æœ‰åŠ æ³•å’Œä¹˜æ³•è¿ç®—ï¼Œä½†ä¸æ€»æ˜¯æœ‰é™¤æ³•è¿ç®—ï¼Œæ¯”å¦‚æ— æ³•å¾—å‡º`(x^2+1)/(x+2)`çš„ç»“æœï¼Œå› æ­¤`R[x]`å¹¶ä¸æ˜¯ä¸€ä¸ªåŸŸï¼Œå› ä¸º`1/(x+2)`å¯ä»¥çœ‹æˆæ˜¯`(x+2)`çš„é€†å…ƒï¼Œä½†æ˜¯å¹¶ä¸å±äº`R[x]`ä¸­ã€‚\n\nç„¶è€Œï¼Œæ­£å¦‚æ•´æ•°æ¨¡ä¸Šä»»æ„ä¸€ä¸ªç´ æ•°æ„æˆçš„é›†åˆå¯ä»¥æ„æˆä¸€ä¸ªåŸŸï¼Œ**å¤šé¡¹å¼æ¨¡ä¸Šä¸€ä¸ªç´ å¤šé¡¹å¼æ„æˆçš„é›†åˆå¯ä»¥æ„æˆåŸŸ**\n\n**ç´ å¤šé¡¹å¼ï¼ˆ`prime polynomial`ï¼‰ï¼šç³»æ•°ä¸ºæ•´æ•°å¹¶ä¸”ä¸èƒ½è¢«å› å¼åˆ†è§£æˆä½é˜¶å¤šé¡¹å¼ã€‚**æ¯”å¦‚ä¸Šé¢çš„`x^2+1`ï¼Œåœ¨å®æ•°èŒƒå›´å†…ä¸å¯è¢«å› å¼åˆ†è§£ã€‚å› æ­¤ï¼Œ`R[x]/(x^2+1)`å°±æ˜¯ä¸€ä¸ªåŸŸï¼Œè¿™ä¸ªåŸŸä¸­çš„å¤šé¡¹å¼ä¸­`x`çš„æœ€é«˜æ¬¡å¹‚æœ€å¤§åªèƒ½æ˜¯`1`\n\nå¯¹äºåŸŸ`Z/p`ï¼Œ`mod`ä¸€ä¸ª`n`æ¬¡ç´ å¤šé¡¹å¼`f(x)`çš„ç»“æœä¸ºä¸€ä¸ªå…·æœ‰`p^n`ä¸ªå…ƒç´ çš„åŸŸ`(Z/p)[x]/f(x)`ã€‚å…³äº`f(x)`è¿™ä¸ªç´ å¤šé¡¹å¼çš„é€‰æ‹©å¹¶ä¸é‡è¦ï¼Œå› ä¸ºä»»æ„ä¸¤ä¸ªå¤§å°ä¸º`p^n`çš„æœ‰é™åŸŸå…·æœ‰ç›¸åŒçš„ç»“æ„ï¼Œ**å°†å¤§å°ä¸º`p^n`çš„æœ‰é™åŸŸè®°ä¸º`GF(p^n)`ã€‚**\n\nå¯¹äºå¤šé¡¹å¼ï¼Œä¾‹å¦‚`x^8+x^4+x^3+x+1`ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå‘é‡`[1,0,0,0,1,1,0,1,1]`ã€‚\n\n### GF(2^n)\n\nä½œä¸ºç¨‹åºå‘˜ï¼Œå¯¹æˆ‘ä»¬æ¥è¯´æœ€æœ‰è¶£çš„æ˜¯`GF(2^n)`ï¼Œå³`Z/2`çš„å¤šé¡¹å¼æ‰©å±•ï¼Œå› ä¸º`GF(2^n)`çš„å…ƒç´ ä¸ºé•¿åº¦ä¸º`n`çš„ä½å‘é‡ã€‚\n\nä¾‹å¦‚ï¼Œ`(Z/2)[x]/(x^8+x^4+x^3+x+1)`ï¼Œè¿™ä¸ªåŸŸå…±æœ‰`2^8`ä¸ªå…ƒç´ ï¼Œæ¯ä¸€ä¸ªå…ƒç´ ä¸ºä¸€ä¸ªé•¿åº¦ä¸º`8`çš„ä½å‘é‡ï¼Œä»£è¡¨ä¸€ä¸ªå•å­—èŠ‚ï¼šä¸€ä¸ªå­—èŠ‚çš„äºŒè¿›åˆ¶å½¢å¼ *b~7~b~6~b~5~b~4~b~3~b~2~b~1~b~0~* ä»£è¡¨å¤šé¡¹å¼ *b~7~x^7^+b~6~x^6^+b~5~x^5^+b~4~x^4^+b~3~x^3^+b~2~x^2^+b~1~x+b~0~*ã€‚\n\n##### åŠ æ³•æ“ä½œ\n\nå¤šé¡¹å¼çš„åŠ æ³•æ“ä½œï¼Œå³æŠŠç›¸åŒæ¬¡æ•°çš„é¡¹ç³»æ•°ç›¸åŠ ï¼Œå› ä¸ºç³»æ•°æ˜¯`Z/2`çš„å…ƒç´ ï¼Œå› æ­¤ç³»æ•°ç›¸åŠ æ„å‘³ç€`XOR`æ“ä½œ\n\n```\n(x^2 + x) + (x + 1) = x^2 + 2x + 1 = x^2 + 1\n```\n\næ¢æˆäºŒè¿›åˆ¶å½¢å¼ï¼š*110~2~+011~2~=101~2~*\n\n##### ä¹˜æ³•æ“ä½œ\n\nå¤šé¡¹å¼çš„ä¹˜æ³•æ“ä½œæ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦åŸºäºåŠ æ³•çš„`XOR`æ“ä½œ\n\n```\n(x^2 + x) Â· (x + 1) = x^3 + x^2 + x^2 + x = x^3 + x\n```\n\næ¢æˆäºŒè¿›åˆ¶å½¢å¼ï¼Œå…·ä½“çš„è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š\n\n```\n     110\n x   011\n---------\n     110\n    110\n + 000\n---------\n   01010\n```\n\nè®¡ç®—åçš„ç»“æœå¯èƒ½æº¢å‡ºï¼Œéœ€è¦æ¨¡ä¸Šå¯¹åº”çš„ç´ å¤šé¡¹å¼ï¼Œæ¯”å¦‚ *(Z/2)[x]/(x^8^+x^4^+x^3^+x+1)*è¿™ä¸ªåŸŸå†…çš„å…ƒç´ çš„ä¹˜æ³•ï¼Œæœ€åçš„ç»“æœéœ€è¦æ¨¡ä¸Šç´ å¤šé¡¹å¼å¼*x^8^+x^4^+x^3^+x+1*ã€‚\n\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸Šé¢çš„ä¹˜æ³•è¿‡ç¨‹ä¸­ï¼Œéœ€è¦åˆ†åˆ«æ‰§è¡Œ`n`æ¬¡ä¹˜æ³•å’ŒåŠ æ³•ï¼Œè¿™ä¸ª`n`ä¸ºå…·ä½“ä½å‘é‡çš„é•¿åº¦ã€‚è€Œåœ¨å®é™…å®ç°åŸŸçš„ä¹˜æ³•æ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨æŸ¥æ‰¾è¡¨æ¥è¿›è¡Œä¼˜åŒ–ã€‚è¿™é‡Œçš„æŸ¥æ‰¾è¡¨ä¸æ˜¯è¯´å»ºç«‹ä¾‹å¦‚ä¹ä¹ä¹˜æ³•è¡¨é‚£æ ·çš„è¡¨æ ¼ï¼Œåœ¨ä»‹ç»å…·ä½“çš„ä¼˜åŒ–åŸç†ä¹‹å‰ï¼Œéœ€è¦å…ˆä»‹ç»ä¸€ä¸‹**ç”Ÿæˆå…ƒ**çš„æ¦‚å¿µã€‚\n\n**åœ¨ä¸€ä¸ªæœ‰é™åŸŸä¸­ï¼Œè‡³å°‘å­˜åœ¨ä¸€ä¸ªå…ƒç´ Î±ï¼Œä½¿å¾—åŸŸå†…ä»»æ„ä¸€ä¸ªéé›¶å…ƒç´ éƒ½å¯ä»¥è¡¨ç¤ºä¸ºè¯¥å…ƒç´ çš„æ–¹å¹‚**ã€‚\n\n**å‡è®¾ä¸€ä¸ªæœ‰é™åŸŸçš„éé›¶å…ƒç´ ä¸ªç´ ä¸ºnï¼Œå¹¶ä¸”ä¸€ä¸ªç”Ÿæˆå…ƒä¸ºÎ±ï¼Œé‚£ä¹ˆ Î±^n^ = 1**ã€‚\n\nä¾‹å¦‚ï¼Œ2æ˜¯ *Z/5* çš„ä¸€ä¸ªç”Ÿæˆå…ƒï¼Œ{Î±, Î±^2^, Î±^3^, Î±^4^} = {2, 4, 3, 1}ã€‚å¯¹äº`GF(p^n)`è®¡ç®—ä¼šæ›´å¤æ‚ï¼Œä½†æ˜¯åŒæ ·ç”Ÿæ•ˆã€‚\n\né€šè¿‡ç”Ÿæˆå…ƒ`Î±`ï¼ŒåŸŸä¸­çš„ä»»æ„éé›¶å…ƒç´ éƒ½å¯ä»¥è¡¨ç¤ºä¸º`Î±`çš„æ–¹å¹‚ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å…ƒç´ çš„ä¹˜æ³•è½¬æ¢ä¸ºå¹‚çš„åŠ æ³•ã€‚å› æ­¤ï¼Œ**æˆ‘ä»¬åœ¨å®ç°ä¹˜æ³•æ—¶ï¼Œå¯ä»¥å…ˆç”Ÿæˆä¸€å¼ `exp`è¡¨å’Œä¸€å¼ `log`è¡¨ï¼Œå…¶ä¸­ *exp[i] = Î±^i^*ï¼Œ è€Œ *log[Î±^i^] = i*ã€‚é€šè¿‡è¿™ä¸¤å¼ æŸ¥æ‰¾è¡¨ï¼Œé’ˆå¯¹éé›¶å…ƒç´ aå’Œbçš„ä¹˜æ³•å¯ä»¥è½¬æ¢ä¸ºï¼š*aÂ·b = exp[log[a] + log[b]]*ï¼Œåªéœ€è¦æ‰§è¡Œ1æ¬¡åŠ æ³•å’Œ3æ¬¡æŸ¥è¡¨æ“ä½œå³å¯ã€‚**\n\n\n\n### Code\n\nå› ä¸º`GF(2^8)`ä¸­ä¸€ä¸ªå…ƒç´ å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º8çš„ä½å‘é‡ï¼Œæ­£å¥½æ˜¯ä¸€ä¸ªå­—èŠ‚å¤§å°ï¼Œå› æ­¤`GF(2^8)`åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ä½¿ç”¨æœ€å¹¿æ³›ã€‚ç°åœ¨æ¥å®ç°ä¸€ä¸‹`GF(2^8)`çš„è¿ç®—ã€‚\n\né¦–å…ˆå®šä¹‰ä¸€ä¸ªåŸŸï¼ŒåŒ…å«ç”¨æ¥ä¼˜åŒ–ä¹˜æ³•è¿ç®—çš„`exp`è¡¨å’Œ`log`è¡¨å’Œç´ å¤šé¡¹å¼ï¼š\n\n```go\ntype Field struct {\n\tpoly int\n\texp  [255]byte\n\tlog  [256]byte // log[0] is unused\n}\n```\n\næ„é€ å‡½æ•°çš„å®ç°ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªç´ å¤šé¡¹å¼å’Œç”Ÿæˆå…ƒï¼Œ`x^8+x^4+x^3+x+1`æ˜¯`GF(2^8)`æœ€å¹¿æ³›ä½¿ç”¨çš„ç´ å¤šé¡¹å¼ï¼Œå¯¹äºçš„äºŒè¿›åˆ¶ä¸º`100011011`ï¼Œå¯¹äºåè¿›åˆ¶ä¸º`283`ï¼Œ`3`æ˜¯`GF(2^8)`çš„ä¸€ä¸ªç”Ÿæˆå…ƒã€‚\n\n```go\nfunc NewField(poly, a int) *Field {\n\tvar f Field\n\tx := 1\n    // å¡«å……expå’Œlogè¡¨\n\tfor i := 0; i < 255; i++ {\n\t\tf.exp[i] = byte(x)\n\t\tf.log[x] = byte(i)\n\t\tx = mul(x, a, poly)\n\t}\n\tf.poly = poly\n\treturn &f\n}\n\nfunc mul(x, y, poly int) int {\n\tz := 0\n\tfor x > 0 {\n\t\tif x&1 != 0 {\n\t\t\tz ^= y\n\t\t}\n\t\tx >>= 1\n\t\ty <<= 1\n\t\tif y&0x100 != 0 {\n\t\t\ty ^= poly\n\t\t}\n\t}\n\treturn z\n}\n```\n\nä¸¤ä¸ªæŸ¥è¡¨æ–¹æ³•ï¼š\n\n```go\nfunc (f *Field) Exp(e int) byte {\n\tif e < 0 {\n\t\treturn 0\n\t}\n\treturn f.exp[e%255] // e^255 = 1\n}\n\nfunc (f *Field) Log(x byte) int {\n\tif x == 0 {\n\t\treturn -1\n\t}\n\n\treturn int(f.log[x])\n}\n```\n\nä¼˜åŒ–åçš„ä¹˜æ³•è¿ç®—å°±æ˜¯`exp[log[a]+log[b]]`ï¼š\n\n```go\nfunc (f *Field) Mul(a, b byte) byte {\n\tif a == 0 || b == 0 {\n\t\treturn 0\n\t}\n\treturn f.Exp(f.Log(a) + f.Log(b))\n}\n```\n\nåŠ æ³•æ“ä½œå°±æ˜¯å¼‚æˆ–æ“ä½œï¼š\n\n```go\nfunc (f *Field) Add(a, b byte) byte {\n\treturn a ^ b\n}\n```\n\næ±‚ä¹˜æ³•é€†å…ƒï¼š\n\n```go\nfunc (f *Field) Inv(x byte) byte {\n\tif x == 0 {\n\t\treturn 0\n\t}\n\treturn f.Exp(255 - f.Log(x))\n}\n```\n\n\n\n### å‚è€ƒ\n\n- [Finite Field Arithmetic and Reed-Solomon Coding](<https://research.swtch.com/field>)\n\n","tags":["ä»£æ•°"]},{"title":"goå‡½æ•°æ ˆå¸ƒå±€","url":"/2019/04/29/goå‡½æ•°æ ˆå¸ƒå±€/","content":"\n# Goå‡½æ•°è°ƒç”¨å¸ƒå±€\n\n### å‡½æ•°å…·æœ‰å±€éƒ¨å˜é‡ï¼ˆæ ˆå¸§å¤§å°å¤§äº0ï¼‰\n\n![](/img/go-func-statck1.png)\n\nä»ä¸Šå›¾æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå‡½æ•°è°ƒç”¨æ—¶ï¼Œå‚æ•°å’Œè¿”å›å€¼æ˜¯é€šè¿‡æ ˆæ¥ä¼ é€’çš„ï¼Œé€šè¿‡æ ˆæ¥ä¼ é€’å‡½æ•°ï¼Œèƒ½å¤Ÿå¾ˆå¥½çš„å®ç°å¤šè¿”å›å€¼ï¼Œè€Œä¸”å½“å‘ç”Ÿ`goroutine`çš„è°ƒåº¦æ—¶ï¼Œåªéœ€è¦åˆ‡æ¢`SP/BP`ç­‰å°‘é‡å¯„å­˜å™¨ï¼Œè€Œä¸éœ€è¦å¯¹é€šç”¨å¯„å­˜å™¨è¿›è¡Œåˆ‡æ¢ï¼Œè€Œä¸”ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨**å‘½åè¿”å›å€¼**æ—¶ï¼Œæ˜¯ç›´æ¥åœ¨å¯¹åº”çš„æ ˆä¸Šè¿›è¡Œæ›´æ–°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨`defer`å‡½æ•°å†…æ›´æ–°è¿”å›å€¼ã€‚\n\n##### æµ‹è¯•ä»£ç \n\n```go\nfunc frameInfo(i int) (uintptr, uintptr, uintptr, uintptr,int,int)\nfunc main() {\n\tfmt.Println(frameInfo(15))\n}\n```\n\n```assembly\nTEXT Â·frameInfo(SB),$8-54 // è¿™é‡Œ8è¡¨ç¤ºå‡½æ•°å±€éƒ¨æ ˆå¸§8ä¸ªå­—èŠ‚ï¼Œå‚æ•°å’Œè¿”å›å€¼å…±54ä¸ªå­—èŠ‚\n    MOVQ SP, AX // å–ç¡¬ä»¶å¯„å­˜å™¨SPçš„å†…å®¹ï¼Œä½œä¸ºç¬¬ä¸€ä¸ªè¿”å›å€¼\n    MOVQ AX, ret0+8(FP)\n    LEAQ i+0(SP), AX // å–pseudo_spçš„å€¼ï¼Œä½œä¸ºç¬¬äºŒä¸ªè¿”å›å€¼\n    MOVQ AX, ret2+16(FP)\n    MOVQ BP, AX  // å–ç¡¬ä»¶å¯„å­˜å™¨BPçš„å€¼ï¼Œä½œä¸ºç¬¬ä¸‰ä¸ªè¿”å›å€¼\n    MOVQ AX, ret1+24(FP)\n    LEAQ i+0(FP), AX // å–pseudo_fpçš„å€¼ï¼Œä½œä¸ºç¬¬å››ä¸ªè¿”å›å€¼\n    MOVQ AX, ret3+32(FP)\n    MOVQ i+0(FP), AX // é€šè¿‡ä¼ªå¯„å­˜å™¨fpè·å–å‚æ•°iä½œä¸ºç¬¬äº”ä¸ªè¿”å›å€¼\n    MOVQ AX, ret4+40(FP)\n    MOVQ i+16(SP), AX // é€šè¿‡ä¼ªå¯„å­˜å™¨spè·å–å‚æ•°iä½œä¸ºç¬¬å…­ç»™è¿”å›å€¼\n    MOVQ AX, ret5+48(FP)\n    RET\n\n```\n\næŸ¥çœ‹è¾“å‡ºå†…å®¹ï¼š\n\n```sh\n$ go run .\n824634146480 824634146488 824634146488 824634146504 15 15\n```\n\nå¯ä»¥çœ‹åˆ°ä¼ªå¯„å­˜å™¨`SP`å’Œæ ˆåº•å¯„å­˜å™¨`BP`æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªåœ°å€ï¼Œè€Œä¼ªå¯„å­˜å™¨`FP`æ¯”ä¼ªå¯„å­˜å™¨`SP`å¤§`16`ä¸ªå­—èŠ‚ï¼Œå…¶ä¸­é«˜`8`ä¸ªå­—èŠ‚ä¿å­˜å‡½æ•°çš„è¿”å›åœ°å€ï¼Œè€Œä½`8`ä¸ªå­—èŠ‚ä¿å­˜å‡½æ•°è°ƒç”¨è€…çš„`BP`ï¼›è€Œç¡¬ä»¶`SP`å’Œä¼ªå¯„å­˜å™¨`SP\t`ä¹‹é—´ç›¸å·®çš„å­—èŠ‚æ•°åˆšå¥½æ˜¯å‡½æ•°æ ˆå¸§ï¼ˆè¿™é‡Œçš„å‡½æ•°æ ˆå¸§ä¸åŒ…å«ä¿å­˜è°ƒç”¨è€…`BP`çš„`8`ä¸ªå­—èŠ‚ï¼‰çš„å¤§å°ï¼Œå¯ä»¥é€šè¿‡è°ƒæ•´å‡½æ•°çš„å±€éƒ¨æ ˆå¸§å¤§å°è§‚å¯Ÿå…¶å…³ç³»\n\n```assembly\nTEXT Â·frameInfo(SB),$16-54 // è°ƒæ•´æ ˆå¸§å¤§å°ä¸º16å­—èŠ‚\n```\n\næŸ¥çœ‹è¾“å‡ºå†…å®¹ï¼š\n\n```sh\n$ go run .\n824634187432 824634187448 824634187448 824634187464 15 15\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œæ–°çš„è¾“å‡ºä¸­ï¼Œç¡¬ä»¶`SP`å’Œä¼ªå¯„å­˜å™¨`SP`ä¹‹é—´ç›¸å·®ä¸º`16`å­—èŠ‚ï¼Œæ­£å¥½ä¸ºæ ˆå¸§å¤§å°ã€‚\n\n\n\n### å‡½æ•°æ ˆå¸§å¤§å°ä¸º0\n\nå½“å‡½æ•°æ ˆå¸§å¤§å°ä¸º`0`æ—¶ï¼Œæƒ…å†µå°±æœ‰ç‚¹ä¸åŒäº†ã€‚\n\nå› ä¸ºè¿™ä¸ªæ—¶å€™ï¼Œå½“å‰å‡½æ•°æ²¡æœ‰åˆ†é…æ ˆå¸§ï¼Œå› æ­¤ç¡¬ä»¶å¯„å­˜å™¨`BP`ä¸éœ€è¦ä¿å­˜å½“å‰å‡½æ•°æ ˆçš„æ ˆåº•ï¼Œä¹Ÿå°±ä¸éœ€è¦åœ¨æ ˆä¸Šé¢å¤–åˆ†é…ä¸€ä¸ª`8`å­—èŠ‚çš„ç©ºé—´æ¥ä¿å­˜å‡½æ•°è°ƒç”¨è€…çš„`BP`å¯„å­˜å™¨å†…å®¹ï¼Œä¹Ÿå°±æ˜¯è¯´å½“å‰`BP`å¯„å­˜å™¨ç›´æ¥ä¿å­˜çš„å°±æ˜¯å‡½æ•°è°ƒç”¨è€…çš„`BP`å¯„å­˜å™¨ä¿¡æ¯ã€‚\n\nè¿™æ—¶å€™çš„æ ˆç»“æ„ï¼š\n\n![](/img/go-func-statck2.png)\n\n##### æµ‹è¯•ä»£ç \n\n```go\nfunc getBp() (uintptr, uintptr)\nfunc zeroFrame(i int) (uintptr, uintptr, uintptr, uintptr, int, int, uintptr)\nfunc main() {\n\tfmt.Println(getBp())\n\tfmt.Println(zeroFrame(11))\n}\n```\n\n```assembly\nTEXT Â·getBp(SB),$8-16\n    MOVQ 0(BP), AX // è·å–è°ƒç”¨è€…å‡½æ•°çš„æ ˆåº•åœ°å€\n    MOVQ AX, ret0+0(FP)\n    MOVQ ra+8(SP), AX // è·å–å½“å‰å‡½æ•°çš„è¿”å›åœ°å€\n    MOVQ AX, ret0+8(FP)\n    RET\n\nTEXT Â·zeroFrame(SB),$0-64\n    MOVQ SP, AX // å–ç¡¬ä»¶å¯„å­˜å™¨SPçš„å†…å®¹ï¼Œä½œä¸ºç¬¬ä¸€ä¸ªè¿”å›å€¼\n    MOVQ AX, ret0+8(FP)\n    LEAQ i+0(SP), AX // å–pseudo_spçš„å€¼ï¼Œä½œä¸ºç¬¬äºŒä¸ªè¿”å›å€¼\n    MOVQ AX, ret1+16(FP)\n    MOVQ BP, AX  // å–ç¡¬ä»¶å¯„å­˜å™¨BPçš„å€¼ï¼Œä½œä¸ºç¬¬ä¸‰ä¸ªè¿”å›å€¼\n    MOVQ AX, ret2+24(FP)\n    LEAQ i+0(FP), AX // å–pseudo_fpçš„å€¼ï¼Œä½œä¸ºç¬¬å››ä¸ªè¿”å›å€¼\n    MOVQ AX, ret3+32(FP)\n    MOVQ i+0(FP), AX // é€šè¿‡ä¼ªå¯„å­˜å™¨fpè·å–å‚æ•°iä½œä¸ºç¬¬äº”ä¸ªè¿”å›å€¼\n    MOVQ AX, ret4+40(FP)\n    MOVQ i+8(SP), AX // é€šè¿‡ä¼ªå¯„å­˜å™¨spè·å–å‚æ•°iä½œä¸ºç¬¬å…­ç»™è¿”å›å€¼\n    MOVQ AX, ret5+48(FP)\n    MOVQ addr+0(SP), AX // è·å–å½“å‰å‡½æ•°çš„è¿”å›åœ°å€\n    MOVQ AX, ret6+56(FP)\n    RET\n\n```\n\næŸ¥çœ‹è¾“å‡ºå†…å®¹ï¼š\n\n```sh\n$ go run .\n824634187656 4776270\n824634187392 824634187392 824634187656 824634187400 11 11 4776438\n```\n\nå‡½æ•°`getBp`è¿”å›äº†è°ƒç”¨è€…ä¹Ÿå³`main`å‡½æ•°çš„æ ˆåº•ä¿¡æ¯ï¼Œå’Œå½“å‰å‡½æ•°çš„è¿”å›åœ°å€\n\nç„¶åè°ƒç”¨å‡½æ•°`zeroFrame`ï¼Œè¯¥å‡½æ•°æ ˆå¸§å¤§å°ä¸º`0`ï¼Œå¯ä»¥çœ‹åˆ°æ‰§è¡Œè¯¥å‡½æ•°æ—¶ï¼Œ`BP`å¯„å­˜å™¨ä¾ç„¶æ˜¯`824634187656`ï¼Œè€Œä¸”ç¡¬ä»¶å¯„å­˜å™¨`SP`å’Œä¼ªå¯„å­˜å™¨`SP`æŒ‡å‘åŒä¸€ä¸ªä½ç½®ï¼Œå¹¶ä¸”å’Œä¼ªå¯„å­˜å™¨`FP`åªç›¸å·®`8`ä¸ªå­—èŠ‚ï¼Œè€Œè¿™`8`ä¸ªå­—èŠ‚ä¿å­˜çš„æ˜¯å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªå‡½æ•°çš„è¿”å›åœ°å€æ˜¯åœ¨åŒä¸€ä¸ªæ®µä¸­çš„ã€‚","tags":["go"]},{"title":"mutexè§£æ","url":"/2019/04/14/goä¸­çš„é”å®ç°æ¢ç©¶/","content":"\n`go`çš„åŸºç¡€åŒ…`sync`æä¾›äº†ä¸¤ç§é”çš„å®ç°ï¼Œåˆ†åˆ«æ˜¯`Mutex`å’Œ`RWMutex`ã€‚å…¶ä¸­`Mutex`æ˜¯äº’æ–¥é”ï¼Œä¸€æ¬¡åªå…è®¸ä¸€ä¸ªåç¨‹è·å–é”ï¼Œ`RWMutex`æ˜¯è¯»å†™é”ï¼Œå…è®¸åŒæ—¶æœ‰å¤šä¸ªåç¨‹è·å–è¯»é”ï¼Œä½†æ˜¯åªèƒ½æœ‰ä¸€ä¸ªåç¨‹è·å–è¯»é”ï¼Œå¹¶ä¸”è¯»å†™äº’æ–¥ã€‚\n\n### Mutex\n\nå¥½ä¹ æƒ¯ï¼Œçœ‹æºç å…ˆçœ‹æ³¨é‡Šï¼š\n\n```\n// Mutex fairness.\n//\n// Mutex can be in 2 modes of operations: normal and starvation.\n// In normal mode waiters are queued in FIFO order, but a woken up waiter\n// does not own the mutex and competes with new arriving goroutines over\n// the ownership. New arriving goroutines have an advantage -- they are\n// already running on CPU and there can be lots of them, so a woken up\n// waiter has good chances of losing. In such case it is queued at front\n// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,\n// it switches mutex to the starvation mode.\n//\n// In starvation mode ownership of the mutex is directly handed off from\n// the unlocking goroutine to the waiter at the front of the queue.\n// New arriving goroutines don't try to acquire the mutex even if it appears\n// to be unlocked, and don't try to spin. Instead they queue themselves at\n// the tail of the wait queue.\n//\n// If a waiter receives ownership of the mutex and sees that either\n// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,\n// it switches mutex back to normal operation mode.\n//\n// Normal mode has considerably better performance as a goroutine can acquire\n// a mutex several times in a row even if there are blocked waiters.\n// Starvation mode is important to prevent pathological cases of tail latency.\n```\n\n##### ç»“æ„å£°æ˜\n\né¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`Mutex`çš„å£°æ˜\n\n```go\ntype Mutex struct {\n\tstate int32 \n\tsema  uint32  \n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œ`Mutex`åªåŒ…å«ä¸¤ä¸ªå­—æ®µï¼Œå…¶ä¸­`state`ç”¨äºè®°å½•é”çš„çŠ¶æ€ï¼Œç¬¬ä¸€ä½è¡¨ç¤ºé”æ˜¯å¦è¢«å ç”¨ï¼Œç¬¬äºŒä½ç”¨äºé€šçŸ¥`unlock`æ–¹æ³•ä¸è¦å”¤é†’ä¸€ä¸ª`waiter`å‚ä¸é”çš„æŠ¢å¤ºï¼Œç¬¬ä¸‰ä½è¡¨ç¤ºæ˜¯å½“å‰é”å¦å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œä»ç¬¬å››ä½åˆ°ç¬¬32ä½åˆ™ç”¨äºè®°å½•å½“å‰é˜»å¡åœ¨ç­‰å¾…é”çš„åç¨‹æ•°é‡ï¼›è€Œ`sema`æ˜¯ç”¨äºåœ¨å¤šä¸ªåç¨‹ä¹‹é—´è¿›è¡ŒåŒæ­¥çš„ä¿¡å·é‡ï¼Œè¿™ä¸ªåé¢å†è¯´ã€‚\n\n##### æŠ¢å é”\n\næˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸‹`Lock`æ–¹æ³•å®ç°ï¼š\n\n```go\n// Lock locks m.\n// If the lock is already in use, the calling goroutine\n// blocks until the mutex is available.\nfunc (m *Mutex) Lock() {\n\t// é¦–å…ˆå…ˆå°è¯•è·å–unlockçš„é”\n    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {\n        // ç«äº‰æ£€æŸ¥ï¼Œå¿½ç•¥ã€‚ã€‚ã€‚\n\t\tif race.Enabled {\n\t\t\trace.Acquire(unsafe.Pointer(m))\n\t\t}\n        // è¡¨ç¤ºcasæ“ä½œæˆåŠŸï¼Œè·å–é”ï¼Œç›´æ¥è¿”å›\n\t\treturn\n\t}\n\t\n    // è®°å½•å¼€å§‹ç­‰å¾…çš„æ—¶é—´\n\tvar waitStartTime int64\n\t// æ˜¯å¦å¤„äºé¥¥é¥¿æ¨¡å¼\n    starving := false\n    // æ˜¯å¦è®¾ç½®äº†stateçš„mutexWokençŠ¶æ€ä½\n\tawoke := false\n    // è®°å½•è‡ªæ—‹æ¬¡æ•°\n\titer := 0\n    // è·å–å½“å‰çš„çŠ¶æ€\n\told := m.state\n\tfor {\n\t\t// å¦‚æœå½“å‰é”å¤„äºLockedçŠ¶æ€ï¼Œå¹¶ä¸”å…è®¸è‡ªæ—‹ï¼Œåˆ™è¿›å…¥è‡ªæ—‹çŠ¶æ€\n        // å…è®¸è‡ªæ—‹çš„æ¡ä»¶ï¼šä¸å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œè‡ªæ—‹æ¬¡æ•°å°äº4ï¼Œrunning on a multicore machine and GOMAXPROCS>1 and there is at least one other running P and local runq is empty\n\t\tif old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {\n\t\t\t// æ›´æ–°stateçš„ç¬¬äºŒä½ï¼Œè¡¨ç¤ºå½“å‰æœ‰è¿è¡Œä¸­çš„åç¨‹åœ¨æŠ¢å é”\n\t\t\tif !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&\n\t\t\t\tatomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {\n\t\t\t\tawoke = true\n\t\t\t}\n            // æ‰§è¡Œè‡ªæ—‹ï¼Œæ‰€è°“è‡ªæ—‹ï¼Œå°±æ˜¯ä¸€ç§busy waitï¼Œå½“å‰åç¨‹ä¸é˜»å¡ï¼Œç­‰å¾…ä¸€ä¼šå„¿é‡æ–°å°è¯•è·å–é”ï¼Œè¿™é‡Œçš„doSpinæ˜¯åœ¨runtimeåŒ…ä¸­å®ç°çš„\n\t\t\truntime_doSpin()\n\t\t\titer++ // æ·»åŠ è‡ªæ—‹æ¬¡æ•°\n\t\t\told = m.state\n\t\t\tcontinue \n\t\t}\n        \n        // å‚ä¸é”çš„æŠ¢å¤º\n        \n\t\tnew := old\n\t\t// å¦‚æœä¸å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œè®¾ç½®çŠ¶æ€ä½å°è¯•è·å–é”\n        if old&mutexStarving == 0 {\n\t\t\tnew |= mutexLocked\n\t\t}\n        \n        // å¦‚æœå·²ç»é”ä½æˆ–è€…å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œéœ€è¦è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œwaiteræ•°é‡åŠ 1\n\t\tif old&(mutexLocked|mutexStarving) != 0 {\n\t\t\tnew += 1 << mutexWaiterShift\n\t\t}\n        \n\t\t// å¦‚æœéœ€è¦è¿›å…¥é¥¥é¥¿çŠ¶æ€ï¼Œåˆ™è®¾ç½®é¥¥é¥¿æ ‡å¿—ä½\n\t\tif starving && old&mutexLocked != 0 {\n\t\t\tnew |= mutexStarving\n\t\t}\n        \n        // stateçš„mutexWokençŠ¶æ€ä½\n\t\tif awoke {\n\t\t\t// The goroutine has been woken from sleep,\n\t\t\t// so we need to reset the flag in either case.\n\t\t\tif new&mutexWoken == 0 {\n\t\t\t\tthrow(\"sync: inconsistent mutex state\")\n\t\t\t}\n\t\t\tnew &^= mutexWoken\n\t\t}\n        // casæ›´æ–°é”çŠ¶æ€\n\t\tif atomic.CompareAndSwapInt32(&m.state, old, new) {\n            // æ›´æ–°æˆåŠŸï¼Œå¹¶ä¸”åŸæ¥é”ä¸ºunlockå¹¶ä¸”ä¸å±äºé¥¥é¥¿æ¨¡å¼ï¼Œç›´æ¥è¿”å›\n            // è¿™ç§æƒ…å†µæ˜¯é”å¤„äºæ­£å¸¸æ¨¡å¼ï¼Œæ–°çš„åç¨‹ä¸ä»ç­‰å¾…ä¸­å”¤é†’çš„åç¨‹ç«äº‰é”ï¼Œå¹¶ä¸”ç«äº‰æˆåŠŸ\n\t\t\tif old&(mutexLocked|mutexStarving) == 0 {\n\t\t\t\tbreak // locked the mutex with CAS\n\t\t\t}\n            \n\t\t\t// æ˜¯å¦æ˜¯ä»ç­‰å¾…çŠ¶æ€ä¸­å”¤é†’çš„\n\t\t\tqueueLifo := waitStartTime != 0\n            // è®¾ç½®å¼€å§‹ç­‰å¾…æ—¶é—´\n\t\t\tif waitStartTime == 0 {\n\t\t\t\twaitStartTime = runtime_nanotime()\n\t\t\t}\n            \n            // å½“å‰åç¨‹æŠ¢å é”å¤±è´¥ï¼Œé˜»å¡ç­‰å¾…ï¼Œè¿™é‡Œéœ€è¦ä¼ å…¥ä¿¡å·é‡semaå’ŒqueueLifo\n            // ä¿¡å·é‡semaç”¨æ¥åœ¨å¤šä¸ªåç¨‹ä¹‹é—´åŒæ­¥\n            // queueLifoå¦‚æœä¸ºtrueï¼Œè¡¨ç¤ºå½“å‰åç¨‹ä¸æ–°çš„åç¨‹ç«äº‰é”å¤±è´¥ï¼ŒåŠ å…¥é˜Ÿé¦–ï¼Œå¦åˆ™åŠ å…¥é˜Ÿå°¾\n\t\t\truntime_SemacquireMutex(&m.sema, queueLifo)\n            \n            // æ‰§è¡Œåˆ°è¿™é‡Œè¡¨æ˜åç¨‹è¢«ä»ç­‰å¾…é˜Ÿåˆ—ä¸­å”¤é†’äº†\n            // å¦‚æœç­‰å¾…æ—¶é—´å¤§äº1msåˆ™è¿›å…¥é¥¥é¥¿æ¨¡å¼\n\t\t\tstarving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs\n\t\t\told = m.state\n            // å½“å‰é”å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œè¡¨æ˜æ²¡æœ‰å…¶ä»–åç¨‹ä¼šä¸å½“å‰åç¨‹ç«äº‰é”\n\t\t\tif old&mutexStarving != 0 {\n\t\t\t\t// æ£€æŸ¥çŠ¶æ€ä½\n\t\t\t\tif old&(mutexLocked|mutexWoken) != 0 || old>>mutexWaiterShift == 0 {\n\t\t\t\t\tthrow(\"sync: inconsistent mutex state\")\n\t\t\t\t}\n                // æ›´æ–°çŠ¶æ€ä½ï¼Œé¥¥é¥¿æ¨¡å¼ï¼Œåªæœ‰å½“å‰åç¨‹èƒ½å¤ŸæŠ¢å é”\n                // é˜»å¡ç­‰å¾…é”çš„åç¨‹æ•°é‡éœ€è¦å‡1\n\t\t\t\tdelta := int32(mutexLocked - 1<<mutexWaiterShift)\n                // å¦‚æœä¸éœ€è¦è¿›å…¥é¥¥é¥¿æ¨¡å¼ï¼Œæˆ–è€…å½“å‰ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™æ¸…ç©ºé¥¥é¥¿æ¨¡å¼\n\t\t\t\tif !starving || old>>mutexWaiterShift == 1 {\n\t\t\t\t\tdelta -= mutexStarving\n\t\t\t\t}\n                // è¿™é‡Œä½¿ç”¨åŸå­Addè€Œä¸æ˜¯CASæ“ä½œï¼Œå› ä¸ºå¯èƒ½åœ¨è¿™ä¸ªæ—¶åˆ»æœ‰æ–°çš„åç¨‹å› ä¸ºç­‰å¾…é”è€Œé˜»å¡ï¼Œè¿™æ—¶å€™å¦‚æœä½¿ç”¨CASä¼šå¤±è´¥\n\t\t\t\tatomic.AddInt32(&m.state, delta)\n\t\t\t\tbreak // è¿”å›\n\t\t\t}\n            // å½“å‰é”å¤„äºæ­£å¸¸æ¨¡å¼ï¼Œå› æ­¤éœ€è¦å’Œæ–°åŠ å…¥çš„åç¨‹ç«äº‰é”\n\t\t\tawoke = true\n\t\t\titer = 0\n\t\t} else { // caså¤±è´¥ï¼Œé‡è¯•\n\t\t\told = m.state\n\t\t}\n\t}\n\n\tif race.Enabled {\n\t\trace.Acquire(unsafe.Pointer(m))\n\t}\n}\n```\n\næ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹`runtime_SemacquireMutex`è¿™ä¸ªæ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å®ç°åœ¨`runtime`åŒ…ä¸­ï¼š\n\n```go\n// è¿™é‡Œä½¿ç”¨`go:linkname`å‘Šè¯‰é“¾æ¥å™¨å°†è¯¥æ–¹æ³•ä¸syncåŒ…çš„runtime_SemacquireMutexæ–¹æ³•é“¾æ¥\n//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex\nfunc sync_runtime_SemacquireMutex(addr *uint32, lifo bool) {\n\tsemacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)\n}\n\nfunc semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {\n    // è·å–å½“å‰g\n\tgp := getg()\n    // ä¸å…è®¸åœ¨ç³»ç»Ÿæ ˆæ‰§è¡ŒLockæ–¹æ³•\n\tif gp != gp.m.curg {\n\t\tthrow(\"semacquire not on the G stack\")\n\t}\n\n\t// å°è¯•æ•è·ä¿¡å·é‡ï¼ŒæˆåŠŸåˆ™ç›´æ¥è¿”å›\n\tif cansemacquire(addr) {\n\t\treturn\n\t}\n\t\n    // sudogç”¨æ¥è¡¨ç¤ºä¸€ä¸ªé˜»å¡çš„gï¼ŒåŒä¸€ä¸ªé”çš„ç­‰å¾…åç¨‹ä¼šæ„æˆä¸€æ¡sudogé“¾è¡¨ï¼Œå¤šæ¡é“¾è¡¨ä¼šç»„ç»‡æˆä¸€é¢—å¹³è¡¡æ ‘\n\ts := acquireSudog()\n   // é€šè¿‡semaçš„åœ°å€è·å–å¯¹åº”çš„rootï¼Œä¸€ä¸ªrootä¸­æœ‰å¤šä¸ªsemaçš„ç­‰å¾…é˜Ÿåˆ—\n\troot := semroot(addr)\n\tt0 := int64(0)\n\ts.releasetime = 0\n\ts.acquiretime = 0\n\ts.ticket = 0\n\tif profile&semaBlockProfile != 0 && blockprofilerate > 0 {\n\t\tt0 = cputicks()\n\t\ts.releasetime = -1\n\t}\n\tif profile&semaMutexProfile != 0 && mutexprofilerate > 0 {\n\t\tif t0 == 0 {\n\t\t\tt0 = cputicks()\n\t\t}\n\t\ts.acquiretime = t0\n\t}\n\tfor {\n\t\tlock(&root.lock)\n\t\t// Add ourselves to nwait to disable \"easy case\" in semrelease.\n\t\tatomic.Xadd(&root.nwait, 1)\n\t\t// å†æ¬¡å°è¯•æ•è·ä¿¡å·é‡\n\t\tif cansemacquire(addr) {\n\t\t\tatomic.Xadd(&root.nwait, -1)\n\t\t\tunlock(&root.lock)\n\t\t\tbreak\n\t\t}\n\t\t// åŠ å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œä¸€ä¸ªrootå†…æœ‰å¤šä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œè¿™äº›ç­‰å¾…é˜Ÿåˆ—é€šè¿‡å¹³è¡¡æ ‘æ¥ç»„ç»‡ï¼Œç­‰å¾…é˜Ÿåˆ—é€šè¿‡addræ¥æ ‡è¯†ï¼Œæ¯ä¸ªç­‰å¾…é˜Ÿåˆ—å°±æ˜¯ä¸€ä¸ªsudogåˆ—è¡¨\n\t\troot.queue(addr, s, lifo)\n        // é˜»å¡å½“å‰g\n\t\tgoparkunlock(&root.lock, waitReasonSemacquire, traceEvGoBlockSync, 4)\n\t\t// gè¢«å”¤é†’ï¼Œå¦‚æœticketä¸ä¸º0æˆ–è€…å†æ¬¡å°è¯•æ•è·ä¿¡å·é‡æˆåŠŸ\n        if s.ticket != 0 || cansemacquire(addr) {\n\t\t\tbreak // æ•è·æˆåŠŸ\n\t\t}\n\t}\n\tif s.releasetime > 0 {\n\t\tblockevent(s.releasetime-t0, 3)\n\t}\n    // é‡Šæ”¾sudog\n\treleaseSudog(s)\n}\n```\n\n##### é‡Šæ”¾é”\n\nç°åœ¨æ¥çœ‹ä¸€ä¸‹`Unlock`æ–¹æ³•å®ç°ï¼š\n\n```go\nfunc (m *Mutex) Unlock() {\n\tif race.Enabled {\n\t\t_ = m.state\n\t\trace.Release(unsafe.Pointer(m))\n\t}\n\n\t// Fast path: drop lock bit.\n    // æ¸…ç©ºé”çŠ¶æ€\n\tnew := atomic.AddInt32(&m.state, -mutexLocked)\n    // æ£€æŸ¥çŠ¶æ€ä½\n\tif (new+mutexLocked)&mutexLocked == 0 {\n\t\tthrow(\"sync: unlock of unlocked mutex\")\n\t}\n    // å¦‚æœä¸å¤„äºé¥¥é¥¿æ¨¡å¼\n\tif new&mutexStarving == 0 {\n\t\told := new\n\t\tfor {\n\t\t\t// å¦‚æœæ²¡æœ‰ç­‰å¾…é”çš„åç¨‹ï¼Œæˆ–è€…è®¾ç½®äº†mutexWokenæ ‡å¿—ä½ï¼Œç›´æ¥è¿”å›\n\t\t\tif old>>mutexWaiterShift == 0 || old&(mutexLocked|mutexWoken|mutexStarving) != 0 {\n\t\t\t\treturn\n\t\t\t}\n            \n\t\t\t// å”¤é†’ä¸€ä¸ªç­‰å¾…çš„åç¨‹ï¼Œå‚ä¸é”ç«äº‰\n\t\t\tnew = (old - 1<<mutexWaiterShift) | mutexWoken\n\t\t\tif atomic.CompareAndSwapInt32(&m.state, old, new) {\n\t\t\t\truntime_Semrelease(&m.sema, false)\n\t\t\t\treturn\n\t\t\t}\n\t\t\told = m.state\n\t\t}\n\t} else {\n\t\t// å½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ï¼Œä»ç­‰å¾…é˜Ÿåˆ—å”¤é†’åç¨‹\n\t\truntime_Semrelease(&m.sema, true)\n\t}\n}\n```\n\næ¥ä¸‹æ¥çœ‹ä¸€ä¸‹`runtime_Semrelease`æ–¹æ³•ï¼š\n\n```go\n//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease\nfunc sync_runtime_Semrelease(addr *uint32, handoff bool) {\n\tsemrelease1(addr, handoff)\n}\n\nfunc semrelease1(addr *uint32, handoff bool) {\n\troot := semroot(addr)\n\tatomic.Xadd(addr, 1) // addrå€¼åŠ 1\n\n\t// Easy case: no waiters?\n\t// This check must happen after the xadd, to avoid a missed wakeup\n\t// (see loop in semacquire).\n\tif atomic.Load(&root.nwait) == 0 {\n\t\treturn\n\t}\n\n\t// Harder case: search for a waiter and wake it.\n\tlock(&root.lock)\n\tif atomic.Load(&root.nwait) == 0 {\n\t\t// The count is already consumed by another goroutine,\n\t\t// so no need to wake up another goroutine.\n\t\tunlock(&root.lock)\n\t\treturn\n\t}\n    // ä»é˜Ÿé¦–è·å–ç­‰å¾…çš„sudog\n\ts, t0 := root.dequeue(addr)\n\tif s != nil {\n\t\tatomic.Xadd(&root.nwait, -1)\n\t}\n\tunlock(&root.lock)\n\tif s != nil { // May be slow, so unlock first\n\t\tacquiretime := s.acquiretime\n\t\tif acquiretime != 0 {\n\t\t\tmutexevent(t0-acquiretime, 3)\n\t\t}\n\t\tif s.ticket != 0 {\n\t\t\tthrow(\"corrupted semaphore ticket\")\n\t\t}\n        // å¦‚æœhandoffä¸ºtrueï¼Œåˆ™å°è¯•æ•è·ä¿¡å·é‡\n\t\tif handoff && cansemacquire(addr) {\n            // æˆåŠŸï¼Œåˆ™æ›´æ–°ticketä¸º1\n\t\t\ts.ticket = 1\n\t\t}\n        // å”¤é†’g\n\t\treadyWithTime(s, 5)\n\t}\n}\n```\n\n\n\n> æ–°ç‰ˆæœ¬çš„`Mutex`å®ç°ï¼Œå°†`Lock`å’Œ`Unlock`æ–¹æ³•ä¸­çš„åªä¿ç•™äº†`fastpath`ï¼Œè€Œ`slowpath`éƒ¨åˆ†ç§»åˆ°æ–°çš„å­è¿‡ç¨‹ä¸­ï¼Œç”¨äºå†…è”ä¼˜åŒ–ã€‚\n\n\n\n### RWMutex\n\nç°åœ¨æ¥çœ‹ä¸€ä¸‹`RWMutex`ï¼ŒåŒæ ·éƒ½ï¼Œå…ˆçœ‹æ³¨é‡Šï¼š\n\n```\n// A RWMutex is a reader/writer mutual exclusion lock.\n// The lock can be held by an arbitrary number of readers or a single writer.\n// The zero value for a RWMutex is an unlocked mutex.\n//\n// A RWMutex must not be copied after first use.\n//\n// If a goroutine holds a RWMutex for reading and another goroutine might\n// call Lock, no goroutine should expect to be able to acquire a read lock\n// until the initial read lock is released. In particular, this prohibits\n// recursive read locking. This is to ensure that the lock eventually becomes\n// available; a blocked Lock call excludes new readers from acquiring the\n// lock.\n```\n\n##### ç»“æ„å£°æ˜\n\n```go\ntype RWMutex struct {\n\tw           Mutex  // held if there are pending writers\n\twriterSem   uint32 // semaphore for writers to wait for completing readers\n\treaderSem   uint32 // semaphore for readers to wait for completing writers\n\treaderCount int32  // number of pending readers\n\treaderWait  int32  // number of departing readers\n}\n```\n\n\n\n##### æŠ¢å è¯»é”\n\n```go\nfunc (rw *RWMutex) RLock() {\n   if race.Enabled {\n      _ = rw.w.state\n      race.Disable()\n   }\n    // readCountåŠ 1ï¼Œå¦‚æœå°äº0ï¼Œè¡¨æ˜å½“å‰æœ‰å†™é”æ­£åœ¨ç­‰å¾…ï¼Œåˆ™é˜»å¡ç­‰å¾…\n   if atomic.AddInt32(&rw.readerCount, 1) < 0 {\n      // A writer is pending, wait for it.\n      runtime_SemacquireMutex(&rw.readerSem, false)\n   }\n   if race.Enabled {\n      race.Enable()\n      race.Acquire(unsafe.Pointer(&rw.readerSem))\n   }\n}\n```\n\n##### é‡Šæ”¾è¯»é”\n\n```go\nfunc (rw *RWMutex) RUnlock() {\n   if race.Enabled {\n      _ = rw.w.state\n      race.ReleaseMerge(unsafe.Pointer(&rw.writerSem))\n      race.Disable()\n   }\n    // readerCountå‡1ï¼Œå°äº0è¯´æ˜æœ‰ç­‰å¾…å†™\n   if r := atomic.AddInt32(&rw.readerCount, -1); r < 0 {\n      if r+1 == 0 || r+1 == -rwmutexMaxReaders {\n         race.Enable()\n         throw(\"sync: RUnlock of unlocked RWMutex\")\n      }\n      // A writer is pending.\n       // readerWaitå‡1ï¼Œå¦‚æœä¸º0è¡¨ç¤ºè¯»é”é‡Šæ”¾å®Œï¼Œå”¤é†’ç­‰å¾…è¯»\n      if atomic.AddInt32(&rw.readerWait, -1) == 0 {\n         // The last reader unblocks the writer.\n         runtime_Semrelease(&rw.writerSem, false)\n      }\n   }\n   if race.Enabled {\n      race.Enable()\n   }\n}\n```\n\n##### æŠ¢å å†™é”\n\n```go\nfunc (rw *RWMutex) Lock() {\n\tif race.Enabled {\n\t\t_ = rw.w.state\n\t\trace.Disable()\n\t}\n\t// First, resolve competition with other writers.\n\trw.w.Lock()\n\t// Announce to readers there is a pending writer.\n\tr := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\n\t// Wait for active readers.\n\tif r != 0 && atomic.AddInt32(&rw.readerWait, r) != 0 {\n\t\truntime_SemacquireMutex(&rw.writerSem, false)\n\t}\n\tif race.Enabled {\n\t\trace.Enable()\n\t\trace.Acquire(unsafe.Pointer(&rw.readerSem))\n\t\trace.Acquire(unsafe.Pointer(&rw.writerSem))\n\t}\n}\n```\n\n##### é‡Šæ”¾å†™é”\n\n ```go\nfunc (rw *RWMutex) Unlock() {\n\tif race.Enabled {\n\t\t_ = rw.w.state\n\t\trace.Release(unsafe.Pointer(&rw.readerSem))\n\t\trace.Disable()\n\t}\n\n\t// Announce to readers there is no active writer.\n\tr := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)\n\tif r >= rwmutexMaxReaders {\n\t\trace.Enable()\n\t\tthrow(\"sync: Unlock of unlocked RWMutex\")\n\t}\n\t// Unblock blocked readers, if any.\n\tfor i := 0; i < int(r); i++ {\n\t\truntime_Semrelease(&rw.readerSem, false)\n\t}\n\t// Allow other writers to proceed.\n\trw.w.Unlock()\n\tif race.Enabled {\n\t\trace.Enable()\n\t}\n}\n ```\n\n\n\n\n\n","tags":["go"]},{"title":"goç½‘ç»œioæ¨¡å‹åˆ†æ","url":"/2019/04/07/goç½‘ç»œioæ¨¡å‹åˆ†æ/","content":"\nåœ¨è¿‡å»ï¼Œä¼ ç»Ÿçš„ç½‘ç»œç¼–ç¨‹æ¨¡å‹æ˜¯å¤šçº¿ç¨‹æ¨¡å‹ï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­å¼€å¯ä¸€ä¸ªç½‘ç»œç›‘å¬ï¼Œç„¶åæ¯æ¬¡æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯è¿›è¡Œè¿æ¥ï¼Œå°±ä¼šå•ç‹¬å¼€å¯ä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†è¿™ä¸ªå®¢æˆ·ç«¯è¯·æ±‚ã€‚\n\nç„¶è€Œï¼Œå¦‚æœå¹¶å‘é‡æ¯”è¾ƒå¤§ï¼ŒæœåŠ¡ç«¯å°±ä¼šåˆ›å»ºå¤§é‡çš„çº¿ç¨‹ï¼Œè€Œä¸”ä¼šæœ‰å¤§é‡çš„çº¿ç¨‹é˜»å¡åœ¨ç½‘ç»œIOä¸Šï¼Œé¢‘ç¹çš„çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ä¼šå ç”¨å¤§é‡çš„cpuæ—¶é—´ç‰‡ï¼Œä¸¥é‡å½±å“æœåŠ¡æ€§èƒ½ï¼Œè€Œä¸”å¤§é‡çš„çº¿ç¨‹ä¹Ÿéœ€è¦å ç”¨å¤§é‡çš„ç³»ç»Ÿèµ„æº\n\nè¿™æ ·å°±å¼•å‡ºè‘—åçš„`C10K`é—®é¢˜ï¼Œå¦‚ä½•åœ¨å•å°æœåŠ¡å™¨ä¸Šæ”¯æŒå¹¶å‘`10K`é‡çº§çš„è¿æ¥\n\næˆ‘ä»¬çŸ¥é“ï¼Œè™½ç„¶åŒä¸€æ—¶é—´æœ‰å¤§é‡çš„å¹¶å‘è¿æ¥ï¼Œä½†æ˜¯åŒä¸€æ—¶åˆ»ï¼Œåªæœ‰å°‘æ•°çš„è¿æ¥æ˜¯å¯è¯»/å†™çš„ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥åªä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹æ¥æœåŠ¡æä¾›æœåŠ¡ï¼Œè¿™ä¹Ÿæ˜¯ç›®å‰è§£å†³`C10K`é—®é¢˜çš„ä¸»è¦æ€è·¯ï¼Œå¯¹åº”çš„è§£å†³æ–¹æ¡ˆå«åš**IOå¤šè·¯å¤ç”¨**ï¼Œç°åœ¨ä¸»æµçš„é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡å™¨/æ¡†æ¶éƒ½æ˜¯åŸºäºè¯¥ç½‘ç»œæ¨¡å‹ï¼Œæ¯”å¦‚`nginx`ã€`redis`æˆ–è€…`netty`ç½‘ç»œåº“ç­‰ã€‚\n\nè¯´åˆ°è¿™ï¼Œå°±ä¸å¾—ä¸æ[`epoll`](<http://man7.org/linux/man-pages/man7/epoll.7.html>)ï¼Œè¿™æ˜¯`linux`å†…æ ¸æä¾›çš„ç”¨äºå®ç°**IOå¤šè·¯å¤ç”¨**çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶ä»–æ“ä½œç³»ç»Ÿä¸Šä¹Ÿæœ‰ç±»ä¼¼çš„æ¥å£ï¼Œå…³äº`epoll`å…·ä½“å†…å®¹ç½‘ä¸Šæœ‰ä¸€å¤§å †çš„[èµ„æ–™](<http://man7.org/linux/man-pages/man7/epoll.7.html>)ï¼Œè¿™é‡Œå°±ä¸é‡å¤ä»‹ç»äº†\n\n**IOå¤šè·¯å¤ç”¨æ¨¡å‹**ï¼Œä¹Ÿå¯ä»¥ç§°ä½œæ˜¯**äº‹ä»¶é©±åŠ¨æ¨¡å‹**ï¼Œè™½ç„¶èƒ½å¤Ÿæœ‰æ•ˆè§£å†³`C10K`é—®é¢˜ï¼Œä½†æ˜¯ç›¸å¯¹ä¼ ç»Ÿçš„å¤šçº¿ç¨‹æ¨¡å‹ä¹Ÿå¸¦æ¥äº†ä¸€ç‚¹å¤æ‚æ€§ã€‚æ¯”å¦‚è¯´ï¼Œåœ¨å¤šçº¿ç¨‹æ¨¡å‹ä¸‹ï¼Œæ¯ä¸ªè¿æ¥ç‹¬å ä¸€ä¸ªçº¿ç¨‹ï¼Œè€Œçº¿ç¨‹æœ¬èº«æœ‰è‡ªå·±çš„ä¸Šä¸‹æ–‡ï¼›è€Œå¦‚æœæ˜¯IOå¤šè·¯å¤ç”¨æ¨¡å‹ï¼Œéœ€è¦åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­å¤„ç†å¤šä¸ªè¿æ¥ï¼Œè€Œæ¯ä¸ªéœ€è¦æœ‰è‡ªå·±çš„ä¸Šä¸‹æ–‡ï¼Œéœ€è¦å¼€å‘è€…æ‰‹åŠ¨ç®¡ç†ã€‚æ¯”å¦‚æœåŠ¡ç«¯è¿˜æ²¡æœ‰æ¥æ”¶åˆ°ä¸€ä¸ªå®Œæ•´çš„åè®®æŠ¥æ–‡æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æŠŠå…ˆå‰æ¥æ”¶çš„éƒ¨åˆ†å†…å®¹ä¿å­˜åˆ°å½“å‰è¿æ¥ä¸Šä¸‹æ–‡ä¸­ï¼Œç­‰åˆ°ä¸‹æ¬¡å…¶ä½™å†…å®¹åˆ°åº•æ—¶å†ä¸€èµ·å¤„ç†ã€‚\n\nä»Šå¤©ï¼Œæˆ‘ä»¬ä¸»è¦æ¥çœ‹ä¸€ä¸‹`go`ä¸­çš„ç½‘ç»œæ¨¡å‹ã€‚\n\nåœ¨`go`ä¸­æˆ‘ä»¬å¯ä»¥åƒä¼ ç»Ÿçš„å¤šçº¿ç¨‹æ¨¡å‹é‚£æ ·ä¸ºæ¯ä¸ªç½‘ç»œè¿æ¥å•ç‹¬ä½¿ç”¨ä¸€ä¸ª`goroutine`æ¥æä¾›æœåŠ¡ï¼Œä½†æ˜¯`goroutine`çš„èµ„æºå ç”¨ç›¸æ¯”ç³»ç»Ÿçº§çº¿ç¨‹æ¥è¯´éå¸¸å°ï¼Œè€Œä¸”å…¶åˆ‡æ¢åœ¨è¿è¡Œåœ¨ç”¨æˆ·æ€çš„ï¼Œå¹¶ä¸”åªéœ€è¦äº¤æ¢å¾ˆå°‘çš„å¯„å­˜å™¨ï¼Œå› æ­¤`goroutine`çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ä»£ä»·ä¹Ÿæ˜¯æå°çš„ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå…¶åº•å±‚ä¹Ÿæ˜¯åŸºäº`epoll`ï¼ˆlinuxç³»ç»Ÿä¸‹ï¼‰æ¥å®ç°äº‹ä»¶é€šçŸ¥çš„ï¼Œå› æ­¤åªéœ€è¦å ç”¨å¾ˆå°‘çš„ç³»ç»Ÿçº§çº¿ç¨‹ã€‚\n\nå¾ˆæ˜æ˜¾å¯ä»¥çœ‹å‡ºï¼Œ`go`ä¸­çš„ç½‘ç»œIOæ¨¡å‹æ˜¯ä¼ ç»Ÿå¤šçº¿ç¨‹æ¨¡å‹å’ŒIOå¤šè·¯å¤ç”¨æ¨¡å‹çš„ç»“åˆï¼Œæ—¢æœ‰å‰è€…çš„æ˜“ç”¨æ€§ï¼Œåˆæœ‰åè€…çš„æ•ˆç‡ï¼Œå› æ­¤ä½¿ç”¨`go`å¯ä»¥å¾ˆå®¹æ˜“åœ°å¼€å‘é«˜æ€§èƒ½æœåŠ¡å™¨ã€‚\n\nä»Šå¤©æˆ‘ä»¬å°±æ¥çœ‹ä¸€ä¸‹ï¼Œ`go`ä¸­çš„ç½‘ç»œIOæ¨¡å‹æ˜¯å¦‚ä½•å®ç°çš„ã€‚\n\n### ä¸€åˆ‡ä»åˆ›å»ºListenerå¼€å§‹\n\næˆ‘ä»¬ä»åˆ›å»º`Listener`å¼€å§‹è¯´èµ·ã€‚\n\nå…ˆçœ‹ä¸‹é¢ä»£ç ï¼š\n\n```go\nln,_ :=net.Listen(\"tcp\",\":80\")\n```\n\næˆ‘ä»¬ä½¿ç”¨`Listen`æ¥åˆ›å»ºä¸€ä¸ª`Listener`ï¼Œé‚£ä¹ˆåº•å±‚å…·ä½“ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿè®©æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥æ¥æ­å¼€\n\né¦–å…ˆæŸ¥çœ‹`net.Listen`æ–¹æ³•\n\n```go\nfunc Listen(network, address string) (Listener, error) {\n\tvar lc ListenConfig\n\treturn lc.Listen(context.Background(), network, address)\n}\n```\n\nå¯ä»¥çœ‹åˆ°å®é™…ä¸Šå·¥ä½œçš„æ˜¯`ListenConfig.Listen`,æˆ‘ä»¬ç»§ç»­å¾€ä¸‹çœ‹ï¼š\n\n```go\nfunc (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) {\n    ...\n\tvar l Listener\n\tla := addrs.first(isIPv4)\n\tswitch la := la.(type) {\n\tcase *TCPAddr:\n\t\tl, err = sl.listenTCP(ctx, la)\n\t...\n\treturn l, nil\n}\n```\n\nå› ä¸ºæˆ‘ä»¬åˆ›å»ºçš„æ˜¯`tcp`è¿æ¥ï¼Œè¿™é‡Œæˆ‘ä»¬åªå…³æ³¨`sl.listenTCP`æ–¹æ³•ï¼Œç»§ç»­å¾€ä¸‹\n\n```go\nfunc (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) {\n\tfd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, \"listen\", sl.ListenConfig.Control)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &TCPListener{fd}, nil\n}\n```\n\næˆ‘ä»¬çœ‹å‡½æ•°ç¬¬ä¸€è¡Œï¼Œè°ƒç”¨äº†`internetSocket`ï¼Œå¾ˆæ˜æ˜¾é‡Œé¢å°±æ˜¯åˆ›å»ºå®é™…`socket`çš„é€»è¾‘äº†ï¼Œç»§ç»­å¾€ä¸‹èµ°\n\n```go\nfunc internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {\n\tif (runtime.GOOS == \"windows\" || runtime.GOOS == \"openbsd\" || runtime.GOOS == \"nacl\") && mode == \"dial\" && raddr.isWildcard() {\n\t\traddr = raddr.toLocal(net)\n\t}\n\tfamily, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)\n\treturn socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)\n}\n```\n\nè¿™é‡Œæˆ‘ä»¬åªçœ‹`linux`çš„æƒ…å†µï¼Œå› æ­¤ç»§ç»­çœ‹`socket`æ–¹æ³•ï¼š\n\n```go\nfunc socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {\n    // è¿™é‡Œæ˜¯å®é™…åˆ›å»ºsocketçš„ä»£ç \n\ts, err := sysSocket(family, sotype, proto)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n    // è®¾ç½®socketé€‰é¡¹\n\tif err = setDefaultSockopts(s, family, sotype, ipv6only); err != nil {\n\t\tpoll.CloseFunc(s)\n\t\treturn nil, err\n\t}\n    // æ ¹æ®socketåˆ›å»ºnetFDï¼ŒnetFDæ˜¯netåŒ…å¯¹åº•å±‚socketçš„å°è£…\n\tif fd, err = newFD(s, family, sotype, net); err != nil {\n\t\tpoll.CloseFunc(s)\n\t\treturn nil, err\n\t}\n\n\tif laddr != nil && raddr == nil {\n\t\tswitch sotype {\n        // çœ‹ä¸Šé¢çš„å‚æ•°ï¼Œæˆ‘ä»¬ä¼ å…¥çš„sotypeæ˜¯SOCK_STREAMï¼Œå› æ­¤ä¼šèµ°è¿™ä¸ªåˆ†æ”¯\n\t\tcase syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:\n\t\t\tif err := fd.listenStream(laddr, listenerBacklog, ctrlFn); err != nil {\n\t\t\t\tfd.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn fd, nil\n\t\tcase syscall.SOCK_DGRAM:\n\t\t\tif err := fd.listenDatagram(laddr, ctrlFn); err != nil {\n\t\t\t\tfd.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn fd, nil\n\t\t}\n\t}\n\tif err := fd.dial(ctx, laddr, raddr, ctrlFn); err != nil {\n\t\tfd.Close()\n\t\treturn nil, err\n\t}\n\treturn fd, nil\n}\n```\n\næˆ‘ä»¬å…ˆæ¥çœ‹`sysSocket`æ–¹æ³•ï¼š\n\n```go\nfunc sysSocket(family, sotype, proto int) (int, error) {\n    // è¿™é‡Œçš„socketFuncå®é™…ä¸Šæ˜¯åˆ›å»ºsocketçš„ç³»ç»Ÿè°ƒç”¨\n    // \tsocketFunc func(int, int, int) (int, error)  = syscall.Socket\n    // æ³¨æ„è¿™é‡Œä¼ å…¥çš„SOCK_NONBLOCKï¼Œè¡¨æ˜æˆ‘ä»¬åˆ›å»ºçš„æ˜¯éé˜»å¡çš„socket\n    // è¿™é‡Œçš„SOCK_CLOEXECè¡¨æ˜åœ¨æ‰§è¡Œforkç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå½“æ‰§è¡Œexecæ—¶éœ€è¦å…³é—­ä»çˆ¶è¿›ç¨‹ç»§æ‰¿çš„æ–‡ä»¶è®¾å¤‡\n\ts, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)\n\tswitch err {\n\tcase nil:\n\t\treturn s, nil\n\tdefault:\n\t\treturn -1, os.NewSyscallError(\"socket\", err)\n        // ä½ç‰ˆæœ¬å†…æ ¸ä¸æ”¯æŒåˆ›å»ºæ—¶æŒ‡å®šSOCK_NONBLOCKæˆ–è€…SOCK_CLOEXEC\n        // è¿™æ—¶å€™éœ€è¦åˆ†ä¸¤æ­¥ï¼Œå…ˆåˆ›å»ºsocketï¼Œç„¶åå†è®¾ç½®flag\n\tcase syscall.EPROTONOSUPPORT, syscall.EINVAL:\n\t}\n\n    // è¿™é‡Œéœ€è¦åŠ é”ï¼Œä¸forkæ“ä½œäº’æ–¥ï¼Œé˜²æ­¢åœ¨åˆ›å»ºsocketè€Œæ²¡æœ‰è®¾ç½®`SOCK_CLOEXEC`æ—¶æ‰§è¡Œäº†forkå’Œexec\n\tsyscall.ForkLock.RLock()\n    // åˆ›å»ºsocket\n\ts, err = socketFunc(family, sotype, proto)\n\tif err == nil {\n        // è®¾ç½®SOCK_COLEXEC\n\t\tsyscall.CloseOnExec(s)\n\t}\n\tsyscall.ForkLock.RUnlock()\n\tif err != nil {\n\t\treturn -1, os.NewSyscallError(\"socket\", err)\n\t}\n    // è®¾ç½®éé˜»å¡IO\n\tif err = syscall.SetNonblock(s, true); err != nil {\n\t\tpoll.CloseFunc(s)\n\t\treturn -1, os.NewSyscallError(\"setnonblock\", err)\n\t}\n\treturn s, nil\n}\n```\n\n`sysSocket`ä¸»è¦é€šè¿‡ç³»ç»Ÿè°ƒç”¨åˆ›å»ºäº†`socket`ï¼Œ**åŒæ—¶è®¾ç½®äº†`SOCK_NONBLOCK`æ ‡å¿—ä½**ï¼Œè¿™ç‚¹éå¸¸é‡è¦ï¼Œè¿™é‡Œè¦æ˜ç¡®ï¼Œæˆ‘ä»¬åœ¨`go`ä¸­ä½¿ç”¨çš„ç½‘ç»œè¿æ¥ä¸€èˆ¬éƒ½æ˜¯éé˜»å¡çš„ã€‚å…³äºé˜»å¡IOå’Œéé˜»å¡IOçš„åŒºåˆ«ç½‘ä¸Šæœ‰ä¸€å¤§å †çš„èµ„æ–™ï¼Œè¿™é‡Œå°±ä¸é‡å¤è¯´æ˜äº†ã€‚ä½¿ç”¨éé˜»å¡IOçš„ä¸»è¦çš„åŸå› æ˜¯ï¼Œ**åœ¨goä¸­ï¼Œå½“ä½¿ç”¨é˜»å¡ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå½“å‰goroutineå¯¹åº”çš„åº•å±‚ç³»ç»Ÿçº§çº¿ç¨‹å°±ä¼šè¢«å ç”¨ï¼Œæ— æ³•ä¸å½“å‰gè§£ç»‘ä¸ºå…¶ä»–gæä¾›æœåŠ¡**ï¼Œè¿™æ ·å½“éœ€è¦æ‰§è¡Œå…¶ä»–`g`æ—¶å°±éœ€è¦åˆ›å»ºæ–°çš„çº¿ç¨‹æ¥æ‰§è¡Œ\n\næ¥ç€æ¥çœ‹`netFd.listenStream`\n\n```go\nfunc (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {\n\t...\n    // ä¸ºsocketç»‘å®šç›‘å¬çš„ipå’Œç«¯å£\n\tif err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {\n\t\treturn os.NewSyscallError(\"bind\", err)\n\t}\n    // listenFunc func(int, int) error = syscall.Listen\n    // è¿™é‡Œçš„listenFuncå®é™…ä¸Šæ˜¯ç³»ç»Ÿè°ƒç”¨Listen\n    // å¼€å§‹ç›‘å¬\n\tif err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {\n\t\treturn os.NewSyscallError(\"listen\", err)\n\t}\n    // æ‰§è¡Œåˆå§‹åŒ–æ“ä½œ\n\tif err = fd.init(); err != nil {\n\t\treturn err\n\t}\n\tlsa, _ = syscall.Getsockname(fd.pfd.Sysfd)\n\tfd.setAddr(fd.addrFunc()(lsa), nil)\n\treturn nil\n}\n```\n\nè¿™é‡Œå°±æ˜¯å¸¸è§„çš„ç»‘å®šç›‘å¬åœ°å€å’Œç«¯å£ï¼Œç„¶åå¼€å§‹ç›‘å¬ï¼Œè¿™é‡Œé‡è¦çš„æ˜¯`netFD.init`å‡½æ•°ï¼Œå…ˆæ¥çœ‹`netFD`çš„ç»“æ„ï¼š\n\n```go\n// Network file descriptor.\ntype netFD struct {\n\tpfd poll.FD\n\n\t// immutable until Close\n\tfamily      int\n\tsotype      int\n\tisConnected bool // handshake completed or use of association with peer\n\tnet         string\n\tladdr       Addr\n\traddr       Addr\n}\n\n// FD is a file descriptor. The net and os packages use this type as a\n// field of a larger type representing a network connection or OS file.\ntype FD struct {\n\t// Lock sysfd and serialize access to Read and Write methods.\n\tfdmu fdMutex\n\n\t// System file descriptor. Immutable until Close.\n\tSysfd int\n\n\t// I/O poller.\n\tpd pollDesc\n\n\t// Writev cache.\n\tiovecs *[]syscall.Iovec\n\n\t// Semaphore signaled when file is closed.\n\tcsema uint32\n\n\t// Non-zero if this file has been set to blocking mode.\n\tisBlocking uint32\n\n\t// Whether this is a streaming descriptor, as opposed to a\n\t// packet-based descriptor like a UDP socket. Immutable.\n\tIsStream bool\n\n\t// Whether a zero byte read indicates EOF. This is false for a\n\t// message based socket connection.\n\tZeroReadIsEOF bool\n\n\t// Whether this is a file rather than a network socket.\n\tisFile bool\n}\n```\n\næ¥ç€çœ‹ä¸Šé¢çš„`netFD.init`å‡½æ•°ï¼š\n\n```go\nfunc (fd *netFD) init() error {\n    // è¿™é‡Œçš„pfdå®é™…ä¸Šå°±æ˜¯poll.FDï¼Œç”¨æ¥è¡¨ç¤ºä¸€ä¸ªç½‘ç»œè¿æ¥æˆ–è€…æ‰“å¼€çš„ç³»ç»Ÿæ–‡ä»¶\n\treturn fd.pfd.Init(fd.net, true)\n}\n```\n\næˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`pollFD.Init`ï¼š\n\n```go\nfunc (fd *FD) Init(net string, pollable bool) error {\n\t// We don't actually care about the various network types.\n\tif net == \"file\" {\n\t\tfd.isFile = true\n\t}\n\tif !pollable {\n\t\tfd.isBlocking = 1\n\t\treturn nil\n\t}\n    // è¿™é‡Œåˆæœ‰ä¸ªinitï¼Œè¿™é‡Œçš„pdæ˜¯pollDescç±»å‹\n\terr := fd.pd.init(fd)\n\tif err != nil {\n\t\t// If we could not initialize the runtime poller,\n\t\t// assume we are using blocking mode.\n\t\tfd.isBlocking = 1\n\t}\n\treturn err\n}\n```\n\nå¯ä»¥çœ‹åˆ°ä¸Šé¢åˆæœ‰ä¸ª`init`å‡½æ•°ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹`fd.pd`å¯¹åº”çš„`pollDesc`ç±»å‹ï¼š\n\n```go\ntype pollDesc struct {\n\truntimeCtx uintptr // è¿™ä¸ªè¿è¡Œæ—¶ä¸Šä¸‹æ–‡å¾ˆé‡è¦\n}\n```\n\næˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`init`å‡½æ•°ï¼š\n\n```go\nvar serverInit sync.Once\n\nfunc (pd *pollDesc) init(fd *FD) error {\n\t// ä¿è¯runtime_pollServerInitåªä¼šæ‰§è¡Œä¸€æ¬¡\n    serverInit.Do(runtime_pollServerInit)\n    // æ‰§è¡Œruntime_pollOpen\n\tctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))\n\tif errno != 0 {\n\t\tif ctx != 0 {\n\t\t\truntime_pollUnblock(ctx)\n\t\t\truntime_pollClose(ctx)\n\t\t}\n\t\treturn syscall.Errno(errno)\n\t}\n    // æŠŠè¿”å›å€¼ä¿å­˜åˆ°runtimeCtxä¸­\n\tpd.runtimeCtx = ctx\n\treturn nil\n}\n```\n\nä¸Šé¢è¿™ä¸ªå‡½æ•°æ‰æ˜¯å…³é”®æ‰€åœ¨ï¼Œè¿™é‡Œæ¶‰åŠåˆ°äº†`runtime_pollServerInit`å’Œ`runtime_pollOpen`ä¸¤ä¸ªå‡½æ•°ï¼Œä»å‘½åå¯ä»¥å¾ˆå®¹æ˜“çœ‹å‡ºè¿™ä¸¤ä¸ªå‡½æ•°æ˜¯åœ¨`runtime`åŒ…ä¸­å®ç°çš„ï¼Œç„¶ååœ¨é“¾æ¥å™¨é“¾æ¥è¿‡æ¥çš„\n\nå…ˆæ¥çœ‹ä¸€ä¸‹`runtime_pollServerInit`å®ç°ï¼š\n\n```go\nfunc poll_runtime_pollServerInit() {\n\tnetpollinit()\n\tatomic.Store(&netpollInited, 1)\n}\n\nfunc netpollinit() {\n    // æ‰§è¡Œç³»ç»Ÿè°ƒç”¨åˆ›å»ºepoll\n    // å…ˆå°è¯•ä½¿ç”¨create1ç³»ç»Ÿè°ƒç”¨\n\tepfd = epollcreate1(_EPOLL_CLOEXEC)\n\tif epfd >= 0 {\n\t\treturn\n\t}\n    // è¿™è¾¹çš„1024æ˜¯å†å²åŸå› ï¼Œåªè¦å¤§äº0å°±å¥½äº†\n    // åŸå…ˆepollåº•å±‚ä½¿ç”¨hashè¡¨å®ç°ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªsizeæŒ‡å®šhashè¡¨çš„å¤§å°ï¼Œåé¢åŸºäºrb-treeå®ç°ï¼Œå› æ­¤è¿™ä¸ªå‚æ•°æ²¡æœ‰å®é™…æ„ä¹‰äº†ï¼Œå¤§äº0å³å¯\n\tepfd = epollcreate(1024)\n\tif epfd >= 0 {\n\t\tcloseonexec(epfd)\n\t\treturn\n\t}\n\tprintln(\"runtime: epollcreate failed with\", -epfd)\n\tthrow(\"runtime: netpollinit failed\")\n}\n```\n\nå¾ˆç®€å•ï¼Œå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ª`epoll`\n\nå†æ¥çœ‹ä¸€ä¸‹`runtime_pollOpen`çš„å®ç°ï¼š\n\n```go\nfunc poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {\n\t// åˆ†é…ä¸€ä¸ªpollDescï¼Œè¿™ä¸ªpollDescæ˜¯runtimeçš„pollDescï¼Œå’Œä¸Šé¢çš„pollDescä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼Œä½†æ˜¯ä»–ä»¬ä¹‹é—´åˆæœ‰å…³è”\n    pd := pollcache.alloc()\n\tlock(&pd.lock)\n\tif pd.wg != 0 && pd.wg != pdReady {\n\t\tthrow(\"runtime: blocked write on free polldesc\")\n\t}\n\tif pd.rg != 0 && pd.rg != pdReady {\n\t\tthrow(\"runtime: blocked read on free polldesc\")\n\t}\n\tpd.fd = fd\n\tpd.closing = false\n\tpd.seq++\n\tpd.rg = 0\n\tpd.rd = 0\n\tpd.wg = 0\n\tpd.wd = 0\n\tunlock(&pd.lock)\n\n\tvar errno int32\n\terrno = netpollopen(fd, pd)\n    // è¿™é‡Œè¿”å›äº†pdçš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯poll.pollDescä¸­çš„runtimeCtxå®é™…ä¸Šä¿å­˜çš„å°±æ˜¯runtime.pollDescçš„åœ°å€\n\treturn pd, int(errno)\n}\n\nfunc netpollopen(fd uintptr, pd *pollDesc) int32 {\n\tvar ev epollevent\n    // è®¾ç½®éœ€è¦é€šçŸ¥çš„å®é™…ç±»å‹ï¼Œè¿™é‡Œè®¾ç½®äº†è¾¹ç¼˜è§¦å‘æ¨¡å¼ï¼Œå…³äºepollçš„è¾¹ç¼˜è§¦å‘å’Œæ°´å¹³è§¦å‘æ¨¡å¼å¯ä»¥ç½‘ä¸Šæœ‰ä¸€å †çš„èµ„æ–™\n\tev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET\n    // å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡ŒæŠŠpollDescçš„åœ°å€å­˜åˆ°äº†ev.Dataä¸­\n\t*(**pollDesc)(unsafe.Pointer(&ev.data)) = pd\n    // æ‰§è¡Œepollctlç³»ç»Ÿè°ƒç”¨ï¼Œæ·»åŠ socketåˆ°epollä¸­\n\treturn -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &ev)\n}\n```\n\nè‡³æ­¤ä¸€ä¸ª`net.Listener`å°±åˆ›å»ºå®Œæˆäº†ï¼Œæ€»ç»“ä¸€ä¸‹ä¸»è¦çš„é€»è¾‘ï¼š\n\n1. åˆ›å»ºä¸€ä¸ªéé˜»å¡`socket`ï¼Œå¹¶æ‰§è¡Œ`bind`å’Œ`listen`\n2. å¦‚æœæ²¡æœ‰åˆå§‹åŒ–è¿‡`runtime`åŒ…çš„`epoll`ï¼Œåˆ™æ‰§è¡Œåˆå§‹åŒ–ï¼Œåˆ›å»ºä¸€ä¸ª`epoll`\n3. ä»¥è¾¹ç¼˜è§¦å‘æ¨¡å¼å°†`socket`æ·»åŠ åˆ°`epoll`ä¸­\n4. è¿”å›å°è£…åçš„`net.Listener`\n\n### Acceptåˆæ˜¯å¦‚ä½•æ‰§è¡Œçš„å‘¢\n\næ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ‰§è¡Œ`Accept`æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆ\n\n```go\nfunc (l *TCPListener) Accept() (Conn, error) {\n\tif !l.ok() {\n\t\treturn nil, syscall.EINVAL\n\t}\n\tc, err := l.accept()\n\tif err != nil {\n\t\treturn nil, &OpError{Op: \"accept\", Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}\n\t}\n\treturn c, nil\n}\n\nfunc (ln *TCPListener) accept() (*TCPConn, error) {\n\tfd, err := ln.fd.accept()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newTCPConn(fd), nil\n}\n```\n\næˆ‘ä»¬ä¸Šé¢åˆ›å»ºçš„æ˜¯ä¸€ä¸ª`TcpListener`ï¼Œå› æ­¤è‡ªç„¶æ˜¯æ‰§è¡Œå¯¹åº”çš„`Accept`ï¼Œå¯ä»¥çœ‹åˆ°æ˜¯è°ƒç”¨`netFD.Accept`ï¼š\n\n```go\nfunc (fd *netFD) accept() (netfd *netFD, err error) {\n    // æ‰§è¡Œpoll.FDçš„Acceptæ–¹æ³•ï¼Œè·å–æ–°çš„å®¢æˆ·ç«¯è¿æ¥\n\td, rsa, errcall, err := fd.pfd.Accept()\n\tif err != nil {\n\t\tif errcall != \"\" {\n\t\t\terr = wrapSyscallError(errcall, err)\n\t\t}\n\t\treturn nil, err\n\t}\n\t// å°è£…netFD\n\tif netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != nil {\n\t\tpoll.CloseFunc(d)\n\t\treturn nil, err\n\t}\n    // è¿™é‡Œçš„netFD.initä¸Šé¢åˆ†æè¿‡äº†ï¼Œå°±æ˜¯å°†æ–°çš„socketåŠ å…¥åˆ°epollä¸­\n\tif err = netfd.init(); err != nil {\n\t\tfd.Close()\n\t\treturn nil, err\n\t}\n\tlsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)\n\tnetfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))\n\treturn netfd, nil\n}\n```\n\næ¥ä¸‹æ¥çœ‹ä¸€ä¸‹`poll.FD`çš„`Accept`æ–¹æ³•ï¼š\n\n```go\nfunc (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {\n    // å°è¯•åŠ é”\n\tif err := fd.readLock(); err != nil {\n\t\treturn -1, nil, \"\", err\n\t}\n\tdefer fd.readUnlock()\n    \n\tif err := fd.pd.prepareRead(fd.isFile); err != nil {\n\t\treturn -1, nil, \"\", err\n\t}\n\tfor {\n        /// é¦–å…ˆå°è¯•ç›´æ¥è·å–å®¢æˆ·ç«¯è¿æ¥\n\t\ts, rsa, errcall, err := accept(fd.Sysfd)\n\t\tif err == nil { // è·å–æˆåŠŸï¼Œç›´æ¥è¿”å›\n\t\t\treturn s, rsa, \"\", err\n\t\t}\n\t\tswitch err {\n            // å› ä¸ºæˆ‘ä»¬åˆ›å»ºçš„socketæ˜¯éé˜»å¡çš„ï¼Œå½“æ²¡æœ‰æ–°çš„è¿æ¥å¯ä»¥acceptæ—¶ä¼šç›´æ¥è¿”å›EAGAINè€Œä¸æ˜¯é˜»å¡\n\t\tcase syscall.EAGAIN:\n            // å¦‚æœæ˜¯å¯è½®è¯¢çš„ï¼Œè¡¨æ˜å¯ä»¥ç­‰åˆ°epolläº‹ä»¶é€šçŸ¥\n\t\t\tif fd.pd.pollable() {\n                // \n\t\t\t\tif err = fd.pd.waitRead(fd.isFile); err == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\tcase syscall.ECONNABORTED:\n\t\t\t// This means that a socket on the listen\n\t\t\t// queue was closed before we Accept()ed it;\n\t\t\t// it's a silly error, so try again.\n\t\t\tcontinue\n\t\t}\n\t\treturn -1, nil, errcall, err\n\t}\n}\n\nfunc accept(s int) (int, syscall.Sockaddr, string, error) {\n    // var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4\n    // é¦–å…ˆä½¿ç”¨ç³»ç»Ÿè°ƒç”¨accept4è·å–ä¸€ä¸ªéé˜»å¡çš„socket\n\tns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)\n\tswitch err {\n\tcase nil:\n\t\treturn ns, sa, \"\", nil\n\tdefault: // errors other than the ones listed\n\t\treturn -1, sa, \"accept4\", err\n\tcase syscall.ENOSYS: // syscall missing\n\tcase syscall.EINVAL: // some Linux use this instead of ENOSYS\n\tcase syscall.EACCES: // some Linux use this instead of ENOSYS\n\tcase syscall.EFAULT: // some Linux use this instead of ENOSYS\n\t}\n\t// æœ‰äº›å†…æ ¸ä¸æ”¯æŒaccept4\n\tns, sa, err = AcceptFunc(s)\n\tif err == nil {\n\t\tsyscall.CloseOnExec(ns)\n\t}\n\tif err != nil {\n\t\treturn -1, nil, \"accept\", err\n\t}\n    // è®¾ç½®éé˜»å¡æ¨¡å¼\n\tif err = syscall.SetNonblock(ns, true); err != nil {\n\t\tCloseFunc(ns)\n\t\treturn -1, nil, \"setnonblock\", err\n\t}\n\treturn ns, sa, \"\", nil\n}\n```\n\næ¥ç€æ¥çœ‹`pollDesc.waitRead`å®ç°ï¼š\n\n```go\nfunc (pd *pollDesc) waitRead(isFile bool) error {\n\treturn pd.wait('r', isFile)\n}\n\nfunc (pd *pollDesc) wait(mode int, isFile bool) error {\n\tif pd.runtimeCtx == 0 {\n\t\treturn errors.New(\"waiting for unsupported file type\")\n\t}\n    // åˆæ˜¯ä¸€ä¸ªruntimeåŒ…çš„æ–¹æ³•\n\tres := runtime_pollWait(pd.runtimeCtx, mode)\n\treturn convertErr(res, isFile)\n}\n```\n\næ¥ç€çœ‹ä¸€ä¸‹`runtime_pollWait`å®ç°ï¼š\n\n```go\nfunc poll_runtime_pollWait(pd *pollDesc, mode int) int {\n\terr := netpollcheckerr(pd, int32(mode))\n\tif err != 0 {\n\t\treturn err\n\t}\n\t// As for now only Solaris uses level-triggered IO.\n\tif GOOS == \"solaris\" {\n\t\tnetpollarm(pd, mode)\n\t}\n    // å®é™…å¹²æ´»çš„æ˜¯netpollblock\n\tfor !netpollblock(pd, int32(mode), false) {\n\t\terr = netpollcheckerr(pd, int32(mode))\n\t\tif err != 0 {\n\t\t\treturn err\n\t\t}\n\t\t// Can happen if timeout has fired and unblocked us,\n\t\t// but before we had a chance to run, timeout has been reset.\n\t\t// Pretend it has not happened and retry.\n\t}\n\treturn 0\n}\n\nfunc netpollblock(pd *pollDesc, mode int32, waitio bool) bool {\n    // è¿™é‡Œå¦‚æœæ˜¯'r'æ¨¡å¼ï¼Œåˆ™gppæ˜¯&pd.rg\n    // 'w'æ¨¡å¼åˆ™æ˜¯'&pd.wg'\n\tgpp := &pd.rg\n\tif mode == 'w' {\n\t\tgpp = &pd.wg\n\t}\n\n\t// casæ“ä½œï¼Œè®¾ç½®gppä¸ºpdwait\n\tfor {\n\t\told := *gpp\n\t\tif old == pdReady {\n\t\t\t*gpp = 0\n\t\t\treturn true\n\t\t}\n\t\tif old != 0 {\n\t\t\tthrow(\"runtime: double wait\")\n\t\t}\n\t\tif atomic.Casuintptr(gpp, 0, pdWait) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// è¿™é‡Œç›´æ¥æ‰§è¡Œgoparkï¼Œå°†å½“å‰åç¨‹æŒ‚èµ· ^-^\n\tif waitio || netpollcheckerr(pd, mode) == 0 {\n        // è¿™é‡Œnetpollblockcommitä¼šè¢«è°ƒç”¨ï¼ŒæŠŠå½“å‰gçš„å¼•ç”¨ä¿å­˜åˆ°gppä¸­ï¼Œä¹Ÿå°±æ˜¯pollDescçš„rgæˆ–è€…wgä¸­\n\t\tgopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)\n\t}\n\t// be careful to not lose concurrent READY notification\n\told := atomic.Xchguintptr(gpp, 0)\n\tif old > pdWait {\n\t\tthrow(\"runtime: corrupted polldesc\")\n\t}\n\treturn old == pdReady\n}\n```\n\nè‡³æ­¤ï¼Œ`Accept`çš„æµç¨‹ä¹Ÿå¾ˆæ¸…æ™°äº†ï¼š\n\n1. é¦–å…ˆç›´æ¥å°è¯•é€šè¿‡`socket`æ‰§è¡Œ`accept`æ¥è·å–å¯èƒ½çš„å®¢æˆ·ç«¯è¿æ¥\n2. å¦‚æœæ­¤æ—¶å®¢æˆ·ç«¯æ²¡æœ‰è¿æ¥ï¼Œå› ä¸º`socket`æ˜¯éé˜»å¡æ¨¡å¼ï¼Œä¼šç›´æ¥è¿”å›`EAGAIN`\n3. è°ƒç”¨`runtime.poll_runtime_pollWait`å°†å½“å‰åç¨‹æŒ‚èµ·ï¼Œå¹¶ä¸”æ ¹æ®æ˜¯ç­‰å¾…è¯»è¿˜æ˜¯ç­‰å¾…å†™å°†å½“å‰`g`çš„å¼•ç”¨ä¿å­˜åˆ°`pollDesc`ä¸­çš„`rg`æˆ–è€…`wg`ä¸­\n4. å½“æœ‰æ–°çš„å®¢æˆ·ç«¯è¿æ¥åˆ°æ¥æ—¶ï¼Œ`epoll`ä¼šé€šçŸ¥å°†å½“å‰é˜»å¡çš„åç¨‹æ¢å¤ï¼Œç„¶åé‡æ–°æ‰§è¡Œç¬¬ä¸€æ­¥\n\n### é‚£ä¹ˆepollçš„waitåˆæ˜¯ä»€ä¹ˆæ—¶å€™è°ƒç”¨çš„å‘¢\n\næˆ‘ä»¬å¯ä»¥åœ¨åç¨‹çš„è°ƒåº¦é€»è¾‘ä¸­çœ‹åˆ°è¿™æ ·ä¸€æ®µä»£ç æ®µï¼š\n\n```go\n\tif netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {\n        // è¿™é‡Œçš„netpollçš„å‚æ•°falseè¡¨ç¤ºä¸é˜»å¡\n\t\tif gp := netpoll(false); gp != nil { \n            // è¿™é‡Œè·å–çš„å¯èƒ½æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå°†åé¢å¤šä½™çš„gåŠ å…¥è°ƒåº¦é˜Ÿåˆ—ï¼Œè¿™é‡Œè°ƒåº¦ä¸€æ¬¡åªèƒ½è°ƒåº¦ä¸€ä¸ª\n\t\t\tinjectglist(gp.schedlink.ptr())\n            // è®¾ç½®gä¸ºrunnable\n\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)\n\t\t\tif trace.enabled {\n\t\t\t\ttraceGoUnpark(gp, 0)\n\t\t\t}\n\t\t\treturn gp, false\n\t\t}\n\t}\n```\n\næˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`netpoll`çš„æ‰§è¡Œï¼š\n\n```go\nfunc netpoll(block bool) *g {\n\tif epfd == -1 {\n\t\treturn nil\n\t}\n\twaitms := int32(-1)\n    // è°ƒåº¦é€»è¾‘ä¸­ä¼ å…¥çš„æ˜¯0\n\tif !block {\n\t\twaitms = 0\n\t}\n\tvar events [128]epollevent\nretry:\n    // æ‰§è¡Œepoll_waitç³»ç»Ÿè°ƒç”¨\n\tn := epollwait(epfd, &events[0], int32(len(events)), waitms)\n\tif n < 0 {\n\t\tif n != -_EINTR {\n\t\t\tprintln(\"runtime: epollwait on fd\", epfd, \"failed with\", -n)\n\t\t\tthrow(\"runtime: netpoll failed\")\n\t\t}\n\t\tgoto retry\n\t}\n    // è¿™é‡Œgpæ˜¯ä¸€ä¸ªé“¾è¡¨\n\tvar gp guintptr\n\tfor i := int32(0); i < n; i++ {\n\t\tev := &events[i]\n\t\tif ev.events == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar mode int32\n\t\tif ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'r'\n\t\t}\n\t\tif ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {\n\t\t\tmode += 'w'\n\t\t}\n\t\tif mode != 0 {\n            // ä»ev.dataå–å‡ºpollDescï¼Œè¿˜è®°å¾—ä¸Šé¢åˆ†æè¿‡ï¼Œåœ¨åŠ å…¥epollæ—¶ä¼šæŠŠå¯¹åº”çš„pollDescä¿å­˜åˆ°ev.Dataä¸­ï¼Œè€Œåç¨‹é˜»å¡æ—¶ä¼šæŠŠgæŒ‡é’ˆä¿å­˜åœ¨pollDescä¸­çš„rgæˆ–è€…wgä¸­\n\t\t\tpd := *(**pollDesc)(unsafe.Pointer(&ev.data))\n\t\t\t// è¿™é‡Œæ‰§è¡Œnetpollreadyï¼ŒæŠŠå¯¹åº”é˜»å¡çš„gåŠ åˆ°gpé“¾è¡¨å¤´éƒ¨\n\t\t\tnetpollready(&gp, pd, mode)\n\t\t}\n\t}\n\tif block && gp == 0 {\n\t\tgoto retry\n\t}\n\treturn gp.ptr()\n}\n\nfunc netpollready(gpp *guintptr, pd *pollDesc, mode int32) {\n\tvar rg, wg guintptr\n\tif mode == 'r' || mode == 'r'+'w' {\n        // è¿™é‡Œè°ƒç”¨äº†netpollunblockï¼Œè·å–å¯¹åº”çš„g\n\t\trg.set(netpollunblock(pd, 'r', true))\n\t}\n\tif mode == 'w' || mode == 'r'+'w' {\n\t\twg.set(netpollunblock(pd, 'w', true))\n\t}\n    // é“¾è¡¨è®¾ç½®ï¼Œå°†æ–°çš„gæ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨\n\tif rg != 0 {\n\t\trg.ptr().schedlink = *gpp\n\t\t*gpp = rg\n\t}\n\tif wg != 0 {\n\t\twg.ptr().schedlink = *gpp\n\t\t*gpp = wg\n\t}\n}\n\nfunc netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {\n    // å¦‚æœæ˜¯ç­‰å¾…è¯»åˆ™rgæ˜¯é˜»å¡çš„gçš„å¼•ç”¨\n    // å¦‚æœæ˜¯ç­‰å¾…å†™åˆ™wgæ˜¯é˜»å¡çš„gçš„å¼•ç”¨\n\tgpp := &pd.rg\n\tif mode == 'w' {\n\t\tgpp = &pd.wg\n\t}\n\n\tfor {\n\t\told := *gpp\n\t\tif old == pdReady {\n\t\t\treturn nil\n\t\t}\n\t\tif old == 0 && !ioready {\n\t\t\t// Only set READY for ioready. runtime_pollWait\n\t\t\t// will check for timeout/cancel before waiting.\n\t\t\treturn nil\n\t\t}\n\t\tvar new uintptr\n\t\tif ioready {\n\t\t\tnew = pdReady\n\t\t}\n        // çŠ¶æ€ä¸ºready\n\t\tif atomic.Casuintptr(gpp, old, new) {\n\t\t\tif old == pdReady || old == pdWait {\n\t\t\t\told = 0\n\t\t\t}\n\t\t\treturn (*g)(unsafe.Pointer(old))\n\t\t}\n\t}\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œåœ¨æ‰§è¡Œåç¨‹çš„è°ƒåº¦æ—¶ï¼Œä¼šæ‰§è¡Œ`epoll_wait`ç³»ç»Ÿè°ƒç”¨ï¼Œè·å–å·²ç»å‡†å¤‡å¥½çš„`socket`ï¼Œå¹¶å”¤é†’å¯¹åº”çš„`goroutine`\n\né™¤äº†åœ¨è°ƒåº¦æ—¶ä¼šæ‰§è¡Œ`epoll_wait`ï¼Œåœ¨åå°çº¿ç¨‹`sysmon`ä¸­ä¹Ÿä¼šå®šæ—¶æ‰§è¡Œ`epoll_wait`ï¼š\n\n```go\nfunc sysmon() {\n\t...\n\tfor {\n\t\t...\n\t\tif netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {\n\t\t\tatomic.Cas64(&sched.lastpoll, uint64(lastpoll), uint64(now))\n\t\t\tgp := netpoll(false) // non-blocking - returns list of goroutines\n\t\t\tif gp != nil {\n\t\t\t\tincidlelocked(-1)\n\t\t\t\tinjectglist(gp)\n\t\t\t\tincidlelocked(1)\n\t\t\t}\n\t\t}\n\t\t...\n\t}\n}\n```\n\n### å¤§åŒå°å¼‚çš„è¯»å†™æ“ä½œ\n\né‚£ä¹ˆæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`Read`æ“ä½œï¼Œå®é™…ä¸Š`Read`æœ€åä¼šæ‰§è¡Œ\n\n```go\nfunc (c *conn) Read(b []byte) (int, error) {\n   if !c.ok() {\n      return 0, syscall.EINVAL\n   }\n   n, err := c.fd.Read(b)\n   if err != nil && err != io.EOF {\n      err = &OpError{Op: \"read\", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}\n   }\n   return n, err\n}\n\nfunc (fd *netFD) Read(p []byte) (n int, err error) {\n\tn, err = fd.pfd.Read(p)\n\truntime.KeepAlive(fd)\n\treturn n, wrapSyscallError(\"read\", err)\n}\n```\n\næœ€ååˆ°äº†`poll.FD`çš„`Read`æ–¹æ³•ï¼š\n\n```go\nfunc (fd *FD) Read(p []byte) (int, error) {\n    // è¿™é‡Œæ‰§è¡Œå¯¹åº”çš„åŠ é”æ“ä½œ\n\t...\n\tfor {\n        // é¦–å…ˆå°è¯•ç›´æ¥è¯»ï¼Œå¦‚æœæ— å¯è¯»å†…å®¹ï¼Œå› ä¸ºæ˜¯éé˜»å¡æ¨¡å¼ï¼Œä¼šè¿”å›EAGAIN\n\t\tn, err := syscall.Read(fd.Sysfd, p)\n\t\tif err != nil {\n\t\t\tn = 0\n\t\t\tif err == syscall.EAGAIN && fd.pd.pollable() {\n                // è¿™é‡Œçš„waitReadæœ‰æ²¡æœ‰ä¼¼æ›¾ç›¸è¯†ï¼Ÿè¿™ä¸ªæ–¹æ³•åœ¨acceptæµç¨‹çš„æ—¶å€™å·²ç»åˆ†æè¿‡äº†ï¼Œæœ€åä¼šå°†å½“å‰åç¨‹æŒ‚èµ·\n\t\t\t\tif err = fd.pd.waitRead(fd.isFile); err == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// On MacOS we can see EINTR here if the user\n\t\t\t// pressed ^Z.  See issue #22838.\n\t\t\tif runtime.GOOS == \"darwin\" && err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\terr = fd.eofError(n, err)\n\t\treturn n, err\n\t}\n}\n```\n\nå†æ¥çœ‹ä¸€ä¸‹å†™è¿‡ç¨‹ï¼Œæœ€åä¼šæ‰§è¡Œï¼š\n\n```go\nfunc (fd *FD) Write(p []byte) (int, error) {\n    // è¿™é‡Œæ‰§è¡Œå¯¹åº”çš„åŠ é”æ“ä½œ\n\t...\n    // è®°å½•å·²ç»å†™å…¥å­—èŠ‚æ•°\n\tvar nn int\n\tfor {\n\t\tmax := len(p)\n\t\tif fd.IsStream && max-nn > maxRW {\n\t\t\tmax = nn + maxRW\n\t\t}\n\t\tn, err := syscall.Write(fd.Sysfd, p[nn:max])\n\t\tif n > 0 {\n\t\t\tnn += n\n\t\t}\n        // å†™å…¥æ–¹æ³•ä¸è¯»æ–¹æ³•çš„åŒºåˆ«åœ¨äºï¼Œè¯»æ–¹æ³•åªè¦è¯»å–åˆ°å†…å®¹å°±ä¼šè¿”å›\n        // è€Œå†™å…¥éœ€è¦å°†ä¼ å…¥çš„å­—èŠ‚åˆ‡ç‰‡å…¨éƒ¨å†™å…¥æ‰è¿”å›\n\t\tif nn == len(p) {\n\t\t\treturn nn, err\n\t\t}\n        // è¿™é‡Œçš„waitWriteå’Œä¸Šé¢çš„waitReadç±»ä¼¼\n\t\tif err == syscall.EAGAIN && fd.pd.pollable() {\n\t\t\tif err = fd.pd.waitWrite(fd.isFile); err == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nn, err\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn nn, io.ErrUnexpectedEOF\n\t\t}\n\t}\n}\n\n// å…¶å®æœ€åéƒ½æ˜¯è°ƒç”¨çš„pd.wait\nfunc (pd *pollDesc) waitWrite(isFile bool) error {\n\treturn pd.wait('w', isFile)\n}\n\n// æœ€ç»ˆè°ƒç”¨runtime_pollWaitå°†å½“å‰åç¨‹æŒ‚èµ·\nfunc (pd *pollDesc) wait(mode int, isFile bool) error {\n\tif pd.runtimeCtx == 0 {\n\t\treturn errors.New(\"waiting for unsupported file type\")\n\t}\n\tres := runtime_pollWait(pd.runtimeCtx, mode)\n\treturn convertErr(res, isFile)\n}\n```\n\n### å·®ç‚¹è¢«é—å¿˜çš„close\n\næ¥ç€æ¥çœ‹ä¸€ä¸‹`Close`æ–¹æ³•ï¼Œå®é™…æ‰§è¡Œçš„æ˜¯ï¼š\n\n```go\nfunc (c *conn) Close() error {\n\tif !c.ok() {\n\t\treturn syscall.EINVAL\n\t}\n    // è¿™é‡Œæ‰§è¡ŒnetFD.Close\n\terr := c.fd.Close()\n\tif err != nil {\n\t\terr = &OpError{Op: \"close\", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}\n\t}\n\treturn err\n}\n\nfunc (fd *netFD) Close() error {\n    // æ¸…é™¤finalizer\n\truntime.SetFinalizer(fd, nil)\n    // è°ƒç”¨poll.FDçš„Closeæ–¹æ³•\n\treturn fd.pfd.Close()\n}\n\n\nfunc (fd *FD) Close() error {\n\tif !fd.fdmu.increfAndClose() {\n\t\treturn errClosing(fd.isFile)\n\t}\n\n\t// è¿™é‡Œevictæ–¹æ³•å”¤é†’æ‰€æœ‰é˜»å¡è¯»å†™çš„g\n\tfd.pd.evict()\n\t// å‡å°‘å¼•ç”¨ï¼Œå¦‚æœå¼•ç”¨ä¸º0åˆ™å…³é—­\n\terr := fd.decref()\n\n\tif fd.isBlocking == 0 {\n\t\truntime_Semacquire(&fd.csema)\n\t}\n\n\treturn err\n}\n\nfunc (pd *pollDesc) evict() {\n\tif pd.runtimeCtx == 0 {\n\t\treturn\n\t}\n\truntime_pollUnblock(pd.runtimeCtx)\n}\n\nfunc poll_runtime_pollUnblock(pd *pollDesc) {\n\tlock(&pd.lock)\n\tif pd.closing {\n\t\tthrow(\"runtime: unblock on closing polldesc\")\n\t}\n\tpd.closing = true\n\tpd.seq++\n\tvar rg, wg *g\n\tatomicstorep(unsafe.Pointer(&rg), nil)\n    // è·å–é˜»å¡çš„g\n\trg = netpollunblock(pd, 'r', false)\n\twg = netpollunblock(pd, 'w', false)\n\tif pd.rt.f != nil {\n\t\tdeltimer(&pd.rt)\n\t\tpd.rt.f = nil\n\t}\n\tif pd.wt.f != nil {\n\t\tdeltimer(&pd.wt)\n\t\tpd.wt.f = nil\n\t}\n\tunlock(&pd.lock)\n\tif rg != nil {\n        // è°ƒç”¨goreadyå”¤é†’g\n\t\tnetpollgoready(rg, 3)\n\t}\n\tif wg != nil {\n        // å”¤é†’g\n\t\tnetpollgoready(wg, 3)\n\t}\n}\n\n\nfunc (fd *FD) decref() error {\n\t// å‡å°‘å¼•ç”¨ï¼Œå¦‚æœå¼•ç”¨ä¸º0ï¼Œåˆ™è¿”å›true\n    if fd.fdmu.decref() {\n        // å…³é—­è¿æ¥\n\t\treturn fd.destroy()\n\t}\n\treturn nil\n}\n\nfunc (fd *FD) destroy() error {\n\t// è°ƒç”¨runtime_pollCloseæ–¹æ³•\n\tfd.pd.close()\n    // var CloseFunc func(int) error = syscall.Close\n    // è¿™é‡Œçš„CloseFuncå°±æ˜¯ç³»ç»Ÿè°ƒç”¨close\n\terr := CloseFunc(fd.Sysfd)\n\tfd.Sysfd = -1\n\truntime_Semrelease(&fd.csema)\n\treturn err\n}\n\nfunc (pd *pollDesc) close() {\n\tif pd.runtimeCtx == 0 {\n\t\treturn\n\t}\n\truntime_pollClose(pd.runtimeCtx)\n\tpd.runtimeCtx = 0\n}\n\nfunc poll_runtime_pollClose(pd *pollDesc) {\n\tif !pd.closing {\n\t\tthrow(\"runtime: close polldesc w/o unblock\")\n\t}\n\tif pd.wg != 0 && pd.wg != pdReady {\n\t\tthrow(\"runtime: blocked write on closing polldesc\")\n\t}\n\tif pd.rg != 0 && pd.rg != pdReady {\n\t\tthrow(\"runtime: blocked read on closing polldesc\")\n\t}\n    // ä»epollä¸­åˆ é™¤fd\n\tnetpollclose(pd.fd)\n    // é‡Šæ”¾pollDesc\n\tpollcache.free(pd)\n}\n\nfunc netpollclose(fd uintptr) int32 {\n\tvar ev epollevent\n    // ç³»ç»Ÿè°ƒç”¨epoll_ctlåˆ é™¤å¯¹åº”çš„fd\n\treturn -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), &ev)\n}\n```\n\nç»¼ä¸Šï¼Œå…³é—­ä¸€ä¸ªè¿æ¥æ—¶ï¼š\n\n1. è®¾ç½®pollDescç›¸å…³flagä¸ºå·²å…³é—­ï¼Œå”¤é†’è¯¥è¿æ¥ä¸Šé˜»å¡çš„åç¨‹\n2. å‡å°‘å¯¹åº”poll.FDçš„å¼•ç”¨ï¼Œå¦‚æœå¼•ç”¨ä¸º0ï¼Œåˆ™åªéœ€çœŸæ­£çš„å…³é—­\n3. æ‰§è¡Œå…³é—­æ“ä½œï¼Œå…ˆä»epollåˆ é™¤å¯¹åº”çš„fdï¼Œç„¶åæ‰§è¡Œcloseç³»ç»Ÿè°ƒç”¨å…³é—­\n\n### æœ€å\n\nå¯ä»¥çœ‹åˆ°ï¼Œ`go`ä½¿ç”¨éé˜»å¡IOæ¥é˜²æ­¢å¤§é‡ç³»ç»Ÿçº¿ç¨‹é˜»å¡å¸¦æ¥çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯è®©è½»é‡çº§çš„åç¨‹é˜»å¡åœ¨IOäº‹ä»¶ä¸Šï¼Œç„¶åé€šè¿‡`epoll`æ¥å®ç°IOäº‹ä»¶é€šçŸ¥ï¼Œå”¤é†’é˜»å¡çš„åç¨‹ã€‚","tags":["go"]},{"title":"golangå†…å­˜é€ƒé€¸","url":"/2019/03/31/golangå†…å­˜é€ƒé€¸/","content":"\n`golang`ä¸­ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶ä¼šé€šè¿‡å†…å­˜é€ƒé€¸åˆ†æç¡®å®šå˜é‡åˆ†é…åœ¨å †ä¸Šè¿˜æ˜¯æ ˆä¸Šã€‚\n\n```go\ntype Dog struct {\n}\n\nfunc (d *Dog) Eat() {\n}\n\ntype Animal interface {\n\tEat()\n}\n\nfunc main() {\n\tdog1 := new(Dog)\n\tnoneEscape(dog1)\n\tnop(dog1)\n\tdog2 := new(Dog)\n\tescape(dog2)\n\tdog3 := Dog{}\n\tfmt.Println(&dog3)\n}\n\n//go:noinline\nfunc nop( a Animal){\n}\n\n//go:noinline\nfunc noneEscape(d *Dog) {\n\td.Eat()\n}\n\n//go:noinline\nfunc escape(a Animal) {\n\ta.Eat()\n}\n\n```\n\nå¯ä»¥é€šè¿‡`--gcflags=\"-m -m\"`å‚æ•°ï¼Œåœ¨ç¼–è¯‘æ—¶æ‰“å°å‡ºå†…å­˜é€ƒé€¸åˆ†æä¿¡æ¯ï¼Œ`-m`æœ€å¤šå¯ä»¥æŒ‡å®šå››ä¸ªï¼Œè¶Šå¤šæ‰“å°çš„ä¿¡æ¯è¶Šè¯¦ç»†ã€‚ä¸Šé¢ä»£ç ä¸­çš„`go:noinline`ç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨ç¦æ­¢å¯¹è¯¥å‡½æ•°è¿›è¡Œå†…è”ä¼˜åŒ–ã€‚\n\nè¿è¡Œï¼š\n\n```sh\n$ go build -gcflags=\"-m -m\" .\n```\n\næŸ¥çœ‹æ‰“å°ç»“æœï¼š\n\n```\n# just-for-fun/escape\n.\\main.go:8:6: can inline (*Dog).Eat as: method(*Dog) func() {  }\n.\\main.go:30:6: cannot inline noneEscape: marked go:noinline\n.\\main.go:31:7: inlining call to (*Dog).Eat method(*Dog) func() {  }\n.\\main.go:26:6: cannot inline nop: marked go:noinline\n.\\main.go:35:6: cannot inline escape: marked go:noinline\n.\\main.go:15:6: cannot inline main: function too complex: cost 355 exceeds budget 80\n.\\main.go:8:7: (*Dog).Eat d does not escape\n.\\main.go:30:17: noneEscape d does not escape\n.\\main.go:26:11: nop a does not escape\n.\\main.go:35:13: leaking param: a\n.\\main.go:35:13:        from a.Eat() (receiver in indirect call) at .\\main.go:36:7\n.\\main.go:20:8: dog2 escapes to heap\n.\\main.go:20:8:         from dog2 (passed to call[argument escapes]) at .\\main.go:20:8\n.\\main.go:19:13: new(Dog) escapes to heap\n.\\main.go:19:13:        from dog2 (assigned) at .\\main.go:19:7\n.\\main.go:19:13:        from dog2 (interface-converted) at .\\main.go:20:8\n.\\main.go:19:13:        from dog2 (passed to call[argument escapes]) at .\\main.go:20:8\n.\\main.go:22:14: &dog3 escapes to heap\n.\\main.go:22:14:        from ... argument (arg to ...) at .\\main.go:22:13\n.\\main.go:22:14:        from *(... argument) (indirection) at .\\main.go:22:13\n.\\main.go:22:14:        from ... argument (passed to call[argument content escapes]) at .\\main.go:22:13\n.\\main.go:22:14: &dog3 escapes to heap\n.\\main.go:22:14:        from &dog3 (interface-converted) at .\\main.go:22:14\n.\\main.go:22:14:        from ... argument (arg to ...) at .\\main.go:22:13\n.\\main.go:22:14:        from *(... argument) (indirection) at .\\main.go:22:13\n.\\main.go:22:14:        from ... argument (passed to call[argument content escapes]) at .\\main.go:22:13\n.\\main.go:21:2: moved to heap: dog3\n.\\main.go:16:13: main new(Dog) does not escape\n.\\main.go:18:5: main dog1 does not escape\n.\\main.go:22:13: main ... argument does not escape\n<autogenerated>:1: leaking param: .this\n<autogenerated>:1:      from .this.Eat() (receiver in indirect call) at <autogenerated>:1\n```\n\nä»ä¸Šé¢çš„ä¿¡æ¯ä¸­å¯ä»¥çœ‹åˆ°ï¼Œ`dog1`åˆ†é…åœ¨æ ˆä¸Šï¼Œè€Œ`dog2`å’Œ`dog3`éƒ½åˆ†é…åœ¨å †ä¸Šã€‚\n\n`dog1`åœ¨æ–¹æ³•`noneEscape`ä¸­ï¼Œè°ƒç”¨äº†`Eat`æ–¹æ³•ï¼Œå› ä¸º`Eat`æ–¹æ³•å¹¶æ²¡æœ‰å‘ç”Ÿå†…å­˜é€ƒé€¸ï¼Œå› æ­¤`dog1`åœ¨`noneEscape`ä¸­æ²¡æœ‰å†…å­˜é€ƒé€¸ã€‚è€Œ`nop`æ–¹æ³•å†…`dog1`æ²¡æœ‰æ‰§è¡Œä»»ä½•æ“ä½œï¼Œä¹Ÿä¸ä¼šå‘ç”Ÿå†…å­˜é€ƒé€¸ã€‚å¯è§ï¼Œå³ä½¿æ˜¯ä½¿ç”¨`new`åˆ†é…çš„å˜é‡ï¼Œä¹Ÿä¸ä¸€å®šæ˜¯åˆ†é…åœ¨å †ä¸Šã€‚\n\nè€Œ`dog2`åœ¨æ–¹æ³•`escape`ä¸­ï¼Œè°ƒç”¨äº†`Eat`æ–¹æ³•ï¼Œå› ä¸ºè¿™æ—¶å€™`dog2`æ˜¯`Animal`æ¥å£ç±»å‹ï¼Œ`golang`ä¸­æ¥å£ç±»å‹çš„æ–¹æ³•æ˜¯åŠ¨æ€æ´¾å‘çš„ï¼Œç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“å…·ä½“è°ƒç”¨çš„æ˜¯å“ªä¸ª`Eat`æ–¹æ³•ï¼Œä»è€Œæ— æ³•ç¡®å®š`dog2`åœ¨`Eat`æ˜¯å¦æœ‰å‘ç”Ÿå†…å­˜é€ƒé€¸ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸º`dog2`å‘ç”Ÿäº†å†…å­˜é€ƒé€¸ï¼Œå¹¶å°†å…¶åˆ†é…åœ¨å †ä¸Šã€‚å¦‚æœç¼–è¯‘å™¨èƒ½å¤Ÿåœ¨ç¼–è¯‘æ—¶å°±å¯¹æ¥å£çš„å®é™…ç±»å‹è¿›è¡Œåˆ†æï¼Œå¯¹`Eat`æ–¹æ³•è¿›è¡Œé™æ€æ´¾å‘ï¼Œå°±å¯ä»¥å‘ç°`dog2`å¹¶æ²¡æœ‰å†…å­˜é€ƒé€¸ã€‚\n\n\n\n### fun thing\n\nä»£ç 1ï¼š\n\n```go\nfunc main() {\n   byts := []byte(\"\")\n   s1 := append(byts,'a')\n   s2:= append(byts,'b')\n   fmt.Println(string(s1),string(s2)) // b b\n}\n```\n\nä»£ç 2ï¼š\n\n```go\nfunc main() {\n   byts := []byte(\"\")\n   s1 := append(byts,'a')\n   s2:= append(byts,'b')\n   fmt.Println(byts)\n   fmt.Println(string(s1),string(s2)) // a b\n}\n```\n\nè§‚å¯Ÿä¸Šé¢ä¸¤ä¸ªç¨‹åºï¼Œåªæ˜¯æ·»åŠ äº†ä¸€è¡Œä»£ç ï¼Œä¸¤æ¬¡æ‰§è¡Œç»“æ„å´å®Œå…¨ä¸åŒã€‚å¯¼è‡´ç»“æœå®Œå…¨ä¸åŒçš„åŸå› åœ¨äºï¼Œ`fmt.Println(byts)`å¯¼è‡´`byts`é€ƒè„±åˆ°å †ä¸Šã€‚\n\næŸ¥çœ‹ä¸¤ä»½ä»£ç ç¼–è¯‘åçš„`[]byte(\"\")`å¯¹åº”çš„æ±‡ç¼–ä»£ç ç‰‡æ®µï¼š\n\nä»£ç 1ï¼š\n\n```asm\n0x0036 00054 (main.go:6)\tLEAQ\t\"\"..autotmp_6+120(SP), AX\n0x003b 00059 (main.go:6)\tPCDATA\t$2, $0\n0x003b 00059 (main.go:6)\tMOVQ\tAX, (SP)\n0x003f 00063 (main.go:6)\tXORPS\tX0, X0\n0x0042 00066 (main.go:6)\tMOVUPS\tX0, 8(SP)\n0x0047 00071 (main.go:6)\tCALL\truntime.stringtoslicebyte(SB)\n```\n\nä»£ç 2ï¼š\n\n```asm\n0x0036 00054 (main.go:6)\tMOVQ\t$0, (SP)\n0x003e 00062 (main.go:6)\tXORPS\tX0, X0\n0x0041 00065 (main.go:6)\tMOVUPS\tX0, 8(SP)\n0x0046 00070 (main.go:6)\tCALL\truntime.stringtoslicebyte(SB)\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œä¸¤æ¬¡è°ƒç”¨`runtime.stringtoslicebyte`æ—¶ä¼ é€’çš„å‚æ•°ä¸åŒï¼Œç¬¬ä¸€æ¬¡çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯éç©ºçš„ï¼Œè€Œç¬¬äºŒæ¬¡çš„ç¬¬ä¸€æ¬¡å‚æ•°çš„ç©ºçš„ï¼ŒæŸ¥çœ‹è¯¥å‡½æ•°å®ç°ï¼š\n\n```go\nconst tmpStringBufSize = 32\n\ntype tmpBuf [tmpStringBufSize]byte\n\nfunc stringtoslicebyte(buf *tmpBuf, s string) []byte {\n\tvar b []byte\n    // å¦‚æœbufä¸ä¸ºç©ºï¼Œå¹¶ä¸”len(buf)å°äºlen(s)ï¼Œä¼šç›´æ¥ä½¿ç”¨bufä½œä¸ºåº•å±‚æ•°ç»„ï¼Œè€Œbufçš„é•¿åº¦ä¸º32\n\tif buf != nil && len(s) <= len(buf) {\n\t\t*buf = tmpBuf{}\n\t\tb = buf[:len(s)]\n\t} else {\n\t\tb = rawbyteslice(len(s))\n\t}\n\tcopy(b, s)\n\treturn b\n}\n\n// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.\nfunc rawbyteslice(size int) (b []byte) {\n\tcap := roundupsize(uintptr(size))\n\tp := mallocgc(cap, nil, false)\n\tif cap != uintptr(size) {\n\t\tmemclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))\n\t}\n\n\t*(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(cap)}\n\treturn\n}\n```\n\né€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å¾—çŸ¥ï¼Œä»£ç 1ä¸­çš„`byts`ï¼Œ`cap`ä¸º`32`ï¼Œè€Œä»£ç 2ä¸­çš„`byts`ï¼Œ`cap`ä¸º0ã€‚\n\nå› ä¸ºåœ¨ä»£ç 1ä¸­ï¼Œ`cap`ä¸º`32`ï¼Œåˆ™ä¸¤æ¬¡`append`éƒ½ä¸ä¼šå¯¹åº•å±‚æ•°ç»„å‘é€é‡åˆ†é…ï¼Œè€Œä¸”éƒ½æ˜¯ä¿®æ”¹ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤ç¬¬äºŒæ¬¡æ“ä½œä¼šè¦†ç›–ç¬¬ä¸€æ¬¡æ“ä½œã€‚è€Œåœ¨ä»£ç 2ä¸­ï¼Œæ¯æ¬¡`append`éƒ½ä¼šé‡æ–°åˆ†é…ä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚\n\n\n\n","tags":["go"]},{"title":"go mapåˆ†æ","url":"/2019/03/30/go-mapåˆ†æ/","content":"\n`map`å…¶å®å°±æ˜¯ä¸€ä¸ª`hash table`ï¼Œä»Šå¤©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹`go`ä¸­`map`çš„å®ç°ï¼Œç›¸å…³ä»£ç ä½äº`runtime/map.go`ä¸­ã€‚\n\n### ç»“æ„å®šä¹‰\n\næˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸‹`map`çš„ç›¸å…³ç»“æ„å®šä¹‰\n\n```go\ntype hmap struct {\n\tcount     int // å½“å‰mapä¸­å­˜æ”¾çš„å…ƒç´ ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å†…ç½®å‡½æ•°`len`æ¥è·å–\n\tflags     uint8\n\tB         uint8  // å½“å‰mapçš„backetæ•°é‡ä¸º2^Bï¼Œå…¶ä¸­æœ€å¤§èƒ½å¤Ÿå­˜æ”¾loadFactor * 2^Bä¸ªå…ƒç´ ï¼Œå½“è¶…è¿‡è¿™ä¸ªé˜ˆå€¼æ—¶å°±ä¼šè¿›è¡Œæ‰©å®¹ï¼ŒloadFactoré»˜è®¤ä¸º13/2ï¼Œè¿™ä¸ªå€¼æ˜¯å…¨å±€å®šä¹‰çš„å¸¸é‡\n\tnoverflow uint16 // æ€»çš„overflowçš„æ•°é‡\n\thash0     uint32 // hash seed\n\n\tbuckets    unsafe.Pointer // bucketæ•°ç»„ï¼Œé•¿åº¦ä¸º2^Bï¼Œè¿™é‡Œbucketå®é™…æ˜¯bmap\n\toldbuckets unsafe.Pointer // å¦‚æœå‘ç”Ÿæ‰©å®¹ï¼Œæ—§çš„bucketså°±ä¼šä¿å­˜åˆ°oldbucketsï¼Œåœ¨åç»­çš„æ“ä½œä¸­ä¼šæ…¢æ…¢è¿ç§»åˆ°æ–°çš„bucketsä¸­\n\tnevacuate  uintptr        // æ‰©å®¹æ—¶éœ€è¦ä»åŸæ¥çš„bucketså°†æ•°æ®è¿ç§»åˆ°æ–°çš„bucketsä¸­ï¼Œè¯¥å­—æ®µè¡¨ç¤ºå°äºè¯¥æ•°å€¼çš„bucketså½“å‰éƒ½å·²ç»è¿ç§»å®Œæˆ\n\n\textra *mapextra // å¦‚æœmapä¸­ä¿å­˜çš„keyå’Œvalueéƒ½æ²¡æœ‰åŒ…å«æŒ‡é’ˆï¼Œé‚£ä¹ˆgcæ—¶å°±ä¸éœ€è¦å¯¹bucketsé‡Œé¢çš„å†…å®¹è¿›è¡Œæ‰«æï¼Œä½†æ˜¯æ¯ä¸ªbucketæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œbucketså¤´éƒ¨ä¿å­˜çš„æ˜¯æ¯ä¸ªbucketé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œè¿™æ—¶å€™ä¼šå°†æ¯ä¸ªé“¾è¡¨çš„åç»­èŠ‚ç‚¹ä¿å­˜åˆ°è¯¥å­—æ®µå†…ï¼Œä»è€Œgcæ—¶å¯ä»¥å¯¹è¿™äº›åç»­èŠ‚ç‚¹è¿›è¡Œæ‰«æï¼Œé˜²æ­¢è¢«å›æ”¶\n}\n```\n**`map`çš„keyå’Œvalueï¼Œå¦‚æœéƒ½æ²¡æœ‰åŒ…å«æŒ‡é’ˆï¼Œé‚£ä¹ˆä¼šå¯¹å…¶è¿›è¡Œä¼˜åŒ–ï¼Œ`gc`çš„æ—¶å€™å°±ä¸éœ€è¦å»æ‰«ææ¯ä¸ªé”®å€¼å¯¹äº†**\n\nä¸Šé¢`extra`å­—æ®µå¯¹åº”çš„`mapextra`ç±»å‹ï¼š\n\n```go\ntype mapextra struct {\n\toverflow    *[]*bmap // å¯¹åº”buckets\n\toldoverflow *[]*bmap // å¯¹åº”oldbuckets\n\n\t// nextOverflow holds a pointer to a free overflow bucket.\n\tnextOverflow *bmap // åˆ†é…bmapæ—¶ï¼Œå¯èƒ½ä¼šé¢„å…ˆåˆ†é…ä¸€äº›ï¼Œå½“éœ€è¦æ—¶å¯ä»¥ç›´æ¥ä»è¿™é‡Œè·å–\n}\n```\n\nä¸Šé¢è¯´çš„ï¼Œæ¯ä¸ª`bucket`å®é™…ä¸Šæ˜¯ä¸€ä¸ª`bmap`é“¾è¡¨ï¼Œè€Œ`hmap`ä¸­çš„`buckets`æ˜¯ä¸€ä¸ª`bmap`é“¾è¡¨æ•°ç»„ï¼Œè¿™å®é™…ä¸Šå°±æ˜¯[å¼€æ•£åˆ—](https://en.wikipedia.org/wiki/Hash_table#Open_addressing)ã€‚å’Œæ™®é€šçš„å¼€æ•£åˆ—ä¸åŒçš„æ˜¯ï¼Œ**ä¸€ä¸ª`bmap`ä¸­ä¿å­˜äº†8ä¸ªé”®å€¼å¯¹**ï¼Œä¸‹é¢æ¥çœ‹ä¸€ä¸‹`bmap`çš„å®šä¹‰ï¼š\n\n```go\n// A bucket for a Go map.\n// bucketå®é™…ä¸Šæ˜¯ä¸€ä¸ªbmap\ntype bmap struct {\n\t// è¿™é‡ŒbucketCntæ˜¯ä¸€ä¸ªå…¨å±€å£°æ˜çš„å¸¸é‡ï¼Œå¤§å°ä¸º8ï¼Œä¹Ÿå°±æ˜¯é™åˆ¶æ¯ä¸ªbmapä¸­ä¿å­˜8ä¸ªé”®å€¼å¯¹\n    // å½“åˆ¤æ–­ä¸€ä¸ªkeyæ˜¯å¦åœ¨å½“å‰bmapä¸­æ—¶ï¼Œä¼šå…ˆè·å–è¿™ä¸ªkeyçš„hashçš„é«˜8ä½ï¼Œç„¶ååœ¨tophashä¸­æŸ¥æ‰¾æ˜¯å¦æœ‰åŒ¹é…çš„ç´¢å¼•ï¼Œå¦‚æœæœ‰å†è¿›ä¸€æ­¥æ¯”è¾ƒkeyæ˜¯å¦ç›¸åŒï¼Œå¦‚æœå½“å‰bmapä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™åˆ°ä¸‹ä¸€ä¸ªbmapä¸­æŸ¥æ‰¾\n\ttophash [bucketCnt]uint8\n\t// tophashåé¢ç´§è·Ÿç€ä¿å­˜åœ¨å½“å‰bmapä¸­çš„8ä¸ªkeyå’Œ8ä¸ªvalue\n    // å› ä¸ºä¸åŒç±»å‹çš„keyå’Œvalueå†…å­˜å¤§å°æ˜¯ä¸åŒçš„ï¼Œè¿™é‡Œéœ€è¦åœ¨è¿è¡Œæ—¶æ ¹æ®æŒ‡é’ˆè¿ç®—æ¥è®¿é—®\n    // åœ¨bmapä¸­æ˜¯æŒ‰ç…§ `k1,k2,..,k8,v1,v2,...,v8` è¿™æ ·æ¥æ’åˆ—çš„ï¼Œè€Œä¸æ˜¯æŒ‰ç…§ç›´è§‚ä¸Šçš„`k1,v1,k2,v2,...,k8,v8`è¿™æ ·æ¥æ’åˆ—ï¼Œä¸»è¦æ˜¯ä¸ºäº†å‡å°‘å†…å­˜å¯¹é½æ—¶é¢å¤–çš„å†…å­˜å¼€é”€\n    // 8ä¸ªé”®å€¼å¯¹ä¹‹åè¿˜æœ‰ä¸€ä¸ªoverflowæŒ‡é’ˆï¼Œç”¨æ¥é“¾æ¥ä¸‹ä¸€ä¸ªbmapï¼Œæ­£å¦‚ä¸Šé¢è¯´çš„ï¼Œæ¯ä¸ªbucketå®é™…ä¸Šæ˜¯ä¸€ä¸ªbmapé“¾è¡¨ï¼Œè¿™é‡Œé€šè¿‡overflowé“¾æ¥çš„è¿™äº›bmapè¢«ç§°ä¸º`overflow bucket`\n}\n```\n> å› ä¸ºbmapé“¾æ¥ä¸‹ä¸€ä¸ªbmapçš„overflowæŒ‡é’ˆåœ¨æœ«å°¾ï¼Œè€Œä¸åŒç±»å‹çš„keyå’Œvalueçš„å†…å­˜å¤§å°åˆä¸åŒï¼Œå› æ­¤æ— æ³•ç›´æ¥è·å–åˆ°ä¸‹ä¸€ä¸ªbmapçš„åœ°å€ï¼Œå‰é¢è¯´è¿‡ï¼Œå½“keyå’Œvalueä¸åŒ…å«æŒ‡é’ˆçš„æ—¶å€™ï¼Œgcæ—¶ä¸éœ€è¦æ‰«æè¿™äº›é”®å€¼å¯¹ï¼›ä½†æ˜¯åˆéœ€è¦æ‰«æè¿™äº›bmapï¼Œå› æ­¤è¿™ç§æƒ…å†µä¸‹ä¼šæŠŠè¿™äº›bmapå­˜åˆ°mapextraå­—æ®µä¸­çš„`overflowå’Œoldoverflowä¸­ï¼Œè¿™æ ·gcæ—¶ç›´æ¥éå†è¿™ä¸¤ä¸ªåˆ‡ç‰‡å°±å¥½äº†ã€‚\né‚£ä¸ºä»€ä¹ˆä¸æŠŠoverflowæ”¾åˆ°bmapå¤´éƒ¨å‘¢ï¼Ÿä¸ªäººè§‰å¾—å¯èƒ½æ˜¯ä¸ºäº†è®©å†…å­˜è®¿é—®æ›´å‹å¥½å§ï¼Œè¿ç»­çš„å†…å­˜è®¿é—®è‚¯å®šæ›´åŠ é«˜æ•ˆã€‚\n\n\nå¦‚ä¸Šé¢`bmap`æ‰€è§ï¼Œé”®å€¼å¯¹å¹¶æ²¡æœ‰æ˜¾ç¤ºå£°æ˜å‡ºæ¥ï¼Œè€Œæ˜¯éœ€è¦åœ¨è¿è¡Œæ—¶æ ¹æ®æŒ‡é’ˆè¿ç®—æ¥è®¿é—®ï¼Œè¿™é‡Œæ¥çœ‹ä¸€ä¸‹ä¸€ä¸ªå…¨å±€å£°æ˜çš„å¸¸é‡`dataOffset`ï¼Œè¿™ä¸ªå¸¸é‡åœ¨åç»­ä¼šç»å¸¸çœ‹åˆ°ï¼š\n\n```go\nconst(\n    ...\n\tdataOffset = unsafe.Offsetof(struct {\n\t\tb bmap\n\t\tv int64\n\t}{}.v)\n    ...\n)\n```\n\nå› ä¸º`bmap`å®é™…ä¸Šåªå£°æ˜äº†ä¸€ä¸ª`uint8`ç±»å‹çš„æ•°ç»„ï¼Œå› æ­¤è¿™é‡Œ`v`å­—æ®µçš„åç§»é‡å°±æ˜¯å®é™…`bmap`ä¸­ç¬¬ä¸€ä¸ª`key`å€¼çš„åç§»é‡\n\nè¿™é‡Œå‡è®¾`bmap`çš„åœ°å€æ˜¯`bptr`ï¼Œ`key`çš„ç±»å‹å¤§å°æ˜¯`ksize`ï¼Œ`val`çš„ç±»å‹å¤§å°æ˜¯`vsize`ï¼Œé‚£ä¹ˆè®¿é—®ç¬¬`i`ä¸ª`key`å’Œ`val`çš„åœ°å€å¯ä»¥é€šè¿‡ä¸‹é¢å…¬å¼è®¡ç®—ï¼ˆ`i`ä»`0`å¼€å§‹è®¡ç®—ï¼‰ï¼š\n\n```\nith key: bptr + dataOffset + i * ksize\nith val: bptr + dataOffset + bucketCnt * ksize + i * vsize\n```\n\nè‡³æ­¤ï¼Œæˆ‘ä»¬å¯¹`map`çš„ç»“æ„æœ‰äº†ä¸€ä¸ªå¤§ä½“çš„äº†è§£ï¼Œå…¶é”®å€¼å¯¹çš„å­˜å‚¨ç»“æ„å¤§è‡´å¯ä»¥ç”¨ä¸‹å›¾æ¥æè¿°ï¼š\n\n```\n    bucketæ•°ç»„         bmapä¸­çš„overflowæŒ‡å‘ä¸‹ä¸€ä¸ªbmap \n  å®é™…ä¸Šæ˜¯bmapæ•°ç»„    è¿™äº›ç”±overflowå¼•ç”¨çš„bucketè¢«ç§°ä½œoverflow bucket\n|-----------------|  |-----------------|\n|k1,..,k8,v1,..,v8|->|k1,..,k8,v1,..,v8|-> ...\t\t  \n|-----------------|  |-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n```\n\n\n\n> ä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œä¸€ä¸ª`bucket`å®é™…ä¸Šæ˜¯ä¸€ä¸ª`bmap`ï¼Œè€Œä¸”`bmap`å¯ä»¥é€šè¿‡`overflow`æŒ‡é’ˆæ¥å½¢æˆé“¾è¡¨ï¼Œè¿™äº›é€šè¿‡`overflow`å¼•ç”¨çš„`bmap`è¢«ç§°ä½œ`overflow bucket`ï¼Œè€Œ`buckets`ä¸­`bmap`çš„ç§°ä¸º`bucket`ã€‚`bucket`å®é™…ä¸Šä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯æ•´æ¡`bmap`é“¾è¡¨ï¼Œæ¯”å¦‚æ‰©å®¹æ—¶çš„`bucket`è¿ç§»ï¼Œå®é™…ä¸Šå°±æ˜¯è¿ç§»æ•´æ¡`bmap`é“¾è¡¨ã€‚\n\n\n### mapåˆ›å»º\n\nå½“æˆ‘ä»¬ä½¿ç”¨`make`åˆ›å»º`map`æ—¶ï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ª`size`å‚æ•°ï¼Œå½“æˆ‘ä»¬æ²¡æœ‰æŒ‡å®š`size`æ—¶ï¼Œæˆ–è€…`size`åœ¨ç¼–è¯‘æ—¶å·²çŸ¥æ˜¯ä¸€ä¸ªä¸å¤§äº`8`çš„æ•°å€¼æ—¶ï¼ˆä¹Ÿå°±æ˜¯sizeæ˜¯ä¸€ä¸ªå¸¸é‡ï¼‰ï¼Œä¼šé€šè¿‡`makemap_small`æ¥åˆ›å»ºä¸€ä¸ª`map`ï¼š\n\n```go\n// makehmap_small implements Go map creation for make(map[k]v) and\n// make(map[k]v, hint) when hint is known to be at most bucketCnt\n// at compile time and the map needs to be allocated on the heap.\nfunc makemap_small() *hmap {\n\th := new(hmap)\n\th.hash0 = fastrand() // åˆå§‹åŒ–hash seed\n\treturn h\n}\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œé€šè¿‡`makemap_small`åˆ›å»ºçš„`map`ï¼Œæ­¤æ—¶çš„`B`æ˜¯0ï¼Œ`buckets`æ˜¯`nil`ï¼Œåœ¨ç¬¬ä¸€æ¬¡å†™å…¥çš„æ—¶å€™æ‰ä¼šå»åˆ›å»ºå…·ä½“çš„`buckets`\n\nå¯¹åº”çš„ï¼Œå½“æˆ‘ä»¬æŒ‡å®šäº†ä¸€ä¸ªåˆé€‚çš„`size`æ—¶ï¼Œä¼šé€šè¿‡å¦ä¸€ä¸ªå‡½æ•°æ¥åˆ›å»º`map`ï¼š\n\n```go\n// makemap implements Go map creation for make(map[k]v, hint).\n// If the compiler has determined that the map or the first bucket\n// can be created on the stack, h and/or bucket may be non-nil.\n// If h != nil, the map can be created directly in h.\n// If h.buckets != nil, bucket pointed to can be used as the first bucket.\nfunc makemap(t *maptype, hint int, h *hmap) *hmap {\n    // å¦‚æœå°äº0æˆ–è€…è¿‡å¤§ï¼Œåˆ™è®¾ä¸º0\n\tif hint < 0 || hint > int(maxSliceCap(t.bucket.size)) {\n\t\thint = 0\n\t}\n\n\t// initialize Hmap\n    // ç¼–è¯‘å™¨å¯èƒ½ä¼šè¿›è¡Œä¼˜åŒ–ï¼Œåœ¨æ ˆä¸Šåˆ›å»ºmapï¼Œå› æ­¤hå¯èƒ½ä¸ä¸ºç©º\n\tif h == nil {\n\t\th = new(hmap)\n\t}\n\th.hash0 = fastrand()\n\n\t// find size parameter which will hold the requested # of elements\n\tB := uint8(0)\n    // æ ¹æ®ä¼ å…¥çš„sizeæ¥è®¡ç®—Bçš„å¤§å°ï¼Œè¿™é‡Œçš„Bæ˜¯bucketsçš„æ•°é‡ï¼Œå‰æ–‡è¯´è¿‡ï¼Œmapæœ€å¤šå¯ä»¥å®¹çº³ 0.65*2^B ä¸ªé”®å€¼å¯¹ï¼Œå½“è¶…è¿‡è¿™ä¸ªé˜ˆå€¼æ—¶ï¼Œä¼šæ‰§è¡Œæ‰©å®¹\n\tfor overLoadFactor(hint, B) { \n\t\tB++\n\t}\n\th.B = B\n\n\t// allocate initial hash table\n\t// if B == 0, the buckets field is allocated lazily later (in mapassign)\n\t// If hint is large zeroing this memory could take a while.\n\tif h.B != 0 {\n\t\tvar nextOverflow *bmap\n        // åˆ›å»ºbucketæ•°ç»„ï¼Œè¿™é‡Œå¯èƒ½ä¼šé¢„å…ˆåˆ†é…å‡ ä¸ªbmapï¼Œåç»­å¯ä»¥ç›´æ¥ä½¿ç”¨è€Œä¸éœ€è¦æ‰§è¡Œå†…å­˜åˆ†é…\n\t\th.buckets, nextOverflow = makeBucketArray(t, h.B, nil)\n\t\tif nextOverflow != nil {\n\t\t\th.extra = new(mapextra)\n\t\t\th.extra.nextOverflow = nextOverflow\n\t\t}\n\t}\n\n\treturn h\n}\n```\n\nå½“æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`map`æ—¶ï¼Œå¦‚æœ`map`ä¸­è¦å­˜å‚¨çš„é”®å€¼å¯¹æ•°æ®å¯ä»¥ä¼°è®¡çš„è¯ï¼Œæœ€å¥½åœ¨åˆ›å»ºçš„æ—¶å€™æŒ‡å®šå¥½`size`ï¼Œè¿™æ ·å¯ä»¥é¢„å…ˆåˆ†é…å¥½`bucket`çš„æ•°é‡ã€‚\n\n\n\n### mapçš„è®¿é—®\n\né€šå¸¸æˆ‘ä»¬å¯¹`map`çš„è®¿é—®æœ‰`get`ã€`set`ã€`delete`ã€å’Œ`for range`æ“ä½œï¼Œåœ¨åˆ†æå…·ä½“çš„å®ç°ä¸‹æ—¶ï¼Œæˆ‘ä»¬è¦å…ˆæ¥äº†è§£ä¸€ä¸‹å¦‚æœå®šä½ä¸€ä¸ª`key`çš„ä½ç½®ï¼Œè¿™é‡Œå…ˆä¸æ¶‰åŠåœ¨æ‰§è¡Œæ‰©å®¹æ—¶çš„åœºæ™¯ã€‚\n\næˆ‘ä»¬å†å›é¡¾ä¸€ä¸‹å›¾ï¼š\n\n```\n    bucketæ•°ç»„         bmapä¸­çš„overflowæŒ‡å‘ä¸‹ä¸€ä¸ªbmap \n  å®é™…ä¸Šæ˜¯bmapæ•°ç»„    è¿™äº›ç”±overflowå¼•ç”¨çš„bucketè¢«ç§°ä½œoverflow bucket\n|-----------------|  |-----------------|\n|k1,..,k8,v1,..,v8|->|k1,..,k8,v1,..,v8|-> ...\t\t  \n|-----------------|  |-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n|k1,..,k8,v1,..,v8|-> ...\n|-----------------|\n```\n\nè¦å®šä½ä¸€ä¸ª`key`ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç¡®å®šè¿™ä¸ª`key`æ˜¯è½åœ¨å“ªä¸ª`bucket`ä¸­ï¼Œä¹Ÿå°±æ˜¯å“ªä¸€æ¡`bmap`é“¾è¡¨ä¸­ï¼Œé€šè¿‡è®¡ç®—`key`çš„å“ˆå¸Œå€¼ï¼Œç„¶åé€šè¿‡`hash%bucketæ•°é‡`çš„æ¥å®šä½ ï¼Œå…·ä½“çš„é€»è¾‘å¦‚ä¸‹ï¼š\n\n```go\nalg := t.key.alg // è¿™é‡Œçš„tæ˜¯mapçš„ç±»å‹æè¿°\nhash := alg.hash(key, uintptr(h.hash0)) // è®¡ç®—hashå€¼\nm := bucketMask(h.B) // è¿™é‡Œçš„mä¸º 1<<B-1\n// è¿™é‡Œçš„hash&mç­‰ä»·äºæ±‚æ¨¡æ“ä½œ\nb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize))) \n```\n\nå½“å®šä½åˆ°å…·ä½“çš„`bucket`åï¼Œåªéœ€è¦ä»å¤´å¼€å§‹éå†è¯¥`bmap`é“¾è¡¨ï¼Œå› ä¸º`bmap`ä¸­æœ‰ä¸ª`tophash`æ•°ç»„ï¼Œä¿å­˜äº†æ¯ä¸ª`key`å¯¹åº”çš„å“ˆå¸Œå€¼çš„é«˜å…«ä½ï¼Œå› æ­¤æˆ‘ä»¬ä¸éœ€è¦æŒ¨ä¸ªå¯¹æ¯ä¸ª`key`è¿›è¡Œæ¯”è¾ƒï¼Œåªéœ€è¦å…ˆæ¯”è¾ƒå“ˆå¸Œå€¼çš„é«˜å…«ä½æ˜¯å¦ç›¸åŒå°±è¡Œäº†ï¼Œå¦‚æœç›¸åŒæ‰æ¥ç€æ¯”è¾ƒ`key`æ˜¯å¦ç›¸ç­‰ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š\n\n```go\ntop := tophash(hash) // å–keyçš„hashå€¼çš„é«˜å…«ä½\n\t// è¿™é‡Œbæ˜¯ä¸€ä¸ªbmapæŒ‡é’ˆï¼Œå¦‚æœå½“å‰bmapæ²¡æœ‰ï¼Œåˆ™æŸ¥æ‰¾ä¸‹ä¸€ä¸ªbmap\n\tfor ; b != nil; b = b.overflow(t) { \n        // éå†å½“å‰bmapï¼Œè¿™é‡ŒbucketCntæ˜¯å¸¸é‡8ï¼Œé™åˆ¶ä¸€ä¸ªbmapä¸­æœ€å¤šåªæœ‰8ä¸ªé”®å€¼å¯¹\n\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n            // å…ˆæ¯”è¾ƒå“ˆå¸Œå€¼é«˜å…«ä½ï¼Œå¦‚æœä¸ç›¸ç­‰åˆ™continue\n\t\t\tif b.tophash[i] != top {\n\t\t\t\tcontinue\n\t\t\t}\n            // è®¡ç®—å½“å‰çš„keyçš„ä½ç½®\n\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n            // æ˜¯å¦é—´æ¥å­˜å‚¨ï¼ˆå­˜å‚¨çš„æ˜¯å®é™…keyçš„åœ°å€ï¼‰\n\t\t\tif t.indirectkey {\n\t\t\t\tk = *((*unsafe.Pointer)(k))\n\t\t\t}\n            // æ¯”è¾ƒkeyæ˜¯å¦ç›¸ç­‰\n\t\t\tif alg.equal(key, k) {\n\t\t\t\t......\n\t\t\t}\n\t\t}\n\t}\n```\n\n##### get\n\nä¸`get`ç›¸å…³çš„æ–¹æ³•æœ‰å¤šä¸ªï¼š\n\n```go\n// val := m[key]\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n// val,has := m[key]\nfunc mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) \n// for-rangeæ—¶ï¼Œç”¨äºè·å–keyå’Œval\nfunc mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer)\n```\n\nè¿™ä¸‰ä¸ªæ–¹æ³•å¤§åŒå°å¼‚ï¼Œè¿™é‡Œåªåˆ†æç¬¬ä¸€ä¸ªæ–¹æ³•ï¼š\n\nå…ˆçœ‹è¯¥å‡½æ•°çš„æ³¨é‡Šï¼Œå¦‚æœ`key`ä¸å­˜åœ¨æ—¶ï¼Œè¿”å›çš„æ˜¯å¯¹åº”çš„`val`ç±»å‹çš„ç©ºå€¼ã€‚\n\n```go\n// mapaccess1 returns a pointer to h[key].  Never returns nil, instead\n// it will return a reference to the zero object for the value type if\n// the key is not in the map.\n// NOTE: The returned pointer may keep the whole map live, so don't\n// hold onto it for very long.\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n    // å¦‚æœæ²¡æœ‰å†…å®¹ï¼Œåˆ™è¿”å›å¯¹åº”ç±»å‹çš„é›¶å€¼\n\tif h == nil || h.count == 0 {\n\t\treturn unsafe.Pointer(&zeroVal[0])\n\t}\n    // mapä¸æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œå¦‚æœå­˜åœ¨å†™æ“ä½œåˆ™panicï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨å¤šä¸ªgoroutineå¯¹mapè¿›è¡Œå¹¶å‘è¯»å†™æ—¶ï¼Œéœ€è¦åŠ é”ä¿æŠ¤\n\tif h.flags&hashWriting != 0 {\n\t\tthrow(\"concurrent map read and map write\")\n\t}\n\talg := t.key.alg\n    // è®¡ç®—keyçš„å“ˆå¸Œå€¼\n\thash := alg.hash(key, uintptr(h.hash0))\n    // è·å–bucketsæ•°ç»„é•¿åº¦çš„æ©ç \n\tm := bucketMask(h.B)\n    // å®šä½keyæ‰€åœ¨çš„bucket\n\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n    // å½“å‰æ˜¯å¦å¤„äºæ‰©å®¹æ“ä½œï¼Œå½“å‘ç”Ÿæ‰©å®¹æ“ä½œæ—¶ï¼Œæˆ–é‡æ–°åˆ†é…bucketsæ•°ç»„ï¼Œå¹¶ä¸”éœ€è¦å°†æ—§çš„bucketså†…çš„é”®å€¼å¯¹è¿ç§»åˆ°æ–°çš„bucketsæ•°ç»„ä¸­ï¼Œè¿™ä¸ªè¿ç§»è¿‡ç¨‹ä¸æ˜¯ä¸€æ¬¡æ€§å®Œæˆçš„è€Œæ˜¯åˆ†æ‰¹å®Œæˆçš„\n\tif c := h.oldbuckets; c != nil {\n       \t// æ‰©å®¹æ“ä½œæœ‰ä¸¤ç§ï¼šç¬¬ä¸€ç§ï¼Œå¦‚æœæ˜¯å› ä¸ºå½“å‰çš„é”®å€¼å¯¹æ•°é‡å·²ç»è¾¾åˆ°äº†é˜ˆå€¼0.65*2^Bï¼Œåˆ™ä¼šè§¦å‘æ‰©å®¹ï¼Œè¿™æ—¶å€™æ–°çš„bucketsæ•°ç»„çš„æ•°é‡ä¸ºåŸæ¥çš„2å€ï¼›ç¬¬äºŒç§æ˜¯å½“å‰é”®å€¼å¯¹æ•°é‡å¹¶æ²¡æœ‰è¾¾åˆ°é˜ˆå€¼ï¼Œä½†æ˜¯å½“å‰å­˜åœ¨å¤ªå¤šçš„overflow bucketï¼Œå¯èƒ½æ˜¯å› ä¸ºä¹‹å‰å­˜å‚¨äº†å¤ªå¤šçš„é”®å€¼å¯¹ï¼Œä½†æ˜¯åé¢åˆè¢«åˆ é™¤æ‰äº†ï¼Œè¿™æ—¶å€™æœ‰çš„bucketé“¾è¡¨ä¼šæ¯”è¾ƒé•¿ï¼Œä½†æ˜¯å®é™…ä¸Šå­˜å‚¨çš„é”®å€¼å¯¹æ¯”è¾ƒç¨€ç–ï¼Œè¿™æ ·ä¼šå½±å“æŸ¥æ‰¾æ•ˆç‡ï¼Œè¿™ç§æƒ…å†µä¼šè§¦å‘sameSizeGrowï¼Œå³æ‰©å®¹æ—¶bucketsæ•°ç»„é•¿åº¦ä¸åŸæ¥ä¸€è‡´\n        // å¦‚æœæ˜¯å‰ä¸€ç§ï¼Œåˆ™åŸå…ˆçš„bucketsæ•°é‡çš„æ©ç æ˜¯m>>1\n\t\tif !h.sameSizeGrow() {\n\t\t\t// There used to be half as many buckets; mask down one more power of two.\n\t\t\tm >>= 1\n\t\t}\n        // è®¡ç®—è¯¥keyè½åœ¨çš„oldbucketsä¸­çš„å“ªä¸ªbucketä¸­\n\t\toldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))\n        // å¦‚æœå½“å‰bucketè¿˜æ²¡æœ‰è¿ç§»ï¼Œåˆ™åœ¨è¯¥bucketä¸­æŸ¥è¯¢ï¼Œè¿ç§»æ“ä½œæ˜¯æŒ‰ç…§bucketä¸ºå•ä½è¿›è¡Œçš„\n\t\tif !evacuated(oldb) {\n\t\t\tb = oldb\n\t\t}\n\t}\n    // è·å–å“ˆå¸Œå€¼é«˜å…«ä½\n\ttop := tophash(hash)\n    // éå†bmapé“¾è¡¨\n\tfor ; b != nil; b = b.overflow(t) {\n\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n            // æ¯”è¾ƒå“ˆå¸Œå€¼é«˜å…«ä½\n\t\t\tif b.tophash[i] != top {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n\t\t\tif t.indirectkey {\n\t\t\t\tk = *((*unsafe.Pointer)(k))\n\t\t\t}\n            // æ¯”è¾ƒkeyæ˜¯å¦ç›¸ç­‰\n\t\t\tif alg.equal(key, k) {\n                // è·å–keyå¯¹åº”çš„valï¼Œè¿™é‡Œçš„è®¡ç®—å…¬å¼åœ¨å‰é¢ç»“æ„å®šä¹‰ä¸€èŠ‚ä¸­å·²ç»è¯´æ˜è¿‡\n\t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n                // å¦‚æœè¿™é‡Œå­˜å‚¨çš„æ˜¯valçš„åœ°å€\n\t\t\t\tif t.indirectvalue {\n\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n\t\t\t\t}\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t}\n\treturn unsafe.Pointer(&zeroVal[0])\n}\n```\n\n##### set \n\n`set`æ“ä½œå¯¹åº”çš„æ–¹æ³•æ˜¯`mapassign`ï¼Œè¿™ä¸ªæ–¹æ³•ä¸ºæŒ‡å®šçš„`key`åˆ†é…ä¸€ä¸ªç”¨äºå­˜æ”¾`val`çš„æ§½ï¼Œæˆ–è€…è¿”å›å·²ç»å­˜åœ¨çš„æ§½ï¼Œæ–°çš„`val`ç›´æ¥å†™å…¥è¿™ä¸ªæ§½ä¸­ï¼Œå³å®Œæˆäº†`map`çš„`set`æ“ä½œã€‚\n\nåœ¨å†™å…¥æ—¶ï¼Œå› ä¸ºå¯èƒ½è¯¥`key`å·²ç»å­˜åœ¨ï¼Œå› æ­¤éœ€è¦å…ˆéå†ç›®æ ‡`bucket`çš„`bmap`é“¾è¡¨ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š\n\n```go\n// Like mapaccess, but allocates a slot for the key if it is not present in the map.\nfunc mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n\t// ä¸å…è®¸å†™å…¥ç©ºmap\n    if h == nil {\n\t\tpanic(plainError(\"assignment to entry in nil map\"))\n\t}\n    // å¦‚æœæœ‰å¹¶å‘å†™æ“ä½œï¼Œç›´æ¥panic\n\tif h.flags&hashWriting != 0 {\n\t\tthrow(\"concurrent map writes\")\n\t}\n\talg := t.key.alg\n    // è®¡ç®—keyçš„å“ˆå¸Œå€¼\n\thash := alg.hash(key, uintptr(h.hash0))\n\n\t// Set hashWriting after calling alg.hash, since alg.hash may panic,\n\t// in which case we have not actually done a write.\n    // è®¾ç½®å†™æ ‡å¿—\n\th.flags |= hashWriting\n\t// å¦‚æœbucketsæ•°ç»„ä¸ºç©ºï¼Œåˆ™ä¼šåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º1çš„bucketsæ•°ç»„\n\tif h.buckets == nil {\n\t\th.buckets = newobject(t.bucket) // newarray(t.bucket, 1)\n\t}\n\nagain:\n    // è®¡ç®—ç›®æ ‡bucketåœ¨bucketsæ•°ç»„ä¸­çš„ç´¢å¼•\n\tbucket := hash & bucketMask(h.B)\n    // å¦‚æœå½“å‰æ­£åœ¨æ‰§è¡Œæ‰©å®¹æ“ä½œï¼Œåˆ™ä¼šæ‰§è¡Œè¿ç§»æ“ä½œï¼Œå‰é¢è¯´è¿‡æ‰©å®¹æ—¶çš„è¿ç§»æ“ä½œæ˜¯åˆ†æ‰¹è¿›è¡Œçš„ï¼Œè€Œè¿ç§»æ˜¯æŒ‰ç…§bucketä¸ºå•ä½è¿›è¡Œçš„ï¼Œè€Œè§¦å‘è¿ç§»çš„æ—¶æœºæ˜¯æ‰§è¡Œå†™æ“ä½œ\n\tif h.growing() {\n        // è¯¥å‡½æ•°ä¼šæ‰§è¡Œè¿ç§»æ“ä½œï¼Œè¿ç§»çš„ç›®æ ‡æ˜¯bucket%len_of_oldbuckets\n\t\tgrowWork(t, h, bucket) \n\t}\n    // è®¡ç®—è¦å†™å…¥çš„bucket\n\tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))\n    // è®¡ç®—å“ˆå¸Œå€¼é«˜å…«ä½\n\ttop := tophash(hash)\n\t// åœ¨bmapä¸­è¦æ’å…¥çš„ç´¢å¼•ï¼Œå¦‚æœå‰æ–‡æ‰€è¯´ï¼Œä¸€ä¸ªbmapæœ€å¤šå¯ä»¥æœ‰8ä¸ªé”®å€¼å¯¹\n\tvar inserti *uint8\n    // è¦æ’å…¥keyçš„åœ°å€\n\tvar insertk unsafe.Pointer\n    // å¯¹åº”çš„valçš„åœ°å€\n\tvar val unsafe.Pointer\n    // å› ä¸ºå‰é¢å·²ç»æ‰§è¡Œè¿‡æ‰©å®¹æ“ä½œï¼Œå› æ­¤å†™å…¥åªéœ€è¦å¯¹æ–°çš„bucketè¿›è¡Œæ“ä½œ\n\tfor {\n        // éå†å½“å‰bmap\n\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n            // é«˜å…«ä½å“ˆå¸Œå€¼ä¸ç›¸åŒ\n\t\t\tif b.tophash[i] != top {\n                // å¯¹ç¬¬ä¸€ä¸ªé‡åˆ°çš„ç©ºæ§½ï¼Œè®¾ç½®ä¸ºå¾…å®šæ§½ï¼Œå› ä¸ºå¯èƒ½åœ¨åç»­éå†ä¸­å‘ç°å½“å‰keyå·²ç»å­˜åœ¨ï¼Œåˆ™ç›´æ¥è¿”å›å¯¹åº”çš„valå°±å¥½äº†\n\t\t\t\tif b.tophash[i] == empty && inserti == nil {\n\t\t\t\t\tinserti = &b.tophash[i]\n\t\t\t\t\tinsertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n\t\t\t\t\tval = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n            // è¿™é‡Œè¯´æ˜å“ˆå¸Œå€¼é«˜å…«ä½ä¸€è‡´ï¼Œå› æ­¤éœ€è¦æ¯”è¾ƒkeyæ˜¯å¦ç›¸ç­‰\n\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n\t\t\tif t.indirectkey {\n\t\t\t\tk = *((*unsafe.Pointer)(k))\n\t\t\t}\n            // å¦‚æœä¸ç›¸ç­‰ï¼Œç»§ç»­éå†ä¸‹ä¸€ä¸ª\n\t\t\tif !alg.equal(key, k) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// å¦‚æœkeyå·²ç»å­˜åœ¨ï¼Œç›´æ¥è¿”å›å¯¹åº”çš„valåœ°å€å°±å¥½äº†\n\t\t\tif t.needkeyupdate {\n\t\t\t\ttypedmemmove(t.key, k, key)\n\t\t\t}\n\t\t\tval = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n            // gotoå¤§æ³•å¥½\n\t\t\tgoto done\n\t\t}\n        // å½“å‰bmapæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„keyï¼Œåˆ™ç»§ç»­éå†ä¸‹ä¸€ä¸ªbmap\n\t\tovf := b.overflow(t)\n\t\tif ovf == nil { // å¦‚æœå½“å‰bucketå·²ç»éå†å®Œæˆï¼Œåˆ™è·³å‡º\n\t\t\tbreak\n\t\t}\n\t\tb = ovf\n\t}\n\t\n    // é¦–å…ˆåˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡Œæ‰©å®¹ï¼šå¦‚æœå½“å‰æ²¡æœ‰æ‰©å®¹æ“ä½œæ­£åœ¨æ‰§è¡Œå¹¶ä¸”æ•°æ®è¾¾åˆ°é˜ˆå€¼æˆ–è€…å­˜åœ¨å¤ªå¤šçš„bmapï¼Œåˆ™ä¼šè§¦å‘æ‰©å®¹æ“ä½œ\n\tif !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {\n        // è§¦å‘æ‰©å®¹æ“ä½œï¼Œç„¶åè·³åˆ°å¼€å¤´é‡æ–°æ‰§è¡Œä¸Šé¢æµç¨‹\n\t\thashGrow(t, h)\n\t\tgoto again // Growing the table invalidates everything, so try again\n\t}\n\t// å¦‚æœä¸éœ€è¦æ‰©å®¹æ“ä½œï¼Œå¹¶ä¸”æ²¡æœ‰å¯ä»¥ä½¿ç”¨çš„ç©ºæ§½ï¼Œåˆ™éœ€è¦åˆ†é…ä¸€ä¸ªæ–°çš„overflow bucketï¼Œè¿™é‡Œæ˜¯åˆ†é…åœ¨é“¾è¡¨å°¾éƒ¨ï¼Œå½“å‰çš„bæŒ‡å‘çš„å°±æ˜¯æ•´æ¡bmapé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹\n\tif inserti == nil {\n\t\t// all current buckets are full, allocate a new one.\n\t\tnewb := h.newoverflow(t, b)\n        // æ’å…¥ç¬¬ä¸€ä¸ªæ§½ä¸­\n\t\tinserti = &newb.tophash[0]\n\t\tinsertk = add(unsafe.Pointer(newb), dataOffset)\n\t\tval = add(insertk, bucketCnt*uintptr(t.keysize))\n\t}\n\n\t// store new key/value at insert position\n    // è®¾ç½®key\n    // è¿™é‡Œé’ˆå¯¹æ˜¯å¦éœ€è¦å¯¹keyæˆ–è€…valè¿›è¡Œé—´æ¥å­˜å‚¨çš„å¤„ç†\n\tif t.indirectkey {\n\t\tkmem := newobject(t.key)\n\t\t*(*unsafe.Pointer)(insertk) = kmem\n\t\tinsertk = kmem\n\t}\n\tif t.indirectvalue {\n\t\tvmem := newobject(t.elem)\n\t\t*(*unsafe.Pointer)(val) = vmem\n\t}\n\ttypedmemmove(t.key, insertk, key)\n\t*inserti = top\n\th.count++\t// mapä¸­å…ƒç´ æ•°æ®åŠ 1\n\ndone:\n    // æ£€æŸ¥å†™æ“ä½œæ ‡å¿—ä½\n\tif h.flags&hashWriting == 0 {\n\t\tthrow(\"concurrent map writes\")\n\t}\n    // æ¸…é™¤å†™æ“ä½œ\n\th.flags &^= hashWriting\n\tif t.indirectvalue {\n\t\tval = *((*unsafe.Pointer)(val))\n\t}\n\treturn val\n}\n```\n\n##### delete\n\nåˆ é™¤æ“ä½œæµç¨‹å¦‚ä¸‹ï¼š\n\n```go\nfunc mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n   if h == nil || h.count == 0 {\n      return\n   }\n    // è®¾ç½®å†™æ“ä½œæ ‡å¿—ä½\n   if h.flags&hashWriting != 0 {\n      throw(\"concurrent map writes\")\n   }\n\n   alg := t.key.alg\n   hash := alg.hash(key, uintptr(h.hash0))\n\n   // Set hashWriting after calling alg.hash, since alg.hash may panic,\n   // in which case we have not actually done a write (delete).\n   h.flags |= hashWriting\n\n   bucket := hash & bucketMask(h.B)\n    // å¦‚æœæ­£åœ¨æ‰©å®¹ï¼Œå…ˆæ‰§è¡Œè¿ç§»æ“ä½œ\n   if h.growing() {\n      growWork(t, h, bucket)\n   }\n   b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize)))\n   top := tophash(hash)\nsearch:\n    // æŸ¥æ‰¾è¦åˆ é™¤çš„å¯ä»¥ï¼Œå› ä¸ºå‰é¢å·²ç»æ‰§è¡Œäº†è¿ç§»æ“ä½œï¼Œå› æ­¤è¿™é‡Œåªéœ€è¦åœ¨æ–°çš„bucketä¸­æŸ¥æ‰¾å³å¯\n   for ; b != nil; b = b.overflow(t) {\n      for i := uintptr(0); i < bucketCnt; i++ {\n         if b.tophash[i] != top {\n            continue\n         }\n         k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n         k2 := k\n         if t.indirectkey {\n            k2 = *((*unsafe.Pointer)(k2))\n         }\n         if !alg.equal(key, k2) {\n            continue\n         }\n         // æ‰§è¡Œæ¸…é™¤æ“ä½œ\n         // Only clear key if there are pointers in it.\n         if t.indirectkey {\n            *(*unsafe.Pointer)(k) = nil\n         } else if t.key.kind&kindNoPointers == 0 {\n            memclrHasPointers(k, t.key.size)\n         }\n         v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n         if t.indirectvalue {\n            *(*unsafe.Pointer)(v) = nil\n         } else if t.elem.kind&kindNoPointers == 0 {\n            memclrHasPointers(v, t.elem.size)\n         } else {\n            memclrNoHeapPointers(v, t.elem.size)\n         }\n         b.tophash[i] = empty // å°†tophashä¸­çš„å€¼è®¾ä¸ºemptyï¼Œè¡¨ç¤ºç©ºæ§½\n         h.count-- // æ•°é‡å‡ä¸€\n         break search\n      }\n   }\n\n   if h.flags&hashWriting == 0 {\n      throw(\"concurrent map writes\")\n   }\n   h.flags &^= hashWriting\n}\n```\n\n##### for-range\n\næ‰§è¡Œ`for-range`æ“ä½œæ—¶ï¼Œéœ€è¦ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹è¿­ä»£å™¨çš„å£°æ˜ï¼š\n\n```go\n// A hash iteration structure.\ntype hiter struct {\n\tkey         unsafe.Pointer // keyå€¼ï¼Œnilè¡¨ç¤ºè¿­ä»£ç»“æŸ\n\tvalue       unsafe.Pointer // valå€¼\n\tt           *maptype\n\th           *hmap\n\tbuckets     unsafe.Pointer // bucket ptr at hash_iter initialization time\n\tbptr        *bmap          // å½“å‰æ­£åœ¨è¿­ä»£çš„bucketeçš„æŒ‡é’ˆ\n\toverflow    *[]*bmap       // keeps overflow buckets of hmap.buckets alive\n\toldoverflow *[]*bmap       // keeps overflow buckets of hmap.oldbuckets alive\n\tstartBucket uintptr        // è®°å½•è¿™æ¬¡è¿­ä»£ä»å“ªä¸ªbucketå¼€å§‹\n\toffset      uint8          // è®°å½•è¿™æ¬¡è¿­ä»£ä»hmapä¸­çš„å“ªä¸ªoffsetå¼€å§‹\n\twrapped     bool           // already wrapped around from end of bucket array to beginning\n\tB           uint8\n\ti           uint8\n\tbucket      uintptr\n\tcheckBucket uintptr\n}\n```\n\n`hiter`çš„åˆ›å»ºï¼š\n\n```go\nfunc mapiterinit(t *maptype, h *hmap, it *hiter) {\n\tif h == nil || h.count == 0 {\n\t\treturn\n\t}\n\n\tit.t = t // è®°å½•mapç±»å‹ä¿¡æ¯\n\tit.h = h // å¼•ç”¨map\n\n\t// grab snapshot of bucket state\n\tit.B = h.B // è®°å½•å½“å‰çš„B\n\tit.buckets = h.buckets // è®°å½•å½“å‰çš„buckets\n    // å¦‚æœå½“å‰mapä¸­çš„é”®å€¼å¯¹æ²¡æœ‰æŒ‡é’ˆ\n\tif t.bucket.kind&kindNoPointers != 0 {\n\t\t// Allocate the current slice and remember pointers to both current and old.\n\t\t// This preserves all relevant overflow buckets alive even if\n\t\t// the table grows and/or overflow buckets are added to the table\n\t\t// while we are iterating.\n\t\th.createOverflow()\n\t\tit.overflow = h.extra.overflow\n\t\tit.oldoverflow = h.extra.oldoverflow\n\t}\n\n\t// decide where to start\n    // è¿™é‡Œéšæœºé€‰ä¸¾ä¸€ä¸ªå¼€å§‹è¿­ä»£çš„ä½ç½®ï¼Œå› æ­¤æˆ‘ä»¬å¯¹mapè¿›è¡Œfor-rangeæ“ä½œï¼Œæ¯æ¬¡è¾“å‡ºçš„åºåˆ—éƒ½æ˜¯ä¸åŒçš„\n\tr := uintptr(fastrand())\n\tif h.B > 31-bucketCntBits {\n\t\tr += uintptr(fastrand()) << 31\n\t}\n    // è®¾ç½®å¼€å§‹çš„bucketå’Œoffset\n\tit.startBucket = r & bucketMask(h.B)\n\tit.offset = uint8(r >> h.B & (bucketCnt - 1))\n\n\t// å½“å‰è¿­ä»£çš„bucketç´¢å¼•\n\tit.bucket = it.startBucket\n\n\t// è®¾ç½®è¿­ä»£æ ‡å¿—ä½\n\tif old := h.flags; old&(iterator|oldIterator) != iterator|oldIterator {\n\t\tatomic.Or8(&h.flags, iterator|oldIterator)\n\t}\n\t// æ‰§è¡Œnextæ“ä½œ\n\tmapiternext(it)\n}\n```\n\n`mapiternext`æ–¹æ³•ç”¨äºæ¨è¿›è¿­ä»£å™¨å‰è¿›åˆ°ä¸‹ä¸€ä¸ªé”®å€¼å¯¹ï¼Œå¯¹åº”é€»è¾‘ï¼š\n\n```go\n\nfunc mapiternext(it *hiter) {\n\th := it.h\n\tif h.flags&hashWriting != 0 {\n\t\tthrow(\"concurrent map iteration and map write\")\n\t}\n\tt := it.t\n\tbucket := it.bucket\n\tb := it.bptr // å½“å‰æ­£åœ¨éå†çš„bucket\n\ti := it.i\n\tcheckBucket := it.checkBucket\n\talg := t.key.alg\n\nnext:\n\tif b == nil { // å¦‚æœit.bptrè¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦æ ¹æ®it.bucketè¿›è¡Œåˆå§‹åŒ–ï¼Œç¬¬ä¸€æ¬¡æ‰§è¡Œæˆ–è€…æ¯æ¬¡éå†å®Œä¸€ä¸ªbucketéƒ½ä¼šæ¸…ç©ºbptr\n\t\tif bucket == it.startBucket && it.wrapped {\n\t\t\t// end of iteration\n\t\t\tit.key = nil\n\t\t\tit.value = nil\n\t\t\treturn\n\t\t}\n        // å¦‚æœæ­£åœ¨æ‰§è¡Œæ‰©å®¹ï¼Œå¹¶ä¸”è¿­ä»£æ˜¯åœ¨æ‰©å®¹ä¹‹åå¼€å§‹çš„ï¼Œè¿™æ—¶å€™å¦‚æœæ—§çš„bucketè¿˜æ²¡æœ‰è¿ç§»åˆ°æ–°çš„bucketä¸­ï¼Œé‚£ä¹ˆéœ€è¦åˆ°æ—§çš„bucketä¸­éå†\n\t\tif h.growing() && it.B == h.B {\n            // è·å–å½“å‰è¦è¿­ä»£çš„bucketå¯¹åº”çš„oldbucket\n\t\t\toldbucket := bucket & it.h.oldbucketmask()\n\t\t\tb = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n            // å¦‚æœoldbucketä¸­çš„å…ƒç´ è¿˜æ²¡æœ‰è¿ç§»åˆ°æ–°çš„bucketä¸­\n\t\t\tif !evacuated(b) {\n\t\t\t\tcheckBucket = bucket // oldbucketä¸­çš„é”®å€¼å¯¹è¿ç§»åˆ°æ–°çš„bucketä¸­æ—¶ï¼Œå¯èƒ½ä¼šè¿ç§»åˆ°ä¸¤ä¸ªbucketä¸­ï¼Œæ¯”å¦‚åŸæ¥é•¿åº¦æ˜¯4ï¼Œhash%4ç­‰äº3ï¼Œé™åˆ¶é•¿åº¦æ˜¯8ï¼Œhash%8å¯èƒ½ä¸º4ä¹Ÿå¯èƒ½ä¸º7ï¼Œè¿™é‡Œçš„checkBucketè®°å½•å½“å‰æ­£åœ¨éå†h.bucketsæ•°ç»„ä¸­çš„å“ªä¸ªbucketï¼Œç”¨äºåé¢çš„åˆ¤æ–­\n\t\t\t} else {\n                // å·²ç»è¿ç§»å®Œæˆï¼Œç›´æ¥åœ¨æ–°çš„bucketä¸­éå†\n\t\t\t\tb = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\n\t\t\t\tcheckBucket = noCheck\n\t\t\t}\n\t\t} else { // å½“å‰æ²¡æœ‰æ‰©å®¹æ“ä½œï¼Œç›´æ¥åœ¨æ–°çš„bucketä¸­éå†\n\t\t\tb = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\n\t\t\tcheckBucket = noCheck\n\t\t}\n\t\tbucket++ // ä¸‹ä¸€æ¬¡éå†çš„bucketçš„ç´¢å¼•\n        // å› ä¸ºå¼€å§‹è¿­ä»£çš„bucketä½ç½®æ˜¯éšæœºçš„ï¼Œå¦‚æœè¶Šç•Œäº†ï¼Œä»ç¬¬ä¸€ä¸ªbucketå¼€å§‹\n\t\tif bucket == bucketShift(it.B) {\n\t\t\tbucket = 0\n\t\t\tit.wrapped = true\n\t\t}\n\t\ti = 0\n\t}\n    // éå†bmapä¸­é”®å€¼å¯¹\n\tfor ; i < bucketCnt; i++ {\n        // è®¡ç®—å¼€å§‹éå†çš„åç§»ä½ç½®\n\t\toffi := (i + it.offset) & (bucketCnt - 1)\n        // å¦‚æœç©ºæ§½ï¼Œåˆ™è·³è¿‡\n\t\tif b.tophash[offi] == empty || b.tophash[offi] == evacuatedEmpty {\n\t\t\tcontinue\n\t\t}\n        // è·å–key\n\t\tk := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))\n\t\tif t.indirectkey {\n\t\t\tk = *((*unsafe.Pointer)(k))\n\t\t}\n        // è·å–val\n\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))\n        // å¦‚æœæ­£åœ¨æ‰§è¡Œæ‰©å®¹ï¼Œå¹¶ä¸”æ­£åœ¨éå†çš„bucketè¿˜æ²¡æœ‰è¿ç§»å®Œæˆï¼Œå¹¶ä¸”æ‰©å®¹æ˜¯ç”±äºé”®å€¼å¯¹è¾¾åˆ°é˜ˆå€¼è§¦å‘çš„ï¼Œè¿™æ—¶å€™æ‰©å®¹åçš„bucketsæ•°ç»„çš„é•¿åº¦ä¸ºåŸæ¥çš„ä¸¤å€ï¼ŒåŸæ¥çš„ä¸€ä¸ªbucketä¸­çš„é”®å€¼å¯¹è¿ç§»æ—¶ä¼šè¿ç§»åˆ°æ–°çš„ä¸¤ä¸ªbucketä¸­ï¼Œå› ä¸ºç›®æ ‡bucketæ˜¯é€šè¿‡å“ˆå¸Œå–æ¨¡è®¡ç®—çš„ï¼Œè€Œè¿™æ—¶å€™bucketæ•°ç»„é•¿åº¦æ‰©å¤§äº†ä¸¤å€ï¼Œæ¯”å¦‚åŸç†æ•°ç»„é•¿åº¦æ˜¯4ï¼Œå–æ¨¡åæ˜¯3ï¼Œç°åœ¨æ•°ç»„é•¿åº¦æ˜¯8ï¼Œå–æ¨¡åå¯èƒ½ä¸º3ä¹Ÿå¯èƒ½ä¸º7\n\t\tif checkBucket != noCheck && !h.sameSizeGrow() {\n            // å¦‚æœkey==keyï¼Œæ­£å¸¸éƒ½æ˜¯èµ°è¿™ä¸ªé€»è¾‘\n\t\t\tif t.reflexivekey || alg.equal(k, k) { \n\t\t\t\t// å¦‚æœå½“å‰çš„keyä¸æ˜¯è½åœ¨å½“å‰çš„bucketä¸­çš„ï¼Œæ¯”å¦‚ç°åœ¨æ­£åœ¨éå†çš„bucketä¸º3ï¼Œä½†æ˜¯keyç°åœ¨çš„hashæ˜¯7ï¼Œä»¥åè¿ç§»æ—¶å°†è¿ç§»åˆ°ç´¢å¼•ä¸º7çš„bucketä¸­ï¼Œå› æ­¤è¿™ä¸ªæ—¶å€™åº”è¯¥è·³è¿‡è¿™ä¸ªkey\n\t\t\t\thash := alg.hash(k, uintptr(h.hash0))\n\t\t\t\tif hash&bucketMask(it.B) != checkBucket {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else { // key != keyçš„æƒ…å†µï¼Œæ¯”å¦‚math.NaN() != math.NaN()\n\t\t\t\tif checkBucket>>(it.B-1) != uintptr(b.tophash[offi]&1) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} \n\t\t}\n        // èµ°åˆ°è¿™é‡Œï¼Œå¯èƒ½æœ‰ä¸€ç§æƒ…å†µï¼Œåœ¨è¿­ä»£å¼€å§‹ä¹‹åå‘ç”Ÿäº†æ‰©å®¹ï¼ˆæ¯”å¦‚æˆ‘ä»¬åœ¨for-rangeé‡Œé¢æ’å…¥æ–°çš„é”®å€¼å¯¹ï¼Œè¿™æ—¶å€™è§¦å‘äº†è¿ç§»ï¼‰ï¼Œè¿™æ—¶å€™è¿­ä»£çš„æ˜¯æ‰©å®¹ä¹‹å‰çš„é”®å€¼å¯¹ï¼Œå³åªä¼šè¿­ä»£å½“å‰çš„oldbucketsé‡Œé¢é”®å€¼å¯¹ï¼Œè¿™æ—¶å€™å¦‚æœè¿™äº›é”®å€¼å¯¹è¿˜æ²¡æœ‰å‘ç”Ÿè¿ç§»æˆ–è€…è¯´keyæ˜¯ä¸å¯æ¯”è¾ƒçš„ï¼Œæ¯”å¦‚keyä¸ºmath.NAN()ï¼Œå› ä¸ºkey!=keyï¼Œå› æ­¤è¿™ä¸ªkeyä¸ä¼šè¢«åˆ é™¤æˆ–è€…æ›´æ–°ï¼Œå¯ä»¥ç›´æ¥è¿”å›\n\t\tif (b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY) ||\n\t\t\t!(t.reflexivekey || alg.equal(k, k)) {\n\t\t\tit.key = k\n\t\t\tif t.indirectvalue {\n\t\t\t\tv = *((*unsafe.Pointer)(v))\n\t\t\t}\n\t\t\tit.value = v\n\t\t} else { // èµ°åˆ°è¿™é‡Œè¯´æ˜å‘ç”Ÿäº†è¿ç§»ï¼Œä½¿ç”¨mapaccessKæ¥è·å–\n\t\t\trk, rv := mapaccessK(t, h, k)\n\t\t\tif rk == nil { // å·²ç»è¢«åˆ é™¤äº†\n\t\t\t\tcontinue // key has been deleted\n\t\t\t}\n\t\t\tit.key = rk\n\t\t\tit.value = rv\n\t\t}\n        // æ›´æ–°è¿­ä»£å™¨çŠ¶æ€\n\t\tit.bucket = bucket\n\t\tif it.bptr != b { // avoid unnecessary write barrier; see issue 14921\n\t\t\tit.bptr = b\n\t\t}\n\t\tit.i = i + 1\n\t\tit.checkBucket = checkBucket\n\t\treturn\n\t}\n    // å½“å‰bmapéå†å®Œæˆï¼Œéå†ä¸‹ä¸€ä¸ªbmapï¼Œå¦‚æœå·²ç»æ˜¯bmapé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™è¿”å›çš„bä¸ºnilï¼Œè¿™æ—¶å€™ä¼šè§¦å‘éå†ä¸‹ä¸€ä¸ªbucket\n\tb = b.overflow(t)\n\ti = 0\n\tgoto next\n}\n```\n\n\n\n### æ‰©å®¹\n\nå½“å†™å…¥æ—¶ï¼Œå¦‚æœå½“å‰`bucket`å·²ç»æ»¡äº†ï¼Œåˆ™ä¼šè§¦å‘æ‰©å®¹æ£€æŸ¥ï¼Œå¦‚æœå½“å‰ä¸å¤„äºæ‰©å®¹çŠ¶æ€å¹¶ä¸”æ»¡è¶³ï¼š\n\n- å½“å‰é”®å€¼å¯¹ä¸ªæ•°å·²ç»è¾¾åˆ° `0.65*2^B`\n- å½“å‰`overflow bucket`æ•°é‡è¾¾åˆ°`1<<(B&15)`ï¼Œè¿™é‡Œçš„`B`å¦‚æœå¤§äº15ï¼ŒæŒ‰ç…§15è®¡ç®—\n\nä¸‹é¢çœ‹ä¸€ä¸‹å¼€å§‹æ‰©å®¹çš„é€»è¾‘ï¼š\n\n```go\nfunc hashGrow(t *maptype, h *hmap) {\n\t// If we've hit the load factor, get bigger.\n\t// Otherwise, there are too many overflow buckets,\n\t// so keep the same number of buckets and \"grow\" laterally.\n\tbigger := uint8(1)\n    // å¦‚æœé”®å€¼å¯¹æ•°é‡æ²¡æœ‰è¾¾åˆ°é˜ˆå€¼ï¼Œåˆ™è¯´æ˜æ˜¯overflow bucketæ•°é‡è¿‡å¤šè§¦å‘çš„\n\tif !overLoadFactor(h.count+1, h.B) {\n\t\tbigger = 0 // è¿™é‡Œå°†biggerè®¾ç½®æˆäº†0\n\t\t// è®¾ç½®æ ‡å¿—ä½ï¼Œç”¨äºåç»­åŒºåˆ†æ˜¯å“ªç§æƒ…å†µè§¦å‘çš„æ‰©å®¹\n\t\t// å¦‚æœæ˜¯overflow bucketæ•°é‡è¿‡å¤šè§¦å‘çš„ï¼Œå®é™…ä¸Šå¹¶ä¸ä¼šå¢åŠ bucketçš„æ•°é‡\n\t\t// å› æ­¤ç§°ä½œsameSizeGrow\n\t\th.flags |= sameSizeGrow\n\t}\n\n\t// ä¿å­˜åŸæ¥çš„bucketsåˆ°oldbuckets\n\toldbuckets := h.buckets\n\t// åˆ†é…æ–°çš„buckets\n\t// å¦‚æœæ˜¯é”®å€¼å¯¹è¾¾åˆ°é˜ˆå€¼è§¦å‘çš„æ‰©å®¹ï¼Œbucketæ•°é‡ä¸ºåŸæ¥çš„2å€ï¼Œä¹Ÿå°±æ˜¯æ‰©å±•bucketsæ•°ç»„\n\t// å¦åˆ™ç»´æŒåŸæ¥çš„æ•°é‡\n\tnewbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)\n\t// è®¾ç½®æ›´æ–°è¿­ä»£æ ‡å¿—ä½\n\tflags := h.flags &^ (iterator | oldIterator)\n\tif h.flags&iterator != 0 {\n\t\tflags |= oldIterator\n\t}\n\t// commit the grow (atomic wrt gc)\n    // æ›´æ–°hmapå­—æ®µ\n\th.B += bigger\n\th.flags = flags\n\th.oldbuckets = oldbuckets\n\th.buckets = newbuckets\n\th.nevacuate = 0\n\th.noverflow = 0\n\n\tif h.extra != nil && h.extra.overflow != nil {\n\t\t// Promote current overflow buckets to the old generation.\n\t\tif h.extra.oldoverflow != nil {\n\t\t\tthrow(\"oldoverflow is not nil\")\n\t\t}\n\t\th.extra.oldoverflow = h.extra.overflow\n\t\th.extra.overflow = nil\n\t}\n\tif nextOverflow != nil {\n\t\tif h.extra == nil {\n\t\t\th.extra = new(mapextra)\n\t\t}\n\t\th.extra.nextOverflow = nextOverflow\n\t}\n\n\t// the actual copying of the hash table data is done incrementally\n\t// by growWork() and evacuate().\n}\n```\n\nå†æ¥çœ‹ä¸€ä¸‹`bucket`çš„è¿ç§»æ“ä½œï¼š\n\n```go\nfunc growWork(t *maptype, h *hmap, bucket uintptr) {\n\t// è¿ç§»æ­£åœ¨ä½¿ç”¨çš„bucketå¯¹åº”çš„oldbucketçš„æ•°æ®\n\tevacuate(t, h, bucket&h.oldbucketmask())\n\n\t// ç»§ç»­å¯¹h.nevacuateå¯¹åº”çš„bucketè¿›è¡Œè¿ç§»ï¼Œè®©è¿ç§»å°½å¿«å®Œæˆ\n\tif h.growing() {\n\t\tevacuate(t, h, h.nevacuate)\n\t}\n}\n```\n\nä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œä¸€æ¬¡`growwork`æœ€å¤šå¯ä»¥è¿ç§»ä¸¤ä¸ª`bucket`ï¼Œè¿™æ ·å¯ä»¥å°½æ—©å®Œæˆæ‰©å®¹ä¹‹åçš„è¿ç§»\n\næ¥ç€çœ‹ä¸€ä¸‹`evacuate`çš„é€»è¾‘ï¼š\n\n```go\nfunc evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n    // è®¡ç®—è¦è¿›è¡Œè¿ç§»çš„bucket\n\tb := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n\tnewbit := h.noldbuckets() // è·å–oldbucketsæ•°ç»„çš„é•¿åº¦\n    // å¦‚æœè¿˜æ²¡æœ‰æ‰§è¡Œè¿‡è¿ç§»\n\tif !evacuated(b) {\n\t\t// ä¸€ä¸ªoldbucketä¸­çš„keyå¯èƒ½è¿ç§»åˆ°ä¸¤ä¸ªæ–°çš„bucketä¸­ï¼Œè¿™é‡Œä½¿ç”¨xæ¥è¡¨ç¤ºä½ä½ç›®æ ‡bucketï¼Œyè¡¨ç¤ºé«˜ä½ç›®æ ‡bucket\n\t\tvar xy [2]evacDst\n\t\tx := &xy[0]\n        // ä½ä½ç›®æ ‡bucketçš„ç´¢å¼•å’Œå½“å‰è¦è¿ç§»çš„oldbucketçš„ç´¢å¼•ä¸€è‡´\n\t\tx.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))\n\t\tx.k = add(unsafe.Pointer(x.b), dataOffset)\n\t\tx.v = add(x.k, bucketCnt*uintptr(t.keysize))\n\t\t// å¦‚æœæ˜¯sameSizeGrowï¼Œbucketsé•¿åº¦æ²¡æœ‰å˜åŒ–ï¼Œåˆ™ä¸ä¼šæœ‰é«˜ä½ç›®æ ‡bucket\n\t\tif !h.sameSizeGrow() {\n\t\t\t// Only calculate y pointers if we're growing bigger.\n\t\t\t// Otherwise GC can see bad pointers.\n\t\t\ty := &xy[1]\n            // è®¡ç®—é«˜ä½ç›®æ ‡bucket\n\t\t\ty.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))\n\t\t\ty.k = add(unsafe.Pointer(y.b), dataOffset)\n\t\t\ty.v = add(y.k, bucketCnt*uintptr(t.keysize))\n\t\t}\n\t\t// éå†bucketå¯¹åº”çš„bmapé“¾è¡¨\n\t\tfor ; b != nil; b = b.overflow(t) {\n\t\t\tk := add(unsafe.Pointer(b), dataOffset)\n\t\t\tv := add(k, bucketCnt*uintptr(t.keysize))\n\t\t\tfor i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {\n\t\t\t\ttop := b.tophash[i]\n\t\t\t\tif top == empty { // ç©ºæ§½ï¼Œæ²¡æœ‰é”®å€¼å¯¹\n\t\t\t\t\tb.tophash[i] = evacuatedEmpty\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif top < minTopHash {\n\t\t\t\t\tthrow(\"bad map state\")\n\t\t\t\t}\n\t\t\t\tk2 := k\n\t\t\t\tif t.indirectkey {\n\t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n\t\t\t\t}\n\t\t\t\tvar useY uint8\n                // ä¸æ˜¯sameSizeGrowï¼Œè¯´æ˜å¯èƒ½ä¼šè¿ç§»åˆ°é«˜ä½ç›®æ ‡bucket\n\t\t\t\tif !h.sameSizeGrow() {\n\t\t\t\t\thash := t.key.alg.hash(k2, uintptr(h.hash0))\n                    // å­˜åœ¨è¿­ä»£å™¨ï¼Œå¹¶ä¸”key!=key(NaNs)ï¼Œä¸€èˆ¬ä¸ä¼šèµ°è¿™ä¸ªåˆ†æ”¯\n\t\t\t\t\tif h.flags&iterator != 0 && !t.reflexivekey && !t.key.alg.equal(k2, k2) {\n\t\t\t\t\t\tuseY = top & 1\n\t\t\t\t\t\ttop = tophash(hash)\n\t\t\t\t\t} else {\n                        // æ¯”å¦‚hashæ˜¯7ï¼Œoldbucketsé•¿åº¦æ˜¯4ï¼Œç°åœ¨æ˜¯8ï¼ŒåŸæ¥bucketæ˜¯3ï¼Œç°åœ¨åº”è¯¥è¿ç§»åˆ°7è¿™ä¸ªbucketï¼Œè¿™ç§æƒ…å†µhash&newbit=newbit    \n\t\t\t\t\t\tif hash&newbit != 0 {\n\t\t\t\t\t\t\tuseY = 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                // è¿™é‡Œæ˜¯å¯¹å…¨å±€å¸¸é‡è¿›è¡Œæ£€æŸ¥ï¼ševacuatedY=evacuatedX+1\n                // evacuatedXæ ‡è®°è¿ç§»åˆ°ä½ä½ç›®æ ‡bucket\n                // evacuatedYæ ‡è®°è¿ç§»åˆ°é«˜ä½ç›®æ ‡bucket\n\t\t\t\tif evacuatedX+1 != evacuatedY {\n\t\t\t\t\tthrow(\"bad evacuatedN\")\n\t\t\t\t}\n\t\t\t\t// å¯¹å½“å‰æ§½è¿›è¡Œæ ‡è®°ï¼Œè¡¨ç¤ºå·²ç»å®Œæˆè¿ç§»\n\t\t\t\tb.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY\n                // æ ¹æ®æ˜¯å¦è¿ç§»åˆ°é«˜ä½bucketé€‰æ‹©ç›®æ ‡bucket\n\t\t\t\tdst := &xy[useY]                 // evacuation destination\n\t\t\t\t// å¦‚æœå½“å‰bmapæ»¡äº†ï¼Œåˆ›å»ºæ–°çš„bmap\n\t\t\t\tif dst.i == bucketCnt {\n\t\t\t\t\tdst.b = h.newoverflow(t, dst.b)\n\t\t\t\t\tdst.i = 0\n\t\t\t\t\tdst.k = add(unsafe.Pointer(dst.b), dataOffset)\n\t\t\t\t\tdst.v = add(dst.k, bucketCnt*uintptr(t.keysize))\n\t\t\t\t}\n                // æ‰§è¡Œé”®å€¼å¯¹è¿ç§»\n\t\t\t\tdst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check\n\t\t\t\tif t.indirectkey {\n\t\t\t\t\t*(*unsafe.Pointer)(dst.k) = k2 // copy pointer\n\t\t\t\t} else {\n\t\t\t\t\ttypedmemmove(t.key, dst.k, k) // copy value\n\t\t\t\t}\n\t\t\t\tif t.indirectvalue {\n\t\t\t\t\t*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)\n\t\t\t\t} else {\n\t\t\t\t\ttypedmemmove(t.elem, dst.v, v)\n\t\t\t\t}\n              \t// æ›´æ–°è¿ç§»ç›®æ ‡çŠ¶æ€\n\t\t\t\tdst.i++\n\t\t\t\t// These updates might push these pointers past the end of the\n\t\t\t\t// key or value arrays.  That's ok, as we have the overflow pointer\n\t\t\t\t// at the end of the bucket to protect against pointing past the\n\t\t\t\t// end of the bucket.\n\t\t\t\tdst.k = add(dst.k, uintptr(t.keysize))\n\t\t\t\tdst.v = add(dst.v, uintptr(t.valuesize))\n\t\t\t}\n\t\t}\n\t\t// Unlink the overflow buckets & clear key/value to help GC.\n        // å¦‚æœä¸å­˜åœ¨å¯¹oldbucketsçš„è¿­ä»£å™¨å¹¶ä¸”é”®å€¼å¯¹ä¸­åŒ…å«æŒ‡é’ˆï¼Œåœ¨oldbucketsæ¸…é™¤å½“å‰è¿ç§»çš„bucketï¼Œå¸®åŠ©å°½å¿«gcæ‰è¿™äº›æ²¡æœ‰ç”¨çš„å†…å­˜\n\t\tif h.flags&oldIterator == 0 && t.bucket.kind&kindNoPointers == 0 {\n\t\t\tb := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))\n\t\t\t// Preserve b.tophash because the evacuation\n\t\t\t// state is maintained there.\n\t\t\tptr := add(b, dataOffset)\n\t\t\tn := uintptr(t.bucketsize) - dataOffset\n\t\t\tmemclrHasPointers(ptr, n)\n\t\t}\n\t}\n\t// å¦‚æœå½“å‰è¿ç§»çš„bucketç­‰äºh.nevacuateåˆ™æ›´æ–°h.nevacuateçš„å€¼\n    // å¦‚æœæ‰€æœ‰bucketéƒ½å·²ç»è¿ç§»å®Œæˆï¼Œåˆ™æ¶ˆé™¤æ‰©å®¹çŠ¶æ€\n\tif oldbucket == h.nevacuate {\n\t\tadvanceEvacuationMark(h, t, newbit)\n\t}\n}\n```\n\n\n\n\n\n\n\n","tags":["go"]},{"title":"goä¸­çš„çŒ´å­è¡¥ä¸","url":"/2019/03/06/goä¸­çš„çŒ´å­è¡¥ä¸/","content":"\n### å‡½æ•°å€¼\n\né¦–å…ˆæŸ¥çœ‹ä¸‹é¢ä»£ç ï¼š\n\n```go \nfunc a()int {return 1}\n\nfunc main() {\n\tfmt.Printf(\"%p\\n\", a) // 0x48f950\n\tfn := a\n\tfmt.Printf(\"0x%x\\n\",*(*uintptr)(unsafe.Pointer(&fn))) // 0x4c8680\n\tfmt.Printf(\"0x%x\\n\", **(**uintptr)(unsafe.Pointer(&fn))) // 0x48f950\n}\n```\n\næ ¹æ®ä¸Šé¢çš„è¾“å‡ºæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå‡½æ•°å€¼`fn`å¹¶æ²¡æœ‰ç›´æ¥æŒæœ‰å‡½æ•°`a`çš„åœ°å€ï¼Œè¿™æ˜¯å› ä¸º**`Go`çš„å‡½æ•°å€¼å¯ä»¥åŒ…å«ä¸€äº›é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯**ï¼Œè¿™æ˜¯å®ç°é—­åŒ…å’Œç»‘å®šå®ä¾‹æ–¹æ³•çš„å…³é”®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨[æºç ](https://github.com/golang/go/blob/e9d9d0befc634f6e9f906b5ef7476fbd7ebd25e3/src/runtime/runtime2.go#L75-L78)ä¸­æ‰¾åˆ°ç‚¹å‡½æ•°å€¼ç±»å‹çš„çº¿ç´¢ï¼š\n\n```go\ntype funcval struct {\n\tfn uintptr\n\t// variable-size, fn-specific data here\n}\n```\n\næˆ‘ä»¬ä»£ç ä¸­çš„å‡½æ•°å˜é‡ï¼Œå®é™…ä¸Šåº”è¯¥`*funcval`ç±»å‹\n\n##### é—­åŒ…å®ç°åŸç†\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¢ç©¶ä¸€ä¸‹`golang`ä¸­é—­åŒ…çš„å®ç°åŸç†ï¼Œæˆ‘ä»¬é¦–å…ˆå†™ä¸€ä¸ªç®€å•çš„é—­åŒ…demoï¼Œç„¶åä»ç¼–è¯‘åçš„æ±‡ç¼–ä»£ç æ¥æ¢ç©¶å…¶å®ç°\n\n```go\nfunc main() {\n\tf := fn() // è¿™é‡Œçš„fæ˜¯ä¸€ä¸ªå‡½æ•°å€¼\n\tf()\n}\n\nfunc fn() func() {\n\tvar a = 10\n\treturn func() {\n\t\tfmt.Println(a) // æ•è·å±€éƒ¨å˜é‡a\n\t}\n}\n```\n\næ¥ä¸‹æ¥å°†ä¸Šé¢ä»£ç ç¼–è¯‘æˆæ±‡ç¼–ï¼š\n\n```sh\n$ go tool compile -S -N main.go > asm.s\n```\n\nä¸‹é¢æ˜¯ç”Ÿæˆçš„æ±‡ç¼–ï¼Œåªä¿ç•™ä¸»è¦çš„å†…å®¹ï¼š\n\n```assembly\n\"\".main STEXT size=72 args=0x0 locals=0x18\n\t0x0000 00000 (demo.go:7)\tTEXT\t\"\".main(SB), $24-0\n\t0x0024 00036 (demo.go:8)\tCALL\t\"\".fn(SB) # è°ƒç”¨fnå‡½æ•°è·å–\n\t0x0029 00041 (demo.go:8)\tMOVQ\t(SP), DX # ä¿å­˜è¿”å›çš„å‡½æ•°å€¼æŒ‡é’ˆåˆ°DXï¼Œè¿™é‡Œçš„DXæ˜¯å…³é”®\n\t0x002d 00045 (demo.go:8)\tMOVQ\tDX, \"\".f+8(SP) # æŠŠDXçš„å€¼èµ‹ç»™å±€éƒ¨å˜é‡f \n\t0x0032 00050 (demo.go:9)\tMOVQ\t(DX), AX # ä»ä¸Šé¢funcvalç»“æ„å¯çŸ¥ï¼Œ(DX)ä¸ºå®é™…å‡½æ•°åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢çš„\"\".fn.func1\n\t0x0035 00053 (demo.go:9)\tCALL\tAX # è°ƒç”¨å®é™…çš„å‡½æ•°\n\t0x0040 00064 (demo.go:10)\tRET\n\n\"\".fn STEXT size=136 args=0x8 locals=0x28\n\t0x0000 00000 (demo.go:12)\tTEXT\t\"\".fn(SB), $40-8\n\t0x0036 00054 (demo.go:14)\tLEAQ\ttype.noalg.struct { F uintptr; \"\".a int }(SB), AX # è¿™é‡Œè¡¨ç¤ºå®é™…funcvalçš„ç±»å‹\n\t0x003d 00061 (demo.go:14)\tMOVQ\tAX, (SP)\n\t0x0041 00065 (demo.go:14)\tCALL\truntime.newobject(SB) # newä¸€ä¸ªfuncval\n\t0x0046 00070 (demo.go:14)\tMOVQ\t8(SP), AX # è¿”å›å€¼\n\t0x0050 00080 (demo.go:14)\tLEAQ\t\"\".fn.func1(SB), CX # å–å®é™…å‡½æ•°åœ°å€\n\t0x0057 00087 (demo.go:14)\tMOVQ\tCX, (AX) # ä¿å­˜å®é™…åœ°å€\n\t0x0061 00097 (demo.go:14)\tMOVQ\t\"\".a+16(SP), CX # ä¿å­˜å˜é‡aåˆ°funcval\n\t0x0066 00102 (demo.go:14)\tMOVQ\tCX, 8(AX) \n\t0x006f 00111 (demo.go:14)\tMOVQ\tAX, \"\".~r0+48(SP) # è®¾ç½®è¿”å›å€¼\n\t0x007d 00125 (demo.go:14)\tRET\n\n\"\".fn.func1 STEXT size=258 args=0x0 locals=0x88\n\t0x0000 00000 (demo.go:14)\tTEXT\t\"\".fn.func1(SB), NEEDCTXT, $136-0\n\t0x0036 00054 (demo.go:14)\tMOVQ\t8(DX), AX\t# [DX+8]å®é™…ä¸Šå­˜å‚¨çš„å°±æ˜¯é—­åŒ…å¼•ç”¨å¤–éƒ¨çš„å˜é‡a\n\t0x003a 00058 (demo.go:14)\tMOVQ\tAX, \"\".a+48(SP) # å°†AXèµ‹å€¼ç»™å˜é‡a\n\t0x003f 00063 (demo.go:15)\tMOVQ\tAX, \"\"..autotmp_2+56(SP)\n\t0x0056 00086 (demo.go:15)\tLEAQ\ttype.int(SB), AX # fmt.Printlnå‡½æ•°å®é™…æ¥æ”¶çš„æ˜¯[]interface{}ï¼Œè¿™é‡Œéœ€è¦å…ˆå°†aè½¬æ¢æˆinterface{}ç±»å‹\n\t0x005d 00093 (demo.go:15)\tMOVQ\tAX, (SP)\n\t0x0061 00097 (demo.go:15)\tMOVQ\t\"\"..autotmp_2+56(SP), AX\n\t0x0066 00102 (demo.go:15)\tMOVQ\tAX, 8(SP)\n\t0x006b 00107 (demo.go:15)\tCALL\truntime.convT2E64(SB)\n```\n\nä»ä¸Šé¢æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ`go`çš„é—­åŒ…æ˜¯é€šè¿‡`funcval`æºå¸¦é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯æ¥å®ç°çš„ã€‚\n\nå½“åˆ›å»ºé—­åŒ…å‡½æ•°æ—¶ï¼Œå°†è¢«é—­åŒ…æ•è·çš„å˜é‡çš„åœ°å€ä¿å­˜åˆ°`funcval`ï¼Œå½“è°ƒç”¨é—­åŒ…å‡½æ•°æ—¶ï¼Œä¼šå°†`funcval`çš„åœ°å€ä¿å­˜åˆ°`DX`å¯„å­˜å™¨ï¼Œæ‰§è¡Œé—­åŒ…å‡½æ•°æ—¶ï¼Œå¯ä»¥é€šè¿‡`DX`å¯„å­˜å™¨æ¥è®¿é—®è¿™äº›å˜é‡ã€‚\n\n\n\n### å®ç°çŒ´å­è¡¥ä¸\n\nç°åœ¨ï¼Œæˆ‘ä»¬è¦åœ¨`go`ä¸­å®ç°çŒ´å­è¡¥ä¸ï¼Œæ‰€æƒ³è¦å®ç°çš„æ•ˆæœæ˜¯ï¼š\n\n```go\nfunc a() {\n\tfmt.Println(\"run a\")\n}\nfunc b() {\n\tfmt.Println(\"run b\")\n}\n\nfunc main() {\n\ta() // run a\n\treplace(a, b)\n\ta() // run b\n}\n```\n\næˆ‘ä»¬è¦åœ¨`replace`æ–¹æ³•ä¸­ï¼Œå°†å¯¹å‡½æ•°`a`çš„è°ƒç”¨æ›¿æ¢æˆå¯¹å‡½æ•°`b`çš„è°ƒç”¨ã€‚\n\nå…·ä½“å®ç°ï¼š\n\n```go\nfunc replace(a, b func()) {\n\treplaceFunction(**(**uintptr)(unsafe.Pointer(&a)), *(*uintptr)(unsafe.Pointer(&b)))\n}\n\n// from is a pointer to the actual function\n// to is a pointer to a go funcvalue\nfunc replaceFunction(from, to uintptr) {\n    // demoåªæ”¯æŒ64bit\n\tif unsafe.Sizeof(uintptr(1)) != 8 {\n\t\tpanic(\"only support amd64\")\n\t}\n    // jmpToFunctionValueç”Ÿæˆè·³è½¬åˆ°toä»£è¡¨çš„å‡½æ•°çš„æœºå™¨ç \n\tjumpData := jmpToFunctionValue(to)\n    // ä½¿ç”¨ç”Ÿæˆçš„æœºå™¨ç æ›¿æ¢fromå‡½æ•°\n\tcopyToLocation(from, jumpData)\n\treturn\n}\n\n// movabs rdx,to # toæ˜¯ä¸€ä¸ª*funcvalï¼Œéœ€è¦å°†å…¶å­˜å‚¨åˆ°DXå¯„å­˜å™¨ï¼Œrdxæ˜¯64bitçš„DXå¯„å­˜å™¨\n// jmp QWORD PTR [rdx] # è·³è½¬åˆ°toå¯¹åº”çš„å®é™…å‡½æ•°çš„å¼€å§‹å¤„æ‰§è¡Œ\nfunc jmpToFunctionValue(to uintptr) []byte {\n\treturn []byte{\n\t\t0x48, 0xBA,\n\t\tbyte(to),\n\t\tbyte(to >> 8),\n\t\tbyte(to >> 16),\n\t\tbyte(to >> 24),\n\t\tbyte(to >> 32),\n\t\tbyte(to >> 40),\n\t\tbyte(to >> 48),\n\t\tbyte(to >> 56), // movabs rdx,to\n\t\t0xFF, 0x22,     // jmp QWORD PTR [rdx]\n\t}\n}\n\n// å†…å­˜æ›¿æ¢ï¼Œå› ä¸ºcodeæ‰€åœ¨çš„ä»£ç æ®µé»˜è®¤æ˜¯åªè¯»çš„ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨mprotectå°†å…¶æ›´æ”¹ä¸ºå¯å†™çš„\nfunc copyToLocation(location uintptr, data []byte) {\n\tf := rawMemoryAccess(location, len(data))\n\tmprotectCrossPage(location, len(data), syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC)\n\tcopy(f, data[:])\n\tmprotectCrossPage(location, len(data), syscall.PROT_READ|syscall.PROT_EXEC)\n}\n\n// å°†æŒ‡å®šå†…å­˜åœ°å€è½¬æ¢æˆä¸€ä¸ªslice\nfunc rawMemoryAccess(p uintptr, length int) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(&reflect.SliceHeader{\n\t\tData: p,\n\t\tLen:  length,\n\t\tCap:  length,\n\t}))\n}\n\n// ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨mprotectä¿®æ”¹æŒ‡å®šå†…å­˜çš„è®¿é—®æƒé™\nfunc mprotectCrossPage(addr uintptr, length int, prot int) {\n\tpageSize := syscall.Getpagesize()\n\tfor p := pageStart(addr); p < addr+uintptr(length); p += uintptr(pageSize) {\n\t\tpage := rawMemoryAccess(p, pageSize)\n\t\terr := syscall.Mprotect(page, prot)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// å†…å­˜é¡µå¯¹é½\nfunc pageStart(ptr uintptr) uintptr {\n\treturn ptr & ^(uintptr(syscall.Getpagesize() - 1))\n}\n```\n\nå½“æ‰§è¡Œ`replace(a,b)`æ—¶ï¼Œä¼šåŠ¨æ€å°†å‡½æ•°`a`çš„æŒ‡ä»¤æ›¿æ¢æˆ`movabs rdx,to; jmp QWORD PTR [rdx]`\n\nä¹‹åè°ƒç”¨å‡½æ•°`a`æ—¶ï¼Œä¼šæ‰§è¡Œ`call`æŒ‡ä»¤ï¼Œè¿™æ—¶å€™ä¼šæŠŠä¼ é€’ç»™å‡½æ•°`a`çš„å‚æ•°ä¿å­˜åˆ°æ ˆä¸Šï¼Œå¹¶ä¸”å°†è¿”å›åœ°å€ä¿å­˜åˆ°æŒ‡å®šçš„å¯„å­˜å™¨`RA`ä¸­ï¼›\n\nå› ä¸ºå‡½æ•°`a`è¢«æ›¿æ¢æˆä¸Šè¯‰ä¸¤æ¡æŒ‡ä»¤ï¼Œå› æ­¤ä¼šè·³è½¬åˆ°å‡½æ•°`b`æ‰§è¡Œï¼Œè¿™æ—¶å€™å‡½æ•°`b`å¯ä»¥ç›´æ¥ä½¿ç”¨æ ˆä¸Šçš„å‚æ•°ï¼ˆè¿™å°±è¦æ±‚ä¸¤ä¸ªå‡½æ•°è¦æœ‰ç›¸åŒçš„å‡½æ•°ç­¾åï¼‰ï¼›å› ä¸º`morestack`æ“ä½œæ˜¯åœ¨å‡½æ•°å¼€å§‹æ‰§è¡Œçš„æ—¶å€™è¿›è¡Œæ£€æŸ¥çš„ï¼Œå› æ­¤ä¸ä¼šæœ‰æ ˆæº¢å‡ºçš„é—®é¢˜ã€‚\n\nå½“å‡½æ•°`b`æ‰§è¡Œå®Œæˆæ—¶ï¼Œä¼šæ‰§è¡Œ`ret`æŒ‡ä»¤ï¼Œè¿™æ—¶å€™ä¼šæŠŠè¿”å›å€¼ä¿å­˜åˆ°æ ˆä¸Šï¼ŒåŒæ—¶å°†`RA`ä¸­çš„è¿”å›åœ°å€å¼¹å‡ºåˆ°`PC`å¯„å­˜å™¨ä¸­ï¼›\n\nå¯¹äºå‡½æ•°è°ƒç”¨è€…æ¥è¯´ï¼Œæ•´ä¸ªè¿‡ç¨‹æ˜¯é€æ˜çš„ã€‚\n\n\n\n### refer\n\n[monkey patching in Go](https://bou.ke/blog/monkey-patching-in-go/)\n\n[bouk/monkey](https://github.com/bouk/monkey)","tags":["go"]},{"title":"net/rpcåˆ†æ","url":"/2019/02/28/net-rpcåˆ†æ/","content":"\n### rpc\n\n`golang`æœ¬èº«æä¾›äº†`net/rpc`æ ‡å‡†åº“ï¼Œç”¨äºæä¾›`rpc`æœåŠ¡ã€‚\n\n`rpc`é€šè¿‡å°†ç½‘ç»œä¼ è¾“å’Œæ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–å±è”½åœ¨æ¥å£èƒŒåï¼Œæä¾›ä¸€ç§ç®€æ´çš„è°ƒç”¨æ¥å£ï¼Œå·²è¾¾åˆ°è°ƒç”¨è¿œç¨‹æœåŠ¡æ–¹æ³•åœ¨æ‰§è¡Œæœ¬åœ°æ–¹æ³•ä¸€æ ·ã€‚\n\n### server \n\n##### service\n\n`service`ä»£è¡¨æ¯ä¸ªæ³¨å†Œçš„æœåŠ¡\n\n```go\ntype methodType struct {\n\tsync.Mutex \t\t\t\t  // protects counters\n\tmethod     reflect.Method // æ–¹æ³•ä¿¡æ¯\n\tArgType    reflect.Type   // ç¬¬ä¸€ä¸ªå‚æ•°ç±»å‹\n\tReplyType  reflect.Type   // ç¬¬äºŒä¸ªå‚æ•°ç±»å‹ï¼Œè¯¥å‚æ•°ç”¨æ¥è¿”å›ç»“æœ\n\tnumCalls   uint           // ç»Ÿè®¡è°ƒç”¨æ¬¡æ•°\n}\n\ntype service struct {\n\tname   string                 // æœåŠ¡å\n\trcvr   reflect.Value          // æœåŠ¡å¯¹è±¡çš„å€¼\n\ttyp    reflect.Type           // æœåŠ¡å¯¹è±¡çš„ç±»å‹\n\tmethod map[string]*methodType // è¯¥æœåŠ¡å¯¹å¤–æä¾›çš„æ–¹æ³•\n}\n```\n\n##### server\n\n`server`ä»£è¡¨ä¸€ä¸ª`rpc server`\n\n```go\ntype Server struct {\n\tserviceMap sync.Map     // æ³¨å†Œçš„æœåŠ¡ï¼šmap[string]*service\n\treqLock    sync.Mutex   // protects freeReq\n\tfreeReq    *Request     // ç¼“å­˜Requeståˆ—è¡¨ï¼Œé¿å…æ¯æ¬¡è¯·æ±‚éƒ½è¦é‡æ–°åˆ›å»ºä¸€ä¸ª\n\trespLock   sync.Mutex   // protects freeResp\n\tfreeResp   *Response\n}\n```\n\n##### Request & Response\n\n```go \n// Request is a header written before every RPC call. It is used internally\n// but documented here as an aid to debugging, such as when analyzing\n// network traffic.\ntype Request struct {\n\tServiceMethod string   // format: \"Service.Method\"\n\tSeq           uint64   // è¯·æ±‚çš„Seqï¼Œå®¢æˆ·ç«¯ä¼šå¯¹è¯·æ±‚è¿›è¡Œç¼–å·ï¼Œç”¨äºåŒºåˆ†ä¸åŒçš„è¯·æ±‚\n\tnext          *Request // for free list in Server\n}\n\n// Response is a header written before every RPC return. It is used internally\n// but documented here as an aid to debugging, such as when analyzing\n// network traffic.\ntype Response struct {\n\tServiceMethod string    // echoes that of the Request\n\tSeq           uint64    // echoes that of the request\n\tError         string    // error, if any.\n\tnext          *Response // for free list in Server\n}\n```\n\n##### Register\n\n```go\nfunc (server *Server) Register(rcvr interface{}) error {\n\t// ä½¿ç”¨åå°„åä½œä¸ºæœåŠ¡åç§°\n    return server.register(rcvr, \"\", false)\n}\n\nfunc (server *Server) RegisterName(name string, rcvr interface{}) error {\n    // è‡ªå®šä¹‰æœåŠ¡åç§°\n   return server.register(rcvr, name, true)\n}\n\nfunc (server *Server) register(rcvr interface{}, name string, useName bool) error {\n   s := new(service) \n   s.typ = reflect.TypeOf(rcvr)   // è®¾ç½®ç±»å‹\n   s.rcvr = reflect.ValueOf(rcvr) // è®¾ç½®å€¼\n   // é»˜è®¤å–ç±»å‹å\n   sname := reflect.Indirect(s.rcvr).Type().Name()\n   if useName { // å¦‚æœéœ€è¦ä½¿ç”¨è‡ªå®šä¹‰åç§°\n      sname = name\n   }\n   if sname == \"\" {\n      s := \"rpc.Register: no service name for type \" + s.typ.String()\n      log.Print(s)\n      return errors.New(s)\n   }\n    // å¦‚æœè¯¥serviceä¸æ˜¯å¯¼å‡ºç±»å‹ï¼Œä¿é”™\n   if !isExported(sname) && !useName {\n      s := \"rpc.Register: type \" + sname + \" is not exported\"\n      log.Print(s)\n      return errors.New(s)\n   }\n   s.name = sname\n\n   // å­˜æ‰¾è¯¥servicesç”¨äºæä¾›å¯¹å¤–æœåŠ¡çš„æ–¹æ³•\n   s.method = suitableMethods(s.typ, true)\n\t// æ–¹æ³•æ•°å¿…é¡»å¤§äº0\n   if len(s.method) == 0 {\n      str := \"\"\n\n      // To help the user, see if a pointer receiver would work.\n      method := suitableMethods(reflect.PtrTo(s.typ), false)\n      if len(method) != 0 {\n         str = \"rpc.Register: type \" + sname + \" has no exported methods of suitable type (hint: pass a pointer to value of that type)\"\n      } else {\n         str = \"rpc.Register: type \" + sname + \" has no exported methods of suitable type\"\n      }\n      log.Print(str)\n      return errors.New(str)\n   }\n\t// ä¸å…è®¸åŒä¸€ä¸ªæœåŠ¡åç§°é‡å¤æ³¨å†Œ\n   if _, dup := server.serviceMap.LoadOrStore(sname, s); dup {\n      return errors.New(\"rpc: service already defined: \" + sname)\n   }\n   return nil\n}\n```\n\n`suitableMethods`ç”¨æ¥æŸ¥æ‰¾`service`ä¸­éœ€è¦æš´éœ²çš„æ–¹æ³•ï¼Œå®ç°å°±æ˜¯éå†è¯¥`service`çš„æ‰€æœ‰æ–¹æ³•ï¼Œå¹¶è¿”å›å…¶ä¸­ç¬¦åˆæ¡ä»¶çš„æ–¹æ³•\n\n```go \nfunc suitableMethods(typ reflect.Type, reportErr bool) map[string]*methodType {\n\tmethods := make(map[string]*methodType)\n    // éå†æ–¹æ³•\n\tfor m := 0; m < typ.NumMethod(); m++ {\n\t\tmethod := typ.Method(m)\n\t\tmtype := method.Type\n\t\tmname := method.Name\n\t\t// Method must be exported.\n        // å¦‚æœmethodæ˜¯å¯¼å‡ºçš„ï¼ˆæ–¹æ³•åé¦–å­—æ¯å¤§å†™ï¼‰ï¼ŒPkgPathä¸ºç©º\n\t\tif method.PkgPath != \"\" { \n\t\t\tcontinue\n\t\t}\n\t\t// Method needs three ins: receiver, *args, *reply.\n        // å‚æ•°ä¸ªæ•°å¿…é¡»ä¸º3ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºserviceå¯¹è±¡\n\t\tif mtype.NumIn() != 3 {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: method %q has %d input parameters; needs exactly three\\n\", mname, mtype.NumIn())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// First arg need not be a pointer.\n\t\t// ç¬¬äºŒä¸ªå‚æ•°å¿…é¡»æ˜¯å†…ç½®ç±»å‹æˆ–è€…è‡ªå®šä¹‰çš„å¯¼å‡ºç±»å‹ï¼Œä¸éœ€è¦æ˜¯æŒ‡é’ˆç±»å‹\n        argType := mtype.In(1)\n\t\tif !isExportedOrBuiltinType(argType) {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: argument type of method %q is not exported: %q\\n\", mname, argType)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// Second arg must be a pointer.\n\t\treplyType := mtype.In(2)\n        // ç¬¬ä¸‰ä¸ªå‚æ•°å¿…é¡»æ˜¯æŒ‡é’ˆç±»å‹ï¼Œè¯¥å‚æ•°ç”¨æ¥å‘å®¢æˆ·ç«¯è¿”å›è¯·æ±‚ç»“æœ\n\t\tif replyType.Kind() != reflect.Ptr {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: reply type of method %q is not a pointer: %q\\n\", mname, replyType)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// Reply type must be exported.\n        // è¯¥å‚æ•°ä¹Ÿå¿…é¡»æ˜¯å†…ç½®ç±»å‹æˆ–è€…å¯¼å‡ºç±»å‹\n\t\tif !isExportedOrBuiltinType(replyType) {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: reply type of method %q is not exported: %q\\n\", mname, replyType)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// Method needs one out.\n        // æ–¹æ³•å¿…é¡»æœ‰ä¸”åªæœ‰ä¸€ä¸ªerrorç±»å‹çš„è¿”å›å€¼\n\t\tif mtype.NumOut() != 1 {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: method %q has %d output parameters; needs exactly one\\n\", mname, mtype.NumOut())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// The return type of the method must be error.\n\t\tif returnType := mtype.Out(0); returnType != typeOfError {\n\t\t\tif reportErr {\n\t\t\t\tlog.Printf(\"rpc.Register: return type of method %q is %q, must be error\\n\", mname, returnType)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n        // ç¬¦åˆæ¡ä»¶ï¼Œæ·»åŠ \n\t\tmethods[mname] = &methodType{method: method, ArgType: argType, ReplyType: replyType}\n\t}\n\treturn methods\n}\n```\n\n##### å¯åŠ¨æœåŠ¡\n\n```go \nfunc (server *Server) Accept(lis net.Listener) {\n   for {\n      conn, err := lis.Accept()\n      if err != nil {\n         log.Print(\"rpc.Serve: accept:\", err.Error())\n         return\n      }\n      // æ¯ä¸ªå®¢æˆ·å¯ç”¨ä¸€ä¸ªgoroutineè¿›è¡Œå¤„ç†\n      go server.ServeConn(conn)\n   }\n}\n```\n\n##### å¤„ç†è¯·æ±‚\n\n```go\nfunc (server *Server) ServeConn(conn io.ReadWriteCloser) {\n\tbuf := bufio.NewWriter(conn)\n    // é»˜è®¤ä½¿ç”¨gobç¼–è§£ç \n\tsrv := &gobServerCodec{\n\t\trwc:    conn,\n\t\tdec:    gob.NewDecoder(conn),\n\t\tenc:    gob.NewEncoder(buf),\n\t\tencBuf: buf,\n\t}\n\tserver.ServeCodec(srv)\n}\n\nfunc (server *Server) ServeCodec(codec ServerCodec) {\n\tsending := new(sync.Mutex) // å†™responseå†…å®¹æ—¶éœ€è¦åŠ é”\n\twg := new(sync.WaitGroup)\n\tfor {\n        // ä»è¿æ¥ä¸­è¯»å–è¯·æ±‚ï¼Œä¸»è¦æ˜¯é€šè¿‡gobEncoderå®ç°\n\t\tservice, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)\n\t\tif err != nil {\n\t\t\tif debugLog && err != io.EOF {\n\t\t\t\tlog.Println(\"rpc:\", err)\n\t\t\t}\n\t\t\tif !keepReading {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// send a response if we actually managed to read a header.\n\t\t\tif req != nil {\n\t\t\t\tserver.sendResponse(sending, req, invalidRequest, codec, err.Error())\n\t\t\t\tserver.freeRequest(req)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\twg.Add(1)\n        // æ¯ä¸ªrpcéƒ½ä½¿ç”¨ä¸€ä¸ªgoroutineè¿›è¡Œå¤„ç†\n\t\tgo service.call(server, sending, wg, mtype, req, argv, replyv, codec)\n\t}\n\t// ä¼˜é›…å…³é—­\n\twg.Wait()\n\tcodec.Close()\n}\n```\n\n```go\nfunc (s *service) call(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec) {\n\tif wg != nil {\n\t\tdefer wg.Done()\n\t}\n\tmtype.Lock()\n\tmtype.numCalls++ // ç»Ÿè®¡è°ƒç”¨æ¬¡æ•°\n\tmtype.Unlock()\n\tfunction := mtype.method.Func\n\t// è°ƒç”¨å…·ä½“çš„è¯·æ±‚æ–¹æ³•\n\treturnValues := function.Call([]reflect.Value{s.rcvr, argv, replyv})\n\t// The return value for the method is an error.\n\terrInter := returnValues[0].Interface()\n\terrmsg := \"\"\n    // å¦‚æœè¯·æ±‚æ–¹æ³•è¿”å›error\n\tif errInter != nil {\n\t\terrmsg = errInter.(error).Error()\n\t}\n    // å†™å…¥å“åº”ç»“æœï¼Œè¿™é‡Œä¸»è¦é€šè¿‡gob.Decoderå®ç°\n\tserver.sendResponse(sending, req, replyv.Interface(), codec, errmsg)\n\t// é‡Šæ”¾req\n    server.freeRequest(req)\n}\n```\n\n### client\n\n##### client\n\n```go\ntype Client struct {\n\tcodec ClientCodec // codec\n\n\treqMutex sync.Mutex // protects following\n\trequest  Request\n\n\tmutex    sync.Mutex // protects following\n\tseq      uint64 // ä¸‹ä¸€æ¬¡è¯·æ±‚çš„seq\n\tpending  map[uint64]*Call // æ­£åœ¨æ‰§è¡Œçš„è¯·æ±‚\n\tclosing  bool // user has called Close\n\tshutdown bool // server has told us to stop\n}\n```\n\n##### Call\n\n```go\ntype Call struct {\n   ServiceMethod string      // è°ƒç”¨çš„è¿œç¨‹æ–¹æ³•\n   Args          interface{} // æ–¹æ³•ç¬¬ä¸€ä¸ªå‚æ•°\n   Reply         interface{} // ç¬¬äºŒä¸ªå‚æ•°ï¼Œç”¨äºæ¥æ”¶è¿”å›å€¼\n   Error         error       // ä¿å­˜è¯·æ±‚çš„é”™è¯¯ä¿¡æ¯\n   Done          chan *Call  // ç”¨äºé€šçŸ¥è¯·æ±‚ç»“æŸ\n}\n```\n\n\n\n##### NewClient\n\n```go\nfunc NewClient(conn io.ReadWriteCloser) *Client {\n\tencBuf := bufio.NewWriter(conn)\n\tclient := &gobClientCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(encBuf), encBuf}\n\treturn NewClientWithCodec(client)\n}\n\nfunc NewClientWithCodec(codec ClientCodec) *Client {\n\tclient := &Client{\n\t\tcodec:   codec,\n\t\tpending: make(map[uint64]*Call),\n\t}\n\tgo client.input() // inputç”¨æ¥å¤„ç†serverçš„å“åº”\n\treturn client\n}\n\n```\n\n\n\n##### Call\n\nä½¿ç”¨æ–¹æ³•`Call`å’Œæ–¹æ³•`Go`è°ƒç”¨è¿œç¨‹æ–¹æ³•ï¼Œå…¶ä¸­`Call`ä¼šåŒæ­¥ç­‰å¾…è¯·æ±‚ç»“æŸï¼Œ`Go`æ˜¯å¼‚æ­¥æ‰§è¡Œ\n\n```go \nfunc (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error {\n    // Callæ–¹æ³•å†…éƒ¨ä¹Ÿæ˜¯è°ƒç”¨Goï¼Œç„¶åç­‰å¾…è°ƒç”¨å®Œæˆåè¿”å›\n\tcall := <-client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done\n\treturn call.Error\n}\n\n// Goæ–¹æ³•è¿”å›ä¸€ä¸ªchannelç”¨æ¥é€šçŸ¥è°ƒç”¨ç»“æŸ\nfunc (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call {\n\tcall := new(Call)\n\tcall.ServiceMethod = serviceMethod\n\tcall.Args = args\n\tcall.Reply = reply\n    \n\tif done == nil {\n\t\tdone = make(chan *Call, 10) // buffered.\n\t} else {\n\t\t// If caller passes done != nil, it must arrange that\n\t\t// done has enough buffer for the number of simultaneous\n\t\t// RPCs that will be using that channel. If the channel\n\t\t// is totally unbuffered, it's best not to run at all.\n        if cap(done) == 0 {\n\t\t\tlog.Panic(\"rpc: done channel is unbuffered\")\n\t\t}\n\t}\n\tcall.Done = done\n\tclient.send(call)\n\treturn call\n}\n\n// sendæ‰§è¡Œå®é™…çš„è¯·æ±‚å‘é€\nfunc (client *Client) send(call *Call) {\n\tclient.reqMutex.Lock()\n\tdefer client.reqMutex.Unlock()\n\n\t// Register this call.\n\tclient.mutex.Lock()\n\tif client.shutdown || client.closing {\n\t\tclient.mutex.Unlock()\n\t\tcall.Error = ErrShutdown\n\t\tcall.done()\n\t\treturn\n\t}\n\tseq := client.seq // è·å–æ­¤æ¬¡è¯·æ±‚seq\n\tclient.seq++ // è®¡ç®—ä¸‹ä¸€æ¬¡è¯·æ±‚seq\n\tclient.pending[seq] = call // åŠ å…¥pendingåˆ—è¡¨ä¸­\n\tclient.mutex.Unlock() \n\n\t// Encode and send the request.\n\tclient.request.Seq = seq\n\tclient.request.ServiceMethod = call.ServiceMethod\n    // å‘é€è¯·æ±‚\n\terr := client.codec.WriteRequest(&client.request, call.Args)\n\tif err != nil {\n\t\tclient.mutex.Lock()\n\t\tcall = client.pending[seq]\n\t\tdelete(client.pending, seq)\n\t\tclient.mutex.Unlock()\n\t\tif call != nil {\n\t\t\tcall.Error = err\n\t\t\tcall.done()\n\t\t}\n\t}\n}\n```\n\nåˆ†æä¸Šé¢çš„`send`æ–¹æ³•ï¼Œå½“è¯·æ±‚å‘é€å‡ºå»ä¹‹åå°±è¿”å›äº†ï¼Œé‚£ä¹ˆå¦‚ä½•å¤„ç†è¯·æ±‚çš„å“åº”å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¯æ¬¡æ–°çš„è¯·æ±‚éƒ½ä¼šåŠ å…¥åˆ°`client.pending`ä¸­ï¼Œé‚£ä¹ˆå¯¹åº”çš„åº”è¯¥æœ‰ä¸€ä¸ªå¹•åçš„åç¨‹æ¥å¤„ç†ï¼Œå½“æ”¶åˆ°`server`çš„å“åº”æ—¶ï¼Œæ ¹æ®`seq`è·å–å¯¹åº”çš„`call`ï¼Œç„¶åé€šè¿‡`call.Done`é€šçŸ¥è¯·æ±‚å®Œæˆï¼Œ\n\nå¯¹åº”çš„æ–¹æ³•ä¸º`input`ï¼š\n\n```go\nfunc (client *Client) input() {\n\tvar err error\n\tvar response Response\n\tfor err == nil {\n\t\tresponse = Response{}\n        // è¯»å–serverçš„è¿”å›ç»“æœ\n\t\terr = client.codec.ReadResponseHeader(&response)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n        // è·å–è¿™æ¬¡å“åº”å¯¹åº”çš„è¯·æ±‚çš„seq\n\t\tseq := response.Seq\n\t\tclient.mutex.Lock()\n        // è·å–å¯¹åº”çš„è¯·æ±‚\n\t\tcall := client.pending[seq]\n\t\tdelete(client.pending, seq)\n\t\tclient.mutex.Unlock()\n\t\t// å¤„ç†å“åº”ç»“æœ\n\t\tswitch {\n\t\tcase call == nil:\n\t\t\t// We've got no pending call. That usually means that\n\t\t\t// WriteRequest partially failed, and call was already\n\t\t\t// removed; response is a server telling us about an\n\t\t\t// error reading request body. We should still attempt\n\t\t\t// to read error body, but there's no one to give it to.\n\t\t\terr = client.codec.ReadResponseBody(nil)\n\t\t\tif err != nil {\n\t\t\t\terr = errors.New(\"reading error body: \" + err.Error())\n\t\t\t}\n\t\tcase response.Error != \"\":\n\t\t\t// We've got an error response. Give this to the request;\n\t\t\t// any subsequent requests will get the ReadResponseBody\n\t\t\t// error if there is one.\n\t\t\tcall.Error = ServerError(response.Error)\n\t\t\terr = client.codec.ReadResponseBody(nil)\n\t\t\tif err != nil {\n\t\t\t\terr = errors.New(\"reading error body: \" + err.Error())\n\t\t\t}\n\t\t\tcall.done()\n\t\tdefault:\n\t\t\terr = client.codec.ReadResponseBody(call.Reply)\n\t\t\tif err != nil {\n\t\t\t\tcall.Error = errors.New(\"reading body \" + err.Error())\n\t\t\t}\n\t\t\tcall.done()\n\t\t}\n\t}\n    // å‘ç”Ÿé”™è¯¯é€€å‡ºä¹‹åï¼Œåœæ­¢æ‰€æœ‰ç­‰å¾…çš„è¯·æ±‚\n\t// Terminate pending calls.\n\tclient.reqMutex.Lock()\n\tclient.mutex.Lock()\n\tclient.shutdown = true\n\tclosing := client.closing\n\tif err == io.EOF {\n\t\tif closing {\n\t\t\terr = ErrShutdown\n\t\t} else {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t}\n    // åœæ­¢æ‰€æœ‰ç­‰å¾…çš„è¯·æ±‚\n\tfor _, call := range client.pending {\n\t\tcall.Error = err\n\t\tcall.done()\n\t}\n\tclient.mutex.Unlock()\n\tclient.reqMutex.Unlock()\n\tif debugLog && err != io.EOF && !closing {\n\t\tlog.Println(\"rpc: client protocol error:\", err)\n\t}\n}\n\n// é€šçŸ¥è°ƒç”¨ç»“æŸ\nfunc (call *Call) done() {\n\tselect {\n\tcase call.Done <- call:\n\t\t// ok\n\tdefault:\n\t\t// We don't want to block here. It is the caller's responsibility to make\n\t\t// sure the channel has enough buffer space. See comment in Go().\n\t\tif debugLog {\n\t\t\tlog.Println(\"rpc: discarding Call reply due to insufficient Done chan capacity\")\n\t\t}\n\t}\n}\n```\n\n","tags":["go"]},{"title":"sliceæ‰©å®¹","url":"/2019/02/26/sliceæ‰©å®¹/","content":"\n### slice header \n\ngoä¸­çš„`slice`å£°æ˜å¦‚ä¸‹ï¼š\n\n```go\ntype slice struct {\n\tarray unsafe.Pointer // æŒ‡å‘åº•å±‚æ•°ç»„\n\tlen   int // é•¿åº¦ï¼Œå½“å‰å­˜å‚¨çš„å…ƒç´ ä¸ªæ•°\n\tcap   int // å®¹é‡ï¼Œåº•å±‚æ•°ç»„çš„é•¿åº¦\n}\n```\n\n### grow\n\n`slice`ä¸­çš„`len`è¡¨ç¤ºå½“å‰åˆ‡ç‰‡ä¸­å­˜åœ¨çš„å…ƒç´ ä¸ªæ•°ï¼Œè€Œ`cap`è¡¨ç¤ºåˆ‡è¾¹åº•å±‚æ•°ç»„æ€»å…±å¯ä»¥å­˜æ”¾çš„å…ƒç´ ä¸ªæ•°ï¼Œ\n\nå½“æˆ‘ä»¬ä½¿ç”¨`append`å‡½æ•°ä¸ºåˆ‡ç‰‡è¿½åŠ å…ƒç´ æ—¶ï¼Œå¦‚æœåº•å±‚æ•°ç»„å‰©ä½™å®¹é‡`cap-len`ä¸è¶³ä»¥å®¹çº³æ–°çš„å…ƒç´ ï¼Œåˆ™ä¼šå‘ç”Ÿæ‰©å®¹ï¼Œå…·ä½“çš„æ‰©å®¹é€»è¾‘å¦‚ä¸‹ï¼š\n\n```go \n// @params et: sliceå…ƒç´ ç±»å‹\n// @params old: è€çš„slice\n// @params cap: æœŸå¾…çš„æœ€å°capå€¼ï¼Œè¿™é‡Œçš„capç­‰äº(old.len + appendçš„å…ƒç´ ä¸ªæ•°)\n// @return: æ–°çš„sliceï¼Œå¹¶ä¸”æ‹·è´è€çš„æ•°æ®åˆ°æ–°çš„slice\nfunc growslice(et *_type, old slice, cap int) slice {\n    // å¦‚æœå…ƒç´ ä¸éœ€è¦å­˜å‚¨ç©ºé—´ï¼Œæ¯”å¦‚ç±»å‹struct{}\n\tif et.size == 0 {\n\t\tif cap < old.cap {\n\t\t\tpanic(errorString(\"growslice: cap out of range\"))\n\t\t}\n        // ç›´æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„sliceï¼Œä¸éœ€è¦å†…å­˜åˆ†é…\n        // è¿™é‡Œzerobaseæ˜¯ä¸€ä¸ªå€¼ä¸º0çš„uintptr\n\t\treturn slice{unsafe.Pointer(&zerobase), old.len, cap}\n\t}\n\t\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\t// å¦‚æœx2ä¸èƒ½æ»¡è¶³ï¼Œåˆ™ä½¿ç”¨æœŸå¾…å€¼\n    if cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n        // å¦åˆ™ï¼Œå¦‚æœå…ƒç´ ä¸ªæ•°å°äº1024ï¼Œç›´æ¥x2\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n            // æŒç»­1.25å€ç›´åˆ°æ»¡è¶³\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// å¦‚æœæº¢å‡ºäº†ï¼Œç›´æ¥ä½¿ç”¨æœŸå¾…å€¼\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n\n\tvar overflow bool\n    // åŸæ¥å…ƒç´ å ç”¨å†…å­˜å¤§å°ï¼Œç°åœ¨å…ƒç´ å ç”¨å†…å­˜å¤§å°ï¼Œæ–°çš„åº•å±‚æ•°ç»„å®¹é‡å¤§å°\n\tvar lenmem, newlenmem, capmem uintptr\n\t// è®¡ç®—ä¸Šé¢å£°æ˜çš„å˜é‡å€¼ï¼Œè¿™é‡Œæ ¹æ®et.sizeè¿›è¡Œä¼˜åŒ–\n\tswitch {\n\tcase et.size == 1: // ä¸éœ€è¦ä¹˜é™¤æ³•\n\t\tlenmem = uintptr(old.len)\n\t\tnewlenmem = uintptr(cap)\n\t\tcapmem = roundupsize(uintptr(newcap)) \n\t\toverflow = uintptr(newcap) > maxAlloc\n\t\tnewcap = int(capmem)\n\tcase et.size == sys.PtrSize: // ä¼šåˆ«ä¼˜åŒ–æˆç§»ä½è¿ç®—\n\t\tlenmem = uintptr(old.len) * sys.PtrSize\n\t\tnewlenmem = uintptr(cap) * sys.PtrSize\n\t\tcapmem = roundupsize(uintptr(newcap) * sys.PtrSize)\n\t\toverflow = uintptr(newcap) > maxAlloc/sys.PtrSize\n\t\tnewcap = int(capmem / sys.PtrSize)\n\tcase isPowerOfTwo(et.size): // ä½è¿ç®—\n\t\tvar shift uintptr\n\t\tif sys.PtrSize == 8 {\n\t\t\t// Mask shift for better code generation.\n\t\t\tshift = uintptr(sys.Ctz64(uint64(et.size))) & 63\n\t\t} else {\n\t\t\tshift = uintptr(sys.Ctz32(uint32(et.size))) & 31\n\t\t}\n\t\tlenmem = uintptr(old.len) << shift\n\t\tnewlenmem = uintptr(cap) << shift\n\t\tcapmem = roundupsize(uintptr(newcap) << shift)\n\t\toverflow = uintptr(newcap) > (maxAlloc >> shift)\n\t\tnewcap = int(capmem >> shift)\n\tdefault:\n\t\tlenmem = uintptr(old.len) * et.size\n\t\tnewlenmem = uintptr(cap) * et.size\n\t\tcapmem = roundupsize(uintptr(newcap) * et.size)\n\t\toverflow = uintptr(newcap) > maxSliceCap(et.size)\n\t\tnewcap = int(capmem / et.size)\n\t}\n\n\t// The check of overflow (uintptr(newcap) > maxSliceCap(et.size))\n\t// in addition to capmem > _MaxMem is needed to prevent an overflow\n\t// which can be used to trigger a segfault on 32bit architectures\n\t// with this example program:\n\t//\n\t// type T [1<<27 + 1]int64\n\t//\n\t// var d T\n\t// var s []T\n\t//\n\t// func main() {\n\t//   s = append(s, d, d, d, d)\n\t//   print(len(s), \"\\n\")\n\t// }\n\tif cap < old.cap || overflow || capmem > maxAlloc {\n\t\tpanic(errorString(\"growslice: cap out of range\"))\n\t}\n\n\tvar p unsafe.Pointer\n    // åˆ‡ç‰‡å…ƒç´ å†…ä¸åŒ…å«æŒ‡é’ˆ\n\tif et.kind&kindNoPointers != 0 {\n        // åˆ†é…æ–°çš„åº•å±‚æ•°ç»„ï¼Œè¿™é‡ŒfalseæŒ‡ç¤ºä¸éœ€è¦å†…å­˜æ¸…é›¶\n\t\tp = mallocgc(capmem, nil, false)\n        // ä¸åŒ…å«æŒ‡é’ˆï¼Œå†…å­˜æ‹·è´\n\t\tmemmove(p, old.array, lenmem)\n\t\t// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).\n\t\t// Only clear the part that will not be overwritten.\n        // æ–°æ•°ç»„ä¸­æœªè¢«ä½¿ç”¨çš„å†…å­˜æ¸…é›¶\n\t\tmemclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\n\t} else {\n\t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n        // å› ä¸ºå…ƒç´ ä¸­åŒ…å«æŒ‡é’ˆï¼Œåƒåœ¾æ”¶é›†å™¨éœ€è¦è·Ÿè¸ªæŒ‡é’ˆï¼Œå› æ­¤åˆ†é…å†…å­˜æ—¶éœ€è¦åœ¨ä½å›¾ä¸­æ ‡è®°æŒ‡é’ˆçš„ä½ç½®\n\t\tp = mallocgc(capmem, et, true)\n\t\t// æ²¡æœ‰å¼€å¯å†™å±éšœï¼Œç›´æ¥æ‹·è´å†…å­˜\n        if !writeBarrier.enabled {\n\t\t\tmemmove(p, old.array, lenmem)\n\t\t} else { // gcä¸­ï¼Œå¼€å¯äº†å†™å±éšœ\n\t\t\tfor i := uintptr(0); i < lenmem; i += et.size {\n\t\t\t\ttypedmemmove(et, add(p, i), add(old.array, i))\n\t\t\t}\n\t\t}\n\t}\n\t// è¿”å›æ–°çš„slice\n\treturn slice{p, old.len, newcap}\n}\n\n```\n\n\n\n### turn string to []byte\n\nå½“æ‰§è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå°†`string`ç±»å‹è½¬æ¢æˆ`[]byte`æ—¶ï¼Œä¼šæ‰§è¡Œ`stringtoslicebyte`ï¼š\n\n```go\n// The constant is known to the compiler.\n// There is no fundamental theory behind this number.\nconst tmpStringBufSize = 32\n\ntype tmpBuf [tmpStringBufSize]byte\n// è¿™é‡Œçš„tmpBufæ˜¯ä¸€ä¸ªé•¿åº¦ä¸º32çš„æ•°ç»„\nfunc stringtoslicebyte(buf *tmpBuf, s string) []byte {\n   var b []byte\n   // å¦‚æœbufä¸ä¸ºç©ºå¹¶ä¸”å­—ç¬¦ä¸²é•¿åº¦å°äº32ï¼Œç›´æ¥ä½¿ç”¨buf\n   if buf != nil && len(s) <= len(buf) { \n      *buf = tmpBuf{} // æ¸…é›¶\n      b = buf[:len(s)]\n   } else {\n      b = rawbyteslice(len(s))\n   }\n   copy(b, s)\n   return b\n}\n```\n\næ ¹æ®ä¸Šé¢çš„é€»è¾‘ï¼Œå½“å¯¹é•¿åº¦å°äº32çš„å°å­—ç¬¦ä¸²è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢æ—¶ï¼Œä¼šè¿”å›ä¸€ä¸ª`cap`ä¸º32çš„`slice`","tags":["go"]},{"title":"channelæºç åˆ†æ","url":"/2019/01/31/channelæºç åˆ†æ/","content":"\n`channel`æ˜¯`go`ä¸­çš„ä¸€ç§æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨æ¥å®ç°å¹¶å‘æ§åˆ¶ã€åç¨‹é—´é€šä¿¡ã€...\n\n### ç»“æ„å®šä¹‰\n\n`channel`ç»“æ„åœ¨`runtime`ä¸­çš„å®šä¹‰å¦‚ä¸‹ï¼š\n\n```go\ntype hchan struct {\n\tqcount   uint           // total data in the queue\n\tdataqsiz uint           // size of the circular queueï¼Œç¼“å†²åŒºæ˜¯ä¸€ä¸ªç¯å½¢é˜Ÿåˆ—\n\tbuf      unsafe.Pointer // points to an array of dataqsiz elements\n\telemsize uint16\n\tclosed   uint32 // æ ‡è®°è¯¥channelæ˜¯å¦å·²ç»å…³é—­\n\telemtype *_type // element typeï¼Œè¯¥channelå†…æ•°æ®å…ƒç´ çš„ç±»å‹\n\tsendx    uint   // send index\n\trecvx    uint   // receive index\n\trecvq    waitq  // list of recv waitersï¼Œ\n\tsendq    waitq  // list of send waiters\n\n\t// lock protects all fields in hchan, as well as several\n\t// fields in sudogs blocked on this channel.\n\t//\n\t// Do not change another G's status while holding this lock\n\t// (in particular, do not ready a G), as this can deadlock\n\t// with stack shrinking.\n\tlock mutex\n}\n\ntype waitq struct {\n\tfirst *sudog // sudogå°è£…äº†é˜»å¡çš„g\n\tlast  *sudog\n}\n```\n\n### åˆ›å»ºchannel\n\nå½“æˆ‘ä»¬è¦åˆ›å»ºchannelæ—¶ï¼Œéœ€è¦ä½¿ç”¨`make`æ¥å£ï¼Œå¯¹åº”çš„åˆ›å»ºé€»è¾‘å¦‚ä¸‹ï¼š\n\n```go \ntype chantype struct {\n\ttyp  _type\n\telem *_type\n\tdir  uintptr\n}\n// å¯ä»¥çœ‹åˆ°è¿™é‡Œè¿”å›çš„æ˜¯*hchanï¼Œä¹Ÿè¯´æ˜æˆ‘ä»¬ä»£ç ä¸­çš„channelå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ \nfunc makechan(t *chantype, size int) *hchan {\n\telem := t.elem // channelçš„å…ƒç´ ç±»å‹\n\n\t// compiler checks this but be safe.\n\tif elem.size >= 1<<16 { \n\t\tthrow(\"makechan: invalid channel element type\")\n\t}\n   \t// å†…å­˜å¯¹é½æ ¡éªŒ\n\tif hchanSize%maxAlign != 0 || elem.align > maxAlign {\n\t\tthrow(\"makechan: bad alignment\")\n\t}\n\t// buf sizeæ ¡éªŒ\n\tif size < 0 || uintptr(size) > maxSliceCap(elem.size) || uintptr(size)*elem.size > maxAlloc-hchanSize {\n\t\tpanic(plainError(\"makechan: size out of range\"))\n\t}\n\n\t// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.\n\t// buf points into the same allocation, elemtype is persistent.\n\t// SudoG's are referenced from their owning thread so they can't be collected.\n\t// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.\n\tvar c *hchan\n\tswitch {\n\tcase size == 0 || elem.size == 0: // ç¼“å†²åŒºä¸º0\n\t\t// Queue or element size is zero.\n\t\tc = (*hchan)(mallocgc(hchanSize, nil, true))\n\t\t// Race detector uses this location for synchronization.\n\t\tc.buf = unsafe.Pointer(c)\n\tcase elem.kind&kindNoPointers != 0: // ä¸åŒ…å«æŒ‡é’ˆ\n\t\t// Elements do not contain pointers.\n\t\t// Allocate hchan and buf in one call.\n\t\tc = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))\n\t\tc.buf = add(unsafe.Pointer(c), hchanSize)\n\tdefault:\n\t\t// Elements contain pointers.\n        // åŒ…å«æŒ‡é’ˆï¼Œhchanå’Œbufè¦åˆ†å¼€åˆ†é…å†…å­˜\n\t\tc = new(hchan)\n\t\tc.buf = mallocgc(uintptr(size)*elem.size, elem, true)\n\t}\n\t// åˆå§‹åŒ–çŠ¶æ€\n\tc.elemsize = uint16(elem.size)\n\tc.elemtype = elem\n\tc.dataqsiz = uint(size)\n\n\tif debugChan {\n\t\tprint(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; elemalg=\", elem.alg, \"; dataqsiz=\", size, \"\\n\")\n\t}\n\treturn c\n}\n```\n\n### å†™å…¥channel\n\n```go\nfunc chansend1(c *hchan, elem unsafe.Pointer) {\n\tchansend(c, elem, true, getcallerpc())\n}\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n\t// å¾€ç©ºchannelå†™å…¥ï¼Œä¼šå¯¼è‡´é˜»å¡\n    if c == nil {\n\t\tif !block {\n\t\t\treturn false\n\t\t}\n\t\tgopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)\n\t\tthrow(\"unreachable\")\n\t}\n\n\tif debugChan {\n\t\tprint(\"chansend: chan=\", c, \"\\n\")\n\t}\n\n\tif raceenabled {\n\t\tracereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))\n\t}\n\n\t// Fast path: check for failed non-blocking operation without acquiring the lock.\n\t//\n\t// After observing that the channel is not closed, we observe that the channel is\n\t// not ready for sending. Each of these observations is a single word-sized read\n\t// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).\n\t// Because a closed channel cannot transition from 'ready for sending' to\n\t// 'not ready for sending', even if the channel is closed between the two observations,\n\t// they imply a moment between the two when the channel was both not yet closed\n\t// and not ready for sending. We behave as if we observed the channel at that moment,\n\t// and report that the send cannot proceed.\n\t//\n\t// It is okay if the reads are reordered here: if we observe that the channel is not\n\t// ready for sending and then observe that it is not closed, that implies that the\n\t// channel wasn't closed during the first observation.\n\tif !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||\n\t\t(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {\n\t\treturn false\n\t}\n\n\tvar t0 int64\n\tif blockprofilerate > 0 {\n\t\tt0 = cputicks()\n\t}\n\n\tlock(&c.lock)\n\t// channelå·²ç»å…³é—­ï¼Œpanic\n\tif c.closed != 0 {\n\t\tunlock(&c.lock)\n\t\tpanic(plainError(\"send on closed channel\"))\n\t}\n\t// å¦‚æœæœ‰é˜»å¡åœ¨å†™çš„gï¼Œç›´æ¥å‘é€ç»™è¿™ä¸ªg\n\tif sg := c.recvq.dequeue(); sg != nil {\n\t\t// Found a waiting receiver. We pass the value we want to send\n\t\t// directly to the receiver, bypassing the channel buffer (if any).\n\t\tsend(c, sg, ep, func() { unlock(&c.lock) }, 3)\n\t\treturn true\n\t}\n\t// buf channelå¹¶ä¸”æœ‰è¶³å¤Ÿbufï¼Œå†™å…¥buf\n\tif c.qcount < c.dataqsiz {\n\t\t// Space is available in the channel buffer. Enqueue the element to send.\n\t\tqp := chanbuf(c, c.sendx)\n\t\tif raceenabled {\n\t\t\traceacquire(qp)\n\t\t\tracerelease(qp)\n\t\t}\n\t\ttypedmemmove(c.elemtype, qp, ep)\n\t\tc.sendx++\n\t\tif c.sendx == c.dataqsiz {\n\t\t\tc.sendx = 0\n\t\t}\n\t\tc.qcount++\n\t\tunlock(&c.lock)\n\t\treturn true\n\t}\n\n\tif !block {\n\t\tunlock(&c.lock)\n\t\treturn false\n\t}\n\n\t// Block on the channel. Some receiver will complete our operation for us.\n    // å†™é˜»å¡\n\tgp := getg()\n\tmysg := acquireSudog()\n\tmysg.releasetime = 0\n\tif t0 != 0 {\n\t\tmysg.releasetime = -1\n\t}\n\t// No stack splits between assigning elem and enqueuing mysg\n\t// on gp.waiting where copystack can find it.\n\tmysg.elem = ep\n\tmysg.waitlink = nil\n\tmysg.g = gp\n\tmysg.isSelect = false\n\tmysg.c = c\n\tgp.waiting = mysg\n\tgp.param = nil\n\tc.sendq.enqueue(mysg)\n    // æŒ‚èµ·\n\tgoparkunlock(&c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)\n\t// è¿™é‡Œæ˜¯é˜»å¡è¢«å”¤é†’ä¹‹åçš„é€»è¾‘\n\t// someone woke us up.\n\tif mysg != gp.waiting {\n\t\tthrow(\"G waiting list is corrupted\")\n\t}\n\tgp.waiting = nil\n    // channelè¢«å…³é—­æ—¶ï¼Œä¼šè®¾ç½®gp.param=nil\n\tif gp.param == nil {\n\t\tif c.closed == 0 {\n\t\t\tthrow(\"chansend: spurious wakeup\")\n\t\t}\n        // è¯¥channelå·²ç»å…³é—­ï¼Œpanic\n\t\tpanic(plainError(\"send on closed channel\"))\n\t}\n\tgp.param = nil\n\tif mysg.releasetime > 0 {\n\t\tblockevent(mysg.releasetime-t0, 2)\n\t}\n\tmysg.c = nil\n\treleaseSudog(mysg)\n\treturn true\n}\n```\n\n\n\n### ä»channelè¯»å–\n\n```go \n// å•è¿”å›å€¼ç‰ˆæœ¬\nfunc chanrecv1(c *hchan, elem unsafe.Pointer) {\n\tchanrecv(c, elem, true)\n}\n\n// ä¸¤è¿”å›å€¼ç‰ˆæœ¬\nfunc chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {\n\t_, received = chanrecv(c, elem, true)\n\treturn\n}\n\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {\n\t// raceenabled: don't need to check ep, as it is always on the stack\n\t// or is new memory allocated by reflect.\n\n\tif debugChan {\n\t\tprint(\"chanrecv: chan=\", c, \"\\n\")\n\t}\n\t// ä»ç©ºchannelè¯»ä¼šå¯¼è‡´é˜»å¡\n\tif c == nil {\n\t\tif !block {\n\t\t\treturn\n\t\t}\n\t\tgopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)\n\t\tthrow(\"unreachable\")\n\t}\n\n\t// Fast path: check for failed non-blocking operation without acquiring the lock.\n\t//\n\t// After observing that the channel is not ready for receiving, we observe that the\n\t// channel is not closed. Each of these observations is a single word-sized read\n\t// (first c.sendq.first or c.qcount, and second c.closed).\n\t// Because a channel cannot be reopened, the later observation of the channel\n\t// being not closed implies that it was also not closed at the moment of the\n\t// first observation. We behave as if we observed the channel at that moment\n\t// and report that the receive cannot proceed.\n\t//\n\t// The order of operations is important here: reversing the operations can lead to\n\t// incorrect behavior when racing with a close.\n\tif !block && (c.dataqsiz == 0 && c.sendq.first == nil ||\n\t\tc.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&\n\t\tatomic.Load(&c.closed) == 0 {\n\t\treturn\n\t}\n\n\tvar t0 int64\n\tif blockprofilerate > 0 {\n\t\tt0 = cputicks()\n\t}\n\n\tlock(&c.lock)\n\t// å¦‚æœchannelå·²ç»å…³é—­ï¼Œå¹¶ä¸”ç¼“å†²åŒºå†…å…ƒç´ æ•°é‡ä¸º0ï¼Œåˆ™è¿”å›ç©ºå…ƒç´ \n\tif c.closed != 0 && c.qcount == 0 {\n\t\tif raceenabled {\n\t\t\traceacquire(unsafe.Pointer(c))\n\t\t}\n\t\tunlock(&c.lock)\n\t\tif ep != nil {\n\t\t\ttypedmemclr(c.elemtype, ep)\n\t\t}\n\t\treturn true, false // ç¬¬äºŒä¸ªè¿”å›å€¼falseè¡¨ç¤ºæ²¡æœ‰è¯»å–åˆ°çœŸæ­£çš„å†…å®¹\n\t}\n\t// å¦‚æœå­˜åœ¨ç­‰å¾…å†™çš„gï¼Œç›´æ¥ä»è¿™ä¸ªgè¯»å–\n\tif sg := c.sendq.dequeue(); sg != nil {\n\t\t// Found a waiting sender. If buffer is size 0, receive value\n\t\t// directly from sender. Otherwise, receive from head of queue\n\t\t// and add sender's value to the tail of the queue (both map to\n\t\t// the same buffer slot because the queue is full).\n\t\trecv(c, sg, ep, func() { unlock(&c.lock) }, 3)\n\t\treturn true, true\n\t}\n\t// å¦‚æœç¼“å†²åŒºå­˜åœ¨å…ƒç´ ï¼Œåˆ™è¯»å–ç¼“å†²åŒºå…ƒç´ \n    // channelå³ä½¿å·²ç»è¢«å…³é—­ï¼Œå¦‚æœç¼“å†²åŒºè¿˜æœ‰å…ƒç´ ï¼Œä»å¯ä»¥è¯»å–\n\tif c.qcount > 0 {\n\t\t// Receive directly from queue\n\t\tqp := chanbuf(c, c.recvx)\n\t\tif raceenabled {\n\t\t\traceacquire(qp)\n\t\t\tracerelease(qp)\n\t\t}\n\t\tif ep != nil {\n\t\t\ttypedmemmove(c.elemtype, ep, qp)\n\t\t}\n\t\ttypedmemclr(c.elemtype, qp)\n\t\tc.recvx++\n\t\tif c.recvx == c.dataqsiz {\n\t\t\tc.recvx = 0\n\t\t}\n\t\tc.qcount--\n\t\tunlock(&c.lock)\n\t\treturn true, true\n\t}\n\n\tif !block {\n\t\tunlock(&c.lock)\n\t\treturn false, false\n\t}\n\n\t// no sender available: block on this channel.\n    // é˜»å¡åœ¨å†™æ“ä½œ\n\tgp := getg()\n\tmysg := acquireSudog()\n\tmysg.releasetime = 0\n\tif t0 != 0 {\n\t\tmysg.releasetime = -1\n\t}\n\t// No stack splits between assigning elem and enqueuing mysg\n\t// on gp.waiting where copystack can find it.\n\tmysg.elem = ep\n\tmysg.waitlink = nil\n\tgp.waiting = mysg\n\tmysg.g = gp\n\tmysg.isSelect = false\n\tmysg.c = c\n\tgp.param = nil\n\tc.recvq.enqueue(mysg)\n    // æŒ‚èµ·\n\tgoparkunlock(&c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)\n\n    // è¿™ä¹‹åæ˜¯å”¤é†’ä¹‹åçš„é€»è¾‘\n\t// someone woke us up\n\tif mysg != gp.waiting {\n\t\tthrow(\"G waiting list is corrupted\")\n\t}\n\tgp.waiting = nil\n\tif mysg.releasetime > 0 {\n\t\tblockevent(mysg.releasetime-t0, 2)\n\t}\n\tclosed := gp.param == nil\n\tgp.param = nil\n\tmysg.c = nil\n\treleaseSudog(mysg)\n\t// å¦‚æœå·²ç»å…³é—­å°±è¿”å›false\n    return true, !closed\n}\n```\n\n\n\n### å…³é—­channel\n\n```go \n\nfunc closechan(c *hchan) {\n    // å¦‚æœå…³é—­nil channelï¼Œåˆ™panic\n\tif c == nil {\n\t\tpanic(plainError(\"close of nil channel\"))\n\t}\n\n\tlock(&c.lock)\n   \t// å¦‚æœchannelå·²ç»å…³é—­ï¼Œåˆ™panic\n\tif c.closed != 0 {\n\t\tunlock(&c.lock)\n\t\tpanic(plainError(\"close of closed channel\"))\n\t}\n\t// ç«äº‰æ£€æµ‹\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tracewritepc(unsafe.Pointer(c), callerpc, funcPC(closechan))\n\t\tracerelease(unsafe.Pointer(c))\n\t}\n\t// è®¾ç½®å…³é—­æ ‡å¿—ä½\n\tc.closed = 1\n\t// glistç”¨äºæ”¶é›†é‡Šæ”¾çš„g\n\tvar glist *g\n\n\t// release all readers\n    // å…³é—­æ—¶ï¼Œè¦é‡Šæ”¾æ‰€æœ‰é˜»å¡åœ¨è¯»æ“ä½œçš„åç¨‹\n\tfor {\n\t\tsg := c.recvq.dequeue()\n\t\tif sg == nil {\n\t\t\tbreak\n\t\t}\n        // ä»å·²å…³é—­çš„channelä¸­è¯»å–çš„éƒ½æ˜¯ç©ºå†…å®¹ï¼Œå› æ­¤è¿™é‡Œå°†å…ƒç´ å†…å­˜ç½®é›¶\n\t\tif sg.elem != nil {\n\t\t\ttypedmemclr(c.elemtype, sg.elem)\n\t\t\tsg.elem = nil\n\t\t}\n\t\tif sg.releasetime != 0 {\n\t\t\tsg.releasetime = cputicks()\n\t\t}\n        // ä»sudogä¸­è·å–é˜»å¡çš„g\n\t\tgp := sg.g\n\t\tgp.param = nil\n\t\tif raceenabled {\n\t\t\traceacquireg(gp, unsafe.Pointer(c))\n\t\t}\n        // é“¾è¡¨è®¾ç½®\n\t\tgp.schedlink.set(glist)\n\t\tglist = gp\n\t}\n\n\t// release all writers (they will panic)\n    // é‡Šæ”¾ç­‰å¾…å†™çš„channel\n\tfor {\n\t\tsg := c.sendq.dequeue()\n\t\tif sg == nil {\n\t\t\tbreak\n\t\t}\n\t\tsg.elem = nil\n\t\tif sg.releasetime != 0 {\n\t\t\tsg.releasetime = cputicks()\n\t\t}\n\t\tgp := sg.g\n\t\tgp.param = nil\n\t\tif raceenabled {\n\t\t\traceacquireg(gp, unsafe.Pointer(c))\n\t\t}\n\t\tgp.schedlink.set(glist)\n\t\tglist = gp\n\t}\n\tunlock(&c.lock)\n\n\t// Ready all Gs now that we've dropped the channel lock.\n    // å°†ä¸Šé¢é‡Šæ”¾çš„æ‰€æœ‰gè®¾ç½®ä¸ºå°±ç»ªçŠ¶æ€ï¼Œç­‰å¾…è°ƒåº¦\n\tfor glist != nil {\n\t\tgp := glist\n\t\tglist = glist.schedlink.ptr()\n\t\tgp.schedlink = 0\n\t\tgoready(gp, 3)\n\t}\n}\n\n```\n\n","tags":["go","channel"]},{"title":"golangæ‰§è¡Œcommand","url":"/2018/12/27/golangæ‰§è¡Œcommand/","content":"\n### åœ¨golangä¸­ä½¿ç”¨cmd\n\nåœ¨æ—¥å¸¸å¼€å‘ä¸­ï¼Œæˆ‘ä»¬æœ‰æ—¶å€™éœ€è¦åœ¨ç¨‹åºä¸­è°ƒç”¨ç³»ç»Ÿçš„å…¶ä»–æŒ‡ä»¤æ¥å®Œæˆä»»åŠ¡ï¼Œæ¯”å¦‚é€šè¿‡è°ƒç”¨`mysqldump`æ¥æ‰§è¡Œæ•°æ®åº“å¤‡ä»½ã€‚\n\n`golang`æä¾›äº†`Cmd`ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å¸®åŠ©æˆ‘ä»¬æ¥å®Œæˆè¿™äº›å†…å®¹ã€‚\n\n> Package exec runs external commands. It wraps os.StartProcess to make it\n> easier to remap stdin and stdout, connect I/O with pipes, and do other\n> adjustments.\n>\n> Unlike the \"system\" library call from C and other languages, the\n> os/exec package intentionally does not invoke the system shell and\n> does not expand any glob patterns or handle other expansions,\n> pipelines, or redirections typically done by shells. The package\n> behaves more like C's \"exec\" family of functions. To expand glob\n> patterns, either call the shell directly, taking care to escape any\n> dangerous input, or use the path/filepath package's Glob function.\n> To expand environment variables, use package os's ExpandEnv.\n\n### demo\n\n```go\nfunc Backup(p string){\n    cmd := exec.Cmd{}\n\tcmd.Path = \"/usr/bin/mysqldump\"\n    cmd.Args = []string{\"-uuname\", \"-ppasswd\", `db_name`}\n\tfd, err := os.OpenFile(p, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer fd.Close()\n\tcmd.Stderr = os.Stderr // é‡å®šå‘é”™è¯¯è¾“å‡ºï¼Œå¯ä»¥åœ¨æ§åˆ¶å°ä¸­çœ‹åˆ°å­è¿›ç¨‹çš„é”™è¯¯ä¿¡æ¯ï¼Œæ–¹ä¾¿æ’æŸ¥\n\tcmd.Stdout = fd // é‡å®šå‘cmdçš„è¾“å‡ºï¼Œä¿å­˜åˆ°ç›®æ ‡æ–‡ä»¶ä¸­\n\terr = cmd.Run() // Runå®é™…ä¸Šå°±æ˜¯Startå’ŒWaitçš„ç»„åˆï¼Œä¼šç­‰å¾…å­è¿›ç¨‹ç»“æŸæ‰è¿”å›ï¼Œå¦‚æœéœ€è¦å¼‚æ­¥ç›´æ¥ä½¿ç”¨Start\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Restore(p string) {\n\tcmd := exec.Cmd{}\n\tcmd.Path = \"/usr/bin/mysql\"\n    cmd.Args = []string{\"-uuname\", \"-ppasswd\", \"-Ddb_name\"}\n\tfd, err := os.Open(p)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer fd.Close()\n\tcmd.Stdin = fd // é‡å®šå‘æ ‡å‡†è¾“å‡ºä¸ºæ‰“å¼€æ–‡ä»¶\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\nå¦‚åŒä¸Šé¢`demo`æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é‡å®šå‘å­è¿›ç¨‹çš„`stdin`ï¼Œ`stdout`ï¼Œ`stderr`ç­‰\n\næ­¤å¤–ï¼Œ`Cmd`ä¹Ÿæä¾›äº†`Pipe`æ¥å£ï¼Œçœ‹ä¸€ä¸‹å®ç°ï¼š\n\n```go\nfunc (c *Cmd) StdinPipe() (io.WriteCloser, error) {\n\tif c.Stdin != nil {\n\t\treturn nil, errors.New(\"exec: Stdin already set\")\n\t}\n\tif c.Process != nil {\n\t\treturn nil, errors.New(\"exec: StdinPipe after process started\")\n\t}\n\tpr, pw, err := os.Pipe() // åˆ›å»ºä¸€æ¡ç®¡é“\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Stdin = pr // é‡å®šå‘æ ‡å‡†è¾“å‡ºä¸ºè¯»å–ç«¯\n\tc.closeAfterStart = append(c.closeAfterStart, pr)\n\twc := &closeOnce{File: pw} // åŒ…è£…ç®¡é“çš„å†™å‡ºç«¯\n\tc.closeAfterWait = append(c.closeAfterWait, wc)\n\treturn wc, nil // è¿”å›\n}\n```\n\nç®¡é“å¯ä»¥ç”¨äºä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´å•å‘ä¼ è¾“æ•°æ®ï¼Œä¸€ç«¯ç”¨äºå†™å…¥ï¼Œä¸€ç«¯ç”¨äºè¯»å–ã€‚\n\n\n\n### Cmdä¸æ˜¯Shell\n\n**å½“æˆ‘ä»¬åœ¨æ§åˆ¶å°æ‰§è¡Œå‘½ä»¤çš„æ—¶å€™ï¼Œå®é™…ä¸Šæˆ‘ä»¬è¾“å…¥çš„å‘½ä»¤ä¼šå…ˆé€šè¿‡`shell`è¿›è¡Œé¢„å¤„ç†ï¼Œç„¶åæ‰ä¼šè¢«å®é™…çš„ç¨‹åºæ‰§è¡Œ**\n\næ¯”å¦‚ï¼Œå½“æˆ‘ä»¬åœ¨æ§åˆ¶å°æ‰§è¡Œï¼š\n\n```sh\n$ rm -rf *\n```\n\n`shell`ä¼šå…ˆå°†`*`æ›¿æ¢æˆæ‰€æœ‰åŒ¹é…çš„æ–‡ä»¶åˆ—è¡¨ï¼Œç„¶åå†æŠŠ`-rf`å’Œå¾…åˆ é™¤çš„æ–‡ä»¶åˆ—è¡¨ä¼ ç»™`rm`å‘½ä»¤æ‰§è¡Œ\n\nè€Œå¦‚æœé€šè¿‡`Cmd`è¿›è¡Œè°ƒç”¨ï¼Œå¹¶ä¸ä¼šæ‰§è¡Œè¿™äº›é¢„å¤„ç†ã€‚\n\næ¯”å¦‚ï¼š\n\n```go\nfunc main(){\n    cmd := exec.Cmd{}\n\tcmd.Path = \"/bin/rm\"\n    cmd.Args = []string{\"-r\", \"-f\", \"*\"}\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n`*`ä¼šç›´æ¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™`rm`ï¼Œè€Œ`rm`æœ¬èº«å¹¶ä¸ä¼šæ‰§è¡Œæ¨¡ç³ŠåŒ¹é…ï¼Œè€Œæ˜¯æŠŠ`*`å½“åšæ™®é€šçš„æ–‡ä»¶åå¯¹å¾…ï¼Œå¦‚æœå½“å‰ç›®å½•æ²¡æœ‰å­˜åœ¨æ–‡ä»¶åä¸º`*`çš„æ–‡ä»¶ï¼Œåˆ™ä¼šæŠ¥é”™ï¼š`No such file or directory`\n\nè§£å†³çš„æ–¹æ³•ä¸€ï¼š\n\n```go\nfunc main(){\n    cmd := exec.Cmd{}\n\tcmd.Path = \"/bin/bash\"\n    cmd.Args = []string{\"-c\", \"rm -rf *\"} // ä½¿ç”¨ bash -c \"rm -rf *\"\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\nè§£å†³æ–¹æ³•äºŒï¼š\n\n```go\nfunc main(){\n    fs, _ := filepath.Glob(\"*\") // è·å–åŒ¹é…`*`çš„æ–‡ä»¶åˆ—è¡¨\n    cmd := exec.Cmd{}\n\tcmd.Path = \"/bin/rm\"\n    cmd.Args = []string{\"-r\", \"-f\"}\n    cmd.Args = append(cmd.Args, fs...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n","tags":["go"]},{"title":"grpcä¸Šæ‰‹ä½¿ç”¨","url":"/2018/12/21/grpcä¸Šæ‰‹ä½¿ç”¨/","content":"\n# grpcä¸Šæ‰‹ä½¿ç”¨\n\n### å®‰è£…\n\n`golang`ç‰ˆæœ¬çš„`grpc`è¦æ±‚`go`ç‰ˆæœ¬è¦åœ¨`1.6`ä»¥ä¸Š\n\n##### install gRPC\n\nä½¿ç”¨`go get`å‘½ä»¤å®‰è£…`grpc`åŒ…\n\n```sh\n$ go get -u google.golang.org/grpc\n```\n\n> ç”±äºæŸäº›ä¸å¯é€†åŸå› ï¼Œä¸Šé¢å‘½ä»¤ä¼šæŠ¥è¿æ¥è¶…æ—¶ï¼Œå¯ä»¥åˆ°`github`ä¸Šå°†é¡¹ç›®`clone`åˆ°`$GOPATH/src/google.golang.org/`ä¸‹\n>\n> ```sh\n> $ cd $GOPATH/src/google.golang.org\n> $ git clone git@github.com:grpc/grpc-go.git grpc\n> ```\n\n##### install Protocol Buffers  v3\n\n`grpc`é»˜è®¤ä½¿ç”¨`protobuf`ä½œä¸ºåºåˆ—åŒ–å·¥å…·ã€‚\n\n1. æ‰“å¼€[Releases](https://github.com/protocolbuffers/protobuf/releases)é¡µé¢ï¼Œä¸‹è½½å¯¹åº”å¹³å°çš„`.zip`åŒ…`protoc-<version>-<platform>.zip`\n2. è§£å‹\n3. æ·»åŠ äºŒè¿›åˆ¶æ–‡ä»¶è·¯å¾„å¯¼`PATH`ç¯å¢ƒå˜é‡\n\n##### install protoc plugin\n\nå®‰è£…`golang`ç‰ˆæœ¬å¯¹åº”çš„`protobuf`ç”Ÿæˆå·¥å…·\n\n```sh\n$ go get -u github.com/golang/protobuf/protoc-gen-go\n$ export PATH=$PATH:$GOPATH/bin\n```\n\n### è¿è¡Œdemo\n\nè¿›å…¥`example`ç›®å½•\n\n```sh\n$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld\n```\n\nåˆ é™¤åŸæ¥çš„`helloworld.pb.go`æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨`protoc`ç”Ÿæˆè‡ªå·±ç”Ÿæˆä¸€ä¸ª\n\n```sh\n$ rm helloworld/helloworld.pb.go // åˆ é™¤åŸæ¥çš„helloworld.pb.goæ–‡ä»¶\n$ protoc -I helloworld/ helloworld/helloworld.proto --go_out=plugins=grpc:helloworld // æ ¹æ® .proto æ–‡ä»¶ç”Ÿæˆå¯¹åº”çš„.goæ–‡ä»¶\n```\n\nç¼–å†™`grpc`æ¥å£æ—¶ï¼Œåœ¨`.proto`æ–‡ä»¶å®šä¹‰æ¥å£é€šä¿¡æ•°æ®æ ¼å¼å’Œæ¥å£ä¿¡æ¯ï¼Œç„¶åé€šè¿‡`protoc`è‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„`go`ä»£ç ï¼Œå¤§å¤§æ–¹ä¾¿äº†å¼€å‘\n\n- `-I PATH`ï¼šspecify the directory in which to search for imports.  May be specified multiple times; directories will be searched in order.  If not given, the current working directory is used.\n- `--go_out`ï¼šæŒ‡å®šè¾“å‡º`go`ä»£ç \n- `plugins=grpc`ï¼š`.proto`ä¸­çš„`service `æ˜¯`grpc`æ‰©å±•çš„åŠŸèƒ½ï¼Œéœ€è¦ä½¿ç”¨`grpc`æ’ä»¶è¿›è¡Œè§£ææ‰èƒ½ç”Ÿæˆå¯¹åº”çš„æ¥å£å®šä¹‰ä»£ç ã€‚\n\nè¿è¡Œ `grpc server `å’Œ `grpc client`\n\n```sh\n$ go run greeter_server/main.go // å¯åŠ¨grpc server\n$ go run greeter_client/main.go // å¯åŠ¨grpc client\n```\n\n\n\n### å®è·µ\n\nä½¿ç”¨`grpc`å¼€å‘ä¸€ä¸ªç®€å•çš„æ±‚å’ŒæœåŠ¡ã€‚\n\n##### å®šä¹‰.protoæ–‡ä»¶\n\nåœ¨é¡¹ç›®ä¸‹åˆ›å»º`proto/sum.proto`æ–‡ä»¶ï¼š\n\n```protobuf\nsyntax = \"proto3\"; // ä½¿ç”¨ proto3\n\n// javaç”Ÿæˆé€‰é¡¹\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\n\npackage proto; // ç”Ÿæˆçš„goæ‰€å±çš„package\n\nmessage SumResp {\n    int64 sum = 1;\n}\n\nmessage SumReq {\n    int64 a = 1;\n    int64 b = 2;\n}\n\n\nservice CalcSvc {\n    // æ¯ä¸ªrpcæ¥å£å£°æ˜éƒ½å¿…é¡»æœ‰ä¸”ä¸€ä¸ªå‚æ•°å’Œä¸€ä¸ªè¿”å›å€¼\n    rpc Sum(SumReq) returns (SumResp) {}\n}\n```\n\n##### æ ¹æ®æ¥å£æè¿°æ–‡ä»¶ç”Ÿæˆæºç \n\nè¿›å…¥`proto`ç›®å½•ï¼Œæ‰§è¡Œ\n\n```sh\n$ protoc sum.proto --go_out=plugins=grpc:.\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œåœ¨æœ¬ç›®å½•ä¸‹ç”Ÿæˆ`sum.pb.go`æ–‡ä»¶ï¼Œä¸”`package`ä¸º`proto`\n\n##### å¼€å‘æœåŠ¡ç«¯æ¥å£\n\né¦–å…ˆæŸ¥çœ‹ç”Ÿæˆçš„`sum.pb.go`æ–‡ä»¶ï¼Œå¯ä»¥çœ‹åˆ°æ ¹æ®`sum.proto`æ–‡ä»¶ä¸­çš„`CalcSvc`æ¥å£å®šä¹‰ç”Ÿæˆäº†å¯¹åº”çš„æ¥å£ï¼š\n\n```go\n// CalcSvcServer is the server API for CalcSvc service.\ntype CalcSvcServer interface {\n\t// æ¯ä¸ªrpcæ¥å£å£°æ˜éƒ½å¿…é¡»æœ‰ä¸”ä¸€ä¸ªå‚æ•°å’Œä¸€ä¸ªè¿”å›å€¼\n\tSum(context.Context, *SumReq) (*SumResp, error)\n}\n```\n\nå¼€å‘æœåŠ¡ç«¯æ¥å£åªè¦å°±æ˜¯æ ¹æ®è¿™äº›æ¥å£å®šä¹‰å®ç°å…·ä½“çš„ä¸šåŠ¡é€»è¾‘\n\nåœ¨é¡¹ç›®ä¸‹åˆ›å»º`service/main.go`ï¼š\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/reflection\"\n\t\"grpc-demo/proto\"\n\t\"log\"\n\t\"net\"\n)\n\n// ç±»å‹æ–­è¨€\nvar _ proto.CalcSvcServer = new(CalcSvc)\n\ntype CalcSvc struct{}\n\nfunc (CalcSvc) Sum(ctx context.Context, req *proto.SumReq) (resp *proto.SumResp, err error) {\n    // å»ºè®®ä½¿ç”¨GetAï¼Œä¸è¦ç›´æ¥ä½¿ç”¨req.Aï¼Œå¯èƒ½å­˜åœ¨req=nilçš„æƒ…å†µ\n\ta := req.GetA() \n\tb := req.GetB()\n\tlog.Println(\"request coming ...\")\n\treturn &proto.SumResp{\n\t\tSum: a + b,\n\t}, err\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \":8888\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    // æ³¨å†ŒæœåŠ¡åˆ°gRPC\n\ts := grpc.NewServer()\n\tproto.RegisterCalcSvcServer(s, &CalcSvc{})\n    // å¯ç”¨Server Reflectionï¼Œå¯ä»¥ä½¿ç”¨gRPC CLIå»æ£€æŸ¥services\n    // https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md\n\treflection.Register(s)\n    // å¯åŠ¨æœåŠ¡\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\n##### å®¢æˆ·ç«¯è®¿é—®\n\nåœ¨é¡¹ç›®ä¸‹åˆ›å»º`client/main.go`ï¼š\n\n```go \npackage main\n\nimport (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"grpc-demo/proto\"\n\t\"log\"\n)\n\nfunc main() {\n    // åˆ›å»ºgRPCè¿æ¥\n    // WithInsecure option æŒ‡å®šä¸å¯ç”¨è®¤è¯åŠŸèƒ½\n\tconn, err := grpc.Dial(\":8888\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n    // åˆ›å»ºgRPC client\n\tclient := proto.NewCalcSvcClient(conn)\n    // è¯·æ±‚gRPC server\n\tresp, err := client.Sum(context.Background(), &proto.SumReq{\n\t\tA: 5,\n\t\tB: 10,\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"5 + 10 = %d\", resp.GetSum())\n}\n```\n\n##### è¿è¡Œ\n\n```go \n$ go run service/main.go\n$ go run client/main.go\n```\n\n\n\n### grpcè¿æ¥å¤ç”¨\n\né¦–å…ˆä¿®æ”¹æœåŠ¡ç«¯ä»£ç ï¼Œ**æ·»åŠ  `1s` çš„ç¡çœ æ—¶é—´**ï¼Œæ¨¡æ‹Ÿå¤æ‚ä¸šåŠ¡å¤„ç†åœºæ™¯ï¼š\n\n```go\nfunc (CalcSvc) Sum(ctx context.Context, req *proto.SumReq) (resp *proto.SumResp, err error) {\n\ta := req.GetA()\n\tb := req.GetB()\n\tlog.Println(\"request coming ...\")\n    // æ·»åŠ  1s ç¡çœ ï¼Œæ¨¡æ‹Ÿæ¥å£æ‰§è¡Œä¸šåŠ¡é€»è¾‘\n\ttime.Sleep(time.Second)\n\treturn &proto.SumResp{\n\t\tSum: a + b,\n\t}, err\n}\n```\n\n##### http2å¤šè·¯å¤ç”¨\n\n`grpc`åº•å±‚ä½¿ç”¨`http2`åè®®è¿›è¡Œé€šä¿¡ï¼Œå› æ­¤å•æ¡è¿æ¥æ”¯æŒå¤šè·¯å¤ç”¨\n\nä¿®æ”¹å®¢æˆ·ç«¯ä»£ç ï¼š\n\n```go\n\nfunc main() {\n\tconn ,err:=grpc.Dial(\":8888\", grpc.WithInsecure())\n\tif err!=nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient :=proto.NewCalcSvcClient(conn)\n\n\twg := sync.WaitGroup{}\n\tbegin := time.Now()\n\tconcurrentNum := 1000\n\twg.Add(concurrentNum)\n    \n\tfor i := 0; i < concurrentNum; i++ {\n\t\tgo func() {\n\t\t\tresp, err := client.Sum(context.Background(), &proto.SumReq{\n\t\t\t\tA: 5,\n\t\t\t\tB: 10,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tlog.Printf(\"5 + 10 = %d\", resp.GetSum())\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tlog.Printf(\"ç”¨æ—¶ï¼š%v\", time.Now().Sub(begin))\n}\n```\n\nåœ¨ä¸Šé¢ä»£ç ä¸­ï¼ŒæœåŠ¡ç«¯æ¯æ¬¡éƒ½ç¡çœ `1s`ï¼Œå®¢æˆ·ç«¯ä½¿ç”¨å•æ¡è¿æ¥è¿›è¡Œé€šä¿¡ï¼Œ**1000ä¸ªå¹¶å‘è¯·æ±‚æ€»å…±æ‰§è¡Œæ—¶é—´ä¸º`1.1s`å·¦å³**\n\nå¦‚æœæ˜¯`2000`ä¸ªè¯·æ±‚ï¼Œå¹³å‡åœ¨`1.2s`å·¦å³ï¼Œ`10000`ä¸ªè¯·æ±‚æ˜¯`2`så·¦å³ã€‚\n\nå¯è§`grpc`æœ¬èº«å•æ¡è¿æ¥å¯ç”¨æä¾›çš„å¹¶å‘æ•ˆæœè¶³ä»¥æ»¡è¶³å¤§éƒ¨åˆ†ä¸šåŠ¡åœºæ™¯ã€‚\n\n**æ³¨æ„ï¼š**ä¸Šé¢çš„`1000`ä¸ªå¹¶å‘è¯·æ±‚å¹¶ä¸æ˜¯å•æ¡è¿æ¥å¯ä»¥åŒæ—¶å‘èµ·`1000`ä¸ªè¯·æ±‚ï¼Œè€Œæ˜¯å…¶å†…éƒ¨æ”¯æŒç±»ä¼¼`pipeline`çš„æœºåˆ¶ã€‚\n\n##### è¿æ¥æ± \n\næ¥ä¸‹æ¥ä¸ä½¿ç”¨`http2`çš„å¤šè·¯å¤ç”¨ï¼Œé‡‡ç”¨è¿æ¥æ± çš„æ–¹å¼æ¥åˆ›å»ºè¯·æ±‚\n\né¦–å…ˆå®ç°ä¸€ä¸ªè¿æ¥æ± ï¼š\n\n```go\npackage main\n\nimport (\n\t\"google.golang.org/grpc\"\n\t\"sync\"\n\t\"time\"\n)\n\n// è¿æ¥æ± é€‰é¡¹\ntype Options struct {\n\tDial        Dialer\n\tMaxConn     int\n\tMaxIdle     int\n\tWaitTimeout time.Duration\n}\n\n// åˆ›å»ºè¿æ¥\ntype Dialer func() (*grpc.ClientConn, error)\n\ntype Pool struct {\n\tdial    Dialer\n\tmaxConn int // æœ€å¤§æ‰“å¼€è¿æ¥æ•°\n\tmaxIdle int // æœ€å¤§ç©ºé—²è¿æ¥æ•°\n\n\twaitTimeout time.Duration // ç­‰å¾…è¿æ¥è¶…æ—¶æ—¶é—´\n    // ç­‰å¾…è¿æ¥æ—¶é€šè¿‡connChæ¥ä¼ è¾“å¯ç”¨è¿æ¥\n\tconnCh      chan *grpc.ClientConn\n\n\tcurConnNum int // è®°å½•å½“å‰æ‰“å¼€çš„è¿æ¥æ•°\n    // ä¿å­˜ç©ºé—²è¿æ¥\n\tfreeConn   []*grpc.ClientConn\n\tsync.Mutex\n}\n\n// åˆ›å»ºè¿æ¥æ± \nfunc NewPool(opts Options) *Pool {\n\tif opts.MaxConn <= 0 {\n\t\topts.MaxConn = 10\n\t}\n\tif opts.MaxIdle <= 0 {\n\t\topts.MaxIdle = 5\n\t}\n\tif opts.MaxIdle > opts.MaxConn {\n\t\topts.MaxIdle = opts.MaxIdle\n\t}\n\n\treturn &Pool{\n\t\tdial:        opts.Dial,\n\t\tmaxConn:     opts.MaxConn,\n\t\tmaxIdle:     opts.MaxIdle,\n\t\twaitTimeout: opts.WaitTimeout,\n\t\tconnCh:      make(chan *grpc.ClientConn),\n\t\tfreeConn:    make([]*grpc.ClientConn, 0, opts.MaxIdle),\n\t}\n\n}\n\n// è·å–è¿æ¥\nfunc (p *Pool) Get() (conn *grpc.ClientConn) {\n\tp.Lock()\n\t// å·²ç»åˆ°è¾¾æœ€å¤§è¿æ¥æ•°\n\tif p.curConnNum >= p.maxConn {\n        // å¦‚æœç­‰å¾…è¶…æ—¶æ—¶é—´ä¸º0ï¼Œç›´æ¥è¿”å›\n\t\tif p.waitTimeout == 0 {\n\t\t\tp.Unlock()\n\t\t\treturn\n\t\t}\n\n\t\tvar tm <-chan time.Time\n        // å¦‚æœç­‰å¾…è¶…æ—¶æ—¶é—´å°äº0ï¼Œè¡¨ç¤ºæ— é™ç­‰å¾…\n\t\tif p.waitTimeout > 0 {\n\t\t\ttm = time.After(p.waitTimeout)\n\t\t}\n\t\tp.Unlock()\n        // ç­‰å¾…å¯ç”¨è¿æ¥æˆ–è€…è¶…æ—¶\n\t\tselect {\n\t\tcase <-tm:\n\t\tcase conn = <-p.connCh:\n\t\t}\n\t\treturn\n\t}\n\t// å¦‚æœå­˜åœ¨ç©ºé—²è¿æ¥\n\tif ln := len(p.freeConn); ln > 0 {\n\t\tconn = p.freeConn[0]\n\t\tp.freeConn[0] = p.freeConn[ln-1]\n\t\tp.freeConn = p.freeConn[:ln-1]\n\t} else { // åˆ›å»ºæ–°çš„è¿æ¥\n\t\tc, err := p.dial()\n\t\tif err != nil {\n\t\t\tconn = nil\n\t\t} else {\n\t\t\tp.curConnNum++\n\t\t\tconn = c\n\t\t}\n\t}\n\tp.Unlock()\n\treturn\n}\n\n// é‡Šæ”¾è¿æ¥\nfunc (p *Pool) Put(conn *grpc.ClientConn) error {\n\tif conn == nil {\n\t\treturn nil\n\t}\n    // é¦–å…ˆåˆ¤æ–­æ˜¯å¦æœ‰å…¶ä»–åç¨‹åœ¨ç­‰å¾…è¿æ¥\n\tselect {\n\tcase p.connCh <- conn:\n\t\treturn nil\n\tdefault:\n\t}\n\tp.Lock()\n\tdefer p.Unlock()\n    // æ”¾å›ç©ºé—²è¿æ¥\n\tif len(p.freeConn) < p.maxIdle {\n\t\tp.freeConn = append(p.freeConn, conn)\n\t\treturn nil\n\t}\n    // å†æ¬¡åˆ¤æ–­æ˜¯å¦æœ‰ç­‰å¾…å¯ç”¨è¿æ¥\n\tselect {\n\tcase p.connCh <- conn:\n\t\treturn nil\n\tdefault:\n        // å…³é—­è¿æ¥\n\t\tp.curConnNum--\n\t\treturn conn.Close()\n\t}\n}\n\n// ç»Ÿè®¡è¿æ¥æ± çŠ¶æ€\nfunc (p *Pool) Stat() PoolStat {\n\tp.Lock()\n\tp.Unlock()\n\treturn PoolStat{\n\t\tConnNum:     p.curConnNum,\n\t\tIdleConnNum: len(p.freeConn),\n\t}\n}\n\ntype PoolStat struct {\n\tConnNum     int\n\tIdleConnNum int\n}\n\n```\n\næ¥ä¸‹æ¥ï¼Œä½¿ç”¨è¯¥è¿æ¥æ± è¿›è¡Œæµ‹è¯•ï¼š\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n\t\"grpc-demo/proto\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\topts := Options{\n\t\tDial: func() (*grpc.ClientConn, error) {\n\t\t\treturn grpc.Dial(\":8888\", grpc.WithInsecure())\n\t\t},\n\t\tWaitTimeout: time.Second * 10,\n\t\tMaxConn:     100, // è®¾ç½®æœ€å¤§è¿æ¥æ•°ä¸º100\n\t\tMaxIdle:     50,\n\t}\n\tpool := NewPool(opts)\n\tif pool == nil {\n\t\tpanic(\"nil pool\")\n\t}\n\n\twg := sync.WaitGroup{}\n\tbegin := time.Now()\n\tconcurrentNum := 1000\n\twg.Add(concurrentNum)\n\tfor i := 0; i < concurrentNum; i++ {\n\t\tgo func() {\n\n\t\t\tconn := pool.Get()\n\t\t\tif conn == nil {\n\t\t\t\tpanic(\"nil conn\")\n\t\t\t}\n\t\t\tdefer pool.Put(conn)\n\t\t\tclient := proto.NewCalcSvcClient(conn)\n\n\t\t\tresp, err := client.Sum(context.Background(), &proto.SumReq{\n\t\t\t\tA: 5,\n\t\t\t\tB: 10,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tlog.Printf(\"5 + 10 = %d\", resp.GetSum())\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tlog.Printf(\"ç”¨æ—¶ï¼š%v\", time.Now().Sub(begin))\n\tlog.Println(pool.Stat())\n}\n```\n\nåœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæ¯æ¬¡è¯·æ±‚æ—¶éƒ½ä»è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªè¿æ¥ï¼Œè¯·æ±‚å®Œæˆåå°†å…¶é‡Šæ”¾ã€‚\n\nè¿è¡Œä¸Šé¢ä»£ç ï¼Œ**`1000`ä¸ªå¹¶å‘è¯·æ±‚æ€»å…±éœ€è¦èŠ±è´¹`10.15s`å·¦å³**ã€‚\n\n\n\n### è´Ÿè½½å‡è¡¡\n\nè¿™é‡Œä½¿ç”¨`dns`æ¥è¿›è¡Œè´Ÿè½½å‡è¡¡è¿›è¡Œæ¼”ç¤ºã€‚\n\næˆ‘å®éªŒæœºå™¨ä¸Šé¢çš„æœ¬æœº`IP`æ˜¯`127.0.0.1`ï¼Œè™šæ‹Ÿæœº`IP`æ˜¯`192.168.50.12`\n\né¦–å…ˆï¼Œä¿®æ”¹ç³»ç»Ÿçš„`hosts`æ–‡ä»¶ï¼Œæ·»åŠ ï¼š\n\n```\n192.168.50.12 www.grpc.com\n127.0.0.1 www.grpc.com\n```\n\nç„¶åï¼ŒåŒæ—¶åœ¨æœ¬åœ°å’Œè™šæ‹Ÿæœºä¸­å¯åŠ¨`grpc server`\n\næœ€åï¼Œä¿®æ”¹`grpc client`ä»£ç ï¼š\n\n```go\nconn, err := grpc.Dial(\"dns:///www.grpc.com:8888\", grpc.WithInsecure(), grpc.WithBalancerName(roundrobin.Name))\nif err != nil {\n\tlog.Fatal(err)\n}\nclient := proto.NewCalcSvcClient(conn)\n```\n\nåœ¨åˆ›å»º`grpc`è¿æ¥çš„æ—¶å€™ï¼Œä½¿ç”¨`dns:///www.grpc.com:8888`ï¼ŒåŒæ—¶æŒ‡å®šè´Ÿè½½ç­–ç•¥ä¸º`roundrobin`ã€‚\n\næ‰§è¡Œ`grpc client`ï¼Œå¯ç”¨çœ‹åˆ°**ä¸¤è¾¹çš„`grpc server`éƒ½æœ‰æ‰“å°å‡ºè¯·æ±‚æ—¥å¿—**ã€‚\n\n`grpc`æä¾›çš„è´Ÿè½½å‡è¡¡æµ‹è¯•æ˜¯åœ¨**è¯·æ±‚çº§åˆ«ä¸Šè¿›è¡Œè´Ÿè½½å‡è¡¡**ã€‚\n\n`grpc`ä¼šåŒæ—¶ä¸ºæ¯ä¸ª`grpc server`åˆ›å»ºä¸€æ¡è¿æ¥ï¼›æ¯æ¬¡è¦å‘èµ·ä¸€ä¸ªè¯·æ±‚çš„æ—¶å€™ï¼Œéƒ½ä¼šæ ¹æ®è´Ÿè½½ç­–ç•¥é€‰æ‹©ä¸€æ¡è¿æ¥æ¥å‘èµ·è¯·æ±‚ã€‚","tags":["go","grpc"]},{"title":"goç¼–è¯‘å…±äº«åº“ç»™cè°ƒç”¨","url":"/2018/12/19/goç¼–è¯‘å…±äº«åº“ç»™cè°ƒç”¨/","content":"\n### introduce\n\nä½¿ç”¨` golang`å¼€å‘`httpServer`éå¸¸æ–¹ä¾¿ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦åœ¨`c`ç¨‹åºä¸­å†…åµŒ`httpServer`ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨`go`æ¥å¼€å‘æœåŠ¡æ¨¡å—ï¼Œç„¶åç¼–è¯‘æˆå…±äº«åº“ä¾›`c`è°ƒç”¨\n\n### code by go \n\n##### code\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\t\"log\"\n)\n\nimport \"C\" // éœ€è¦å¯¼å…¥`C`æ‰å¯ä»¥ç”Ÿæˆ`.h`æ–‡ä»¶\n\n\n// ä½¿ç”¨`export`å¯¼å‡ºå‡½æ•°\n//export ServerRun\nfunc ServerRun(_addr *C.char) int {\n    // è½¬æ¢cå­—ç¬¦ä¸²ä¸ºgolangå­—ç¬¦ä¸²\n    addr :=C.GoString(_addr)\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n\t\tresp.Write([]byte{'H', 'i', '!'})\n\t})\n\tif err := http.ListenAndServe(addr, mux); err != nil {\n\t\tlog.Println(err.Error())\n\t\treturn -1\n\t}\n\treturn 0\n}\n\n// å†…éƒ¨å‡½æ•°ä¹Ÿå¯ä»¥å¯¼å‡º\n//export wait\nfunc wait() {\n\ttime.Sleep(time.Hour * 1)\n}\n\nfunc main() {}\n```\n\næ³¨æ„ç‚¹ï¼š\n\n- éœ€è¦å¼•å…¥`C`åŒ…ï¼Œå¯ä»¥ä½¿ç”¨`C`åŒ…ä¸­çš„`GoString`å°†`c`çš„å­—ç¬¦ä¸²è½¬æ¢ä¸º`go`çš„å­—ç¬¦ä¸²\n\n- éœ€è¦å¯¼å‡ºçš„å‡½æ•°ï¼Œéœ€è¦ä½¿ç”¨`//export funcName`æ ‡è¯†\n\n- åŒ…å†…å‡½æ•°ä¹Ÿå¯ä»¥å¯¼å‡º\n\n- `go`å’Œ`c`ä¸¤è€…çš„å­—ç¬¦ä¸²å†…å­˜å¸ƒå±€ä¸åŒï¼Œå¦‚æœ`go`å‡½æ•°å‚æ•°å£°æ˜ä¸º`go`çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œåœ¨`c`ä¸­ç›¸å½“äºä¸€ä¸ªç»“æ„ä½“ï¼š\n\n  ```c\n  typedef struct { const char *p; ptrdiff_t n; } _GoString_;\n  typedef _GoString_ GoString;\n  ```\n\n  å½“è¦åœ¨`c`ä¸­è°ƒç”¨`go`å‡½æ•°æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨æ„é€ å­—ç¬¦ä¸²ï¼Œè€Œä¸”è¿˜æœ‰å†…å­˜å®‰å…¨çš„é—®é¢˜ã€‚\n\n##### compile\n\n- åŠ¨æ€å…±äº«åº“ï¼šè¿è¡Œæ—¶åŠ¨æ€åŠ è½½ï¼›å¦‚æœè¿è¡Œæ—¶åŠ è½½å¤±è´¥åˆ™æŠ¥é”™\n\n  ```sh\n  $ go build -buildmode=c-shared -o libtest.so main.go\n  ```\n\n  ç¼–è¯‘å®Œæˆä¹‹åå°†ç”Ÿæˆ`libtest.so`å’Œ`libtest.h`æ–‡ä»¶\n\n- é™æ€å…±äº«åº“ï¼šç¼–è¯‘æ—¶é™æ€é“¾æ¥åˆ°ç¨‹åºä¸­ï¼›ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶è¾ƒå¤§\n\n  ```sh\n  $ go build -buildmode=c-archive -o test.a main.go\n  ```\n\n  ç¼–è¯‘å®Œæˆä¹‹åå°†ç”Ÿæˆ`test.h`å’Œ`test.a`æ–‡ä»¶\n\n\n\n### use in c \n\n##### code \n\nåœ¨å¼€å§‹å†™ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å…ˆçœ‹ä¸€ä¸‹ç”Ÿæˆçš„`test.h`é‡Œé¢çš„å†…å®¹ï¼š\n\n```c\ntypedef struct { const char *p; ptrdiff_t n; } _GoString_;\ntypedef _GoString_ GoString;\n\ntypedef long long GoInt64;\ntypedef GoInt64 GoInt;\n\nextern GoInt ServerRun(char* p0);\n\nextern void wait();\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œ`.h`æ–‡ä»¶ä¸­åŒ…å«äº†å¤–éƒ¨å‡½æ•°`ServerRun`å’Œ`wait`çš„å£°æ˜\n\n```c\n#include<stdio.h>\n#include \"test.h\"\n\nint main(void){\n\t// æ‰§è¡Œ ServerRun\n    if (ServerRun(\":8080\") != 0){\n        printf(\"failed to start server!\");\n        return -1;\n    }\n    return 0;\n}\n```\n\n\n\n##### compile \n\n- é™æ€å…±äº«åº“\n\n  ```sh\n  $ gcc -pthread -o test main.c test.a \n  ```\n\n  ä½¿ç”¨é™æ€é“¾æ¥æ—¶ï¼Œéœ€è¦æŒ‡å®š`-pthread`é€‰é¡¹ \n\n  > Link with the POSIX threads library.  This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.  On some targets this option also sets flags for the preprocessor, so it should be used consistently for both compilation and linking.\n\n  ä¹Ÿå¯ä»¥åŠ¨æ€åŠ è½½`pthread`åº“\n\n  ```sh\n  $ gcc -lpthread -o test main.c test.a\n  ```\n\n- åŠ¨æ€å…±äº«åº“\n\n  ```sh\n  $ gcc main.c -ltest -L. -I. -o test\n  ```\n\n  - `-l`ï¼šå£°æ˜ä½¿ç”¨åˆ°çš„åŠ¨æ€å…±äº«åº“ï¼Œæ¯”å¦‚`libtest.so`ï¼Œåˆ™è¿™é‡Œä¼ å…¥`test`\n  - `-L`ï¼šåœ¨æŒ‡å®šè·¯å¾„ä¸­æŸ¥æ‰¾å…±äº«åº“ï¼›ä¹Ÿå¯ä»¥å°†`.so`æ–‡ä»¶æ‹·è´åˆ°é»˜è®¤å…±äº«åº“ç›®å½•ä¸‹\n  - `-I`ï¼šåœ¨æŒ‡å®šè·¯å¾„ä¸­æŸ¥æ‰¾`.h`å¤´éƒ¨æ–‡ä»¶\n\n\n\nç¼–è¯‘ä¹‹åç”Ÿæˆ`test`æ–‡ä»¶ï¼Œæ‰§è¡Œ`./test`ï¼Œç„¶ååœ¨è®¿é—®`http://localhost:8080`å¯ä»¥çœ‹åˆ°è¿”å›äº†`Hi!`å†…å®¹ã€‚\n\nå¦‚æœä½¿ç”¨åŠ¨æ€åŠ è½½ï¼Œè¿è¡Œå‰éœ€è¦å…ˆå°†`libtest.so`æ–‡ä»¶æ‹·è´åˆ°åŠ¨æ€åŠ è½½åº“é»˜è®¤çš„åŠ è½½è·¯å¾„ä¸­ï¼Œæˆ–è€…å°†å½“å‰è·¯å¾„åŠ åˆ°`LD_LIBRARY_PATH `ç¯å¢ƒå˜é‡ä¸­ã€‚\n","tags":["go"]},{"title":"goland ä¸­è·å– goid","url":"/2018/08/18/goland-ä¸­è·å–-goid/","content":"\n### introduce\n\nç›®å‰ç½‘ä¸Šæœ‰å¾ˆå¤šè·å–goroutine idçš„æ–¹æ³•ï¼Œä¸»è¦åˆ†ä¸ºä¸¤ç§ï¼š\n\n- é€šè¿‡runtime.Stackæ–¹æ³•è·å–æ ˆçš„ä¿¡æ¯ï¼Œè€Œæ ˆä¿¡æ¯ä»¥`goroutine {goid}` å¼€å¤´ï¼Œå†é€šè¿‡å­—ç¬¦ä¸²å¤„ç†å°±å¯ä»¥æå–å‡ºgoid\n- goä¸­é€šè¿‡gæ¥è¡¨ç¤ºgoroutineï¼Œè€Œåœ¨tlsä¸­ä¿å­˜äº†å½“å‰æ‰§è¡Œçš„gçš„åœ°å€ã€‚å¯ä»¥é€šè¿‡æ±‡ç¼–è·å–åˆ°gçš„åœ°å€ï¼Œç„¶ååŠ ä¸Šgoidåœ¨gä¸­çš„åç§»é‡å°±å¯ä»¥è·å–åˆ°goidçš„å€¼äº†\n\nç¬¬ä¸€ç§æ–¹æ³•å®ç°æ–¹ä¾¿ï¼Œåªè¦é€šè¿‡ç®€å•çš„å­—ç¬¦ä¸²å¤„ç†å°±å¯ä»¥è·å–åˆ°goidï¼Œä½†æ˜¯æ€§èƒ½å¼€é”€è¾ƒå¤§ï¼›\n\nç¬¬äºŒç§æ–¹æ³•ï¼Œéœ€è¦ç»“åˆæ±‡ç¼–æ¥è·å–å½“å‰æ‰§è¡Œçš„gçš„åœ°å€ï¼Œè€Œä¸”éœ€è¦è·å–åˆ°goidåœ¨gä¸­çš„åç§»é‡ï¼›è€Œä¸åŒçš„ç‰ˆæœ¬ä¸­gçš„ç»“æ„éƒ½ä¸ä¸€æ ·ï¼Œå› æ­¤è¯¥æ–¹æ³•éœ€è¦ä¸ºæ¯ä¸ªç‰ˆæœ¬éƒ½æä¾›ä¸€ç§å®ç°\n\n### code\n\nä¸‹é¢å°†åŸºäºgo1.10å®ç°ä¸Šé¢ä¸¤ç§è·å–goidçš„æ–¹æ¡ˆã€‚\n\n##### æ–¹æ³•ä¸€ï¼š\n\n```go\n\tstack := make([]byte, 20) //è¯»å–å‰äºŒåä¸ªå­—èŠ‚\n\truntime.Stack(stack, false)\n\tgoid,_ :=strconv.Atoi(strings.Split(string(stack),\" \")[1])\n```\n\nåœ¨ä¸Šé¢çš„å®ç°ä¸­ï¼Œè¯»å–æ ˆçš„å‰20ä¸ªå­—èŠ‚ï¼Œå…¶å†…å®¹ä¸º`goroutine 6 ...`ï¼Œæˆ‘ä»¬è¿™é‡Œåªéœ€è¦å…³æ³¨goidåœ¨å­—ç¬¦ä¸²æ•°ç»„ç¬¬äºŒçš„ä½ç½®ï¼Œç„¶åé€šè¿‡ç®€å•çš„å­—ç¬¦ä¸²åˆ‡å‰²å’Œç±»å‹è½¬æ¢å°±å¯ä»¥è·å–åˆ°goidäº†\n\n##### æ–¹æ³•äºŒï¼š\n\nå› ä¸ºgçš„å®šä¹‰åœ¨runtime.runtime2.goä¸­ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶æ‹·è´å‡ºæ¥\n\n```go\ntype g struct {\n\tstack       stack\n\tstackguard0 uintptr\n    _defer      uintptr\n\t...\n\tgoid           int64\n\t...\n}\n\ntype stack struct {\n\tlo uintptr\n\thi uintptr\n}\n\ntype gobuf struct {\n\tsp   uintptr\n\tpc   uintptr\n\tg    uintptr\n\tctxt unsafe.Pointer\n\tret  uint64\n\tlr   uintptr\n\tbp   uintptr\n}\n```\n\næ‹·è´çš„æ—¶å€™ï¼Œå› ä¸ºgä¸­è¿˜å¼•ç”¨äº†å…¶ä»–ç±»å‹ï¼Œä¹Ÿéœ€è¦ä¸€èµ·æ‹·è´å‡ºæ¥ã€‚è¿™é‡Œæœ‰ä¸ªå°æŠ€å·§ï¼Œå› ä¸ºæˆ‘ä»¬åªæ˜¯éœ€è¦ä½¿ç”¨gæ¥è®¡ç®—goidçš„åç§»é‡ï¼Œå› æ­¤å¦‚æœæœ‰çš„å­—æ®µæ˜¯æŒ‡é’ˆç±»å‹çš„ï¼Œé‚£ä¹ˆå¯ä»¥å°†å…¶æ¢æˆ`uintptr`ç±»å‹ã€‚æ¯”å¦‚è¯´`_defer`æ˜¯`*_defer`ç±»å‹ï¼Œé‚£ä¹ˆå¯ä»¥å°†å…¶æ¢æˆ`uintptr`ç±»å‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸éœ€è¦åœ¨è‡ªå·±çš„ä»£ç ä¸­å£°æ˜`_defer`ç»“æ„äº†ã€‚\n\nç„¶åï¼Œå£°æ˜å…¨å±€å˜é‡`offset`\n\n```go\nvar offset =unsafe.Offsetof((*g)(nil).goid)\n```\n\næˆ‘ä»¬é€šè¿‡`unsafe.Offsetof`æ–¹æ³•æ¥è®¡ç®—goidåœ¨gä¸­çš„åç§»ã€‚\n\næ¥ç€ï¼Œåœ¨goæ–‡ä»¶ä¸­å£°æ˜Goidæ–¹æ³•çš„stub\n\n```go\nfunc Goid()int64\n```\n\nå¹¶åœ¨goid.sä¸­å®ç°è¯¥å‡½æ•°\n\n```assembly\nTEXT Â·Goid(SB),NOSPLIT,$0-8\n    MOVQ Â·offset(SB),AX\t//è·å–åˆ°å…¨å±€å˜é‡offset\n    MOVQ (TLS),BX\t\t//è·å–å½“å‰gçš„åœ°å€\n    ADDQ BX,AX\t\t\t//è®¡ç®—goidçš„åœ°å€\n    MOVQ (AX),BX\t\t//è·å–goidçš„å€¼\n    MOVQ BX,ret+0(FP)\n    RET\n\t//æœ€åçš„ç©ºè¡Œå¿…é¡»ä¿ç•™ï¼Œå¦åˆ™ç¼–è¯‘æŠ¥é”™\n```\n\nåœ¨ä¸Šè¿°å®ç°ä¸­ï¼Œæˆ‘ç›´æ¥åœ¨æ±‡ç¼–ä¸­è®¡ç®—goidåœ¨å†…å­˜ä¸­çš„åœ°å€ã€‚è¿˜æœ‰ä¸€ç§å®ç°æ˜¯åœ¨æ±‡ç¼–ä¸­è·å–gçš„åœ°å€ï¼Œç„¶åå°†å…¶è½¬æ¢æˆ*gç±»å‹å¹¶è·å–goidçš„å€¼ï¼Œè¿™æ ·å°±ä¸éœ€è¦è®¡ç®—offsetçš„å€¼äº†ï¼Œä½†æ˜¯åœ¨å®é™…æµ‹è¯•ä¸­ï¼Œå‰è€…çš„æ‰§è¡Œé€Ÿåº¦æ˜¯åè€…çš„ä¸¤å€ã€‚\n\n\n\nä»¥ä¸Šä»£ç å¯ä»¥åœ¨[github](https://github.com/ymcvalu/goid)ä¸ŠæŸ¥çœ‹\n\n\n\n","tags":["go","goid"]},{"title":"goè‡ªå®šä¹‰ç±»å‹çš„åºåˆ—åŒ–è¿‡ç¨‹","url":"/2018/08/13/goè‡ªå®šä¹‰ç±»å‹çš„åºåˆ—åŒ–è¿‡ç¨‹/","content":"\n\n\n### é—®é¢˜å¼•å…¥\nå½“æŸä¸ªstructå­˜åœ¨æŸä¸ªå­—æ®µä¸ºstringæˆ–è€…[]byteç±»å‹ä½†æ˜¯å®é™…ä¸Šä¿å­˜çš„å†…å®¹æ˜¯jsonæ ¼å¼çš„æ•°æ®æ—¶ï¼Œå¯¹å…¶è¿›è¡Œjsonåºåˆ—åŒ–ï¼Œæ¯”å¦‚\n```go\ntype Message struct {\n\tFrom string     `json:\"from\"`\n\tTo   string     `json:\"to\"`\n\tData string `json:\"data\"`\n}\n\nfunc main() {\n\tmsg := Message{\n\t\tFrom: \"XiaoMing\",\n\t\tTo:   \"LiGang\",\n\t\tData: `{\"title\":\"test\",\"body\":\"something\"}`,\n\t}\n\tjsonData, err := json.Marshal(msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(string(jsonData))\n}\n```\nåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼ŒDataå­—æ®µæ˜¯stringç±»å‹ï¼Œä½†æ˜¯ä¿å­˜çš„å†…å®¹æ˜¯jsonæ ¼å¼çš„æ•°æ®ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œç¨‹åºè¾“å‡ºï¼š\n```json\n{\"from\":\"XiaoMing\",\"to\":\"LiGang\",\"data\":\"{\\\"title\\\":\\\"test\\\",\\\"body\\\":\\\"something\\\"}\"}\n```\nå¯ä»¥çœ‹åˆ°ï¼Œåºåˆ—åŒ–ä¹‹åçš„dataæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚\nå¦‚æœMessageå¯¹åº”çš„æ˜¯æ•°æ®åº“ä¸­çš„ä¸€å¼ è¡¨ï¼Œè€Œdataå­—æ®µåœ¨æ•°æ®åº“ä¸­æ˜¯jsonç±»å‹ï¼Œå½“æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ¥å£ï¼ŒæŸ¥è¯¢Messageè¡¨ä¸­çš„è®°å½•è¿”å›ç»™å®¢æˆ·ç«¯ã€‚å¦‚æœç›´æ¥æ‰§è¡Œåºåˆ—åŒ–ï¼Œé‚£ä¹ˆå®¢æˆ·ç«¯è·å–åˆ°çš„Dataå®é™…ä¸Šæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå®¢æˆ·ç«¯è¿˜éœ€è¦è‡ªè¡Œå¯¹è¿™ä¸ªå­—ç¬¦ä¸²è¿›è¡Œjsonååºåˆ—åŒ–ã€‚\n>è¿™æ—¶å€™æˆ‘ä»¬å°±ä¼šæƒ³ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆåŠæ³•èƒ½å¤Ÿåœ¨æœåŠ¡ç«¯åºåˆ—åŒ–Messageæ—¶ï¼Œå°†dataå­—æ®µåºåˆ—åŒ–æˆjsonå¯¹è±¡è€Œä¸æ˜¯å­—ç¬¦ä¸²å‘¢ï¼Ÿ\n\n### è‡ªå®šä¹‰åºåˆ—åŒ–\nå› ä¸ºdataå­—æ®µçš„å€¼æœ¬èº«å°±æ˜¯jsonç±»å‹ï¼Œä¸ºä»€ä¹ˆä¸èƒ½åœ¨åºåˆ—åŒ–æ—¶ç›´æ¥ä½¿ç”¨å‘¢ï¼Ÿ\næŸ¥çœ‹jsonåŒ…çš„å®˜æ–¹æ–‡æ¡£ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°å…³äº [è‡ªå®šä¹‰åºåˆ—åŒ–](https://godoc.org/encoding/json#ex-package--CustomMarshalJSON)çš„ä¾‹å­\nå½“æ‰§è¡Œjsonåºåˆ—åŒ–æ—¶ï¼Œå¦‚æœå¯¹åº”çš„ç±»å‹å®ç°äº†`Marshaler`æ¥å£ï¼š\n```go\ntype Marshaler interface {\n\tMarshalJSON() ([]byte, error)\n}\n```\né‚£ä¹ˆå°±ä¼šæ‰§è¡Œå…¶`MarshalJSON`æ–¹æ³•ï¼Œå¹¶å°†è¿”å›çš„å­—èŠ‚æ•°ç»„ä½œä¸ºè¯¥å€¼çš„åºåˆ—åŒ–å€¼ã€‚\né‚£ä¹ˆå›åˆ°ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å°±å¾ˆå®¹æ˜“å®ç°ç›®æ ‡ï¼š\n```go\ntype JsonString string\n\nfunc (j JsonString) MarshalJSON() ([]byte, error) {\n\tfmt.Println(\"marshal...\")\n\treturn []byte(j), nil\n}\n\ntype Message struct {\n\tFrom string     `json:\"from\"`\n\tTo   string     `json:\"to\"`\n\tData JsonString `json:\"data\"`\n}\n```\nåœ¨ä¸Šé¢çš„ä»£ç ä¸­åŸºäº`string`ç±»å‹å£°æ˜äº†`JsonString`ï¼Œä»£è¡¨jsonæ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œå¹¶å®ç°äº†Marshaleræ¥å£ã€‚å› ä¸ºJsonStringä»£è¡¨çš„å°±æ˜¯jsonå­—ç¬¦ä¸²ï¼Œç›´æ¥å°†å…¶è½¬æ¢æˆå­—èŠ‚æ•°ç»„è¿”å›ã€‚\nç„¶åå°†Messageä¸­çš„Dataå­—æ®µæ¢æˆJsonStringç±»å‹ã€‚\nå†æ¬¡æ‰§è¡Œç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°ï¼š\n```json\n{\"from\":\"XiaoMing\",\"to\":\"LiGang\",\"data\":{\"title\":\"test\",\"body\":\"something\"}}\n```\n**Perfect!**","tags":["go"]},{"title":"golangä¸­çš„deferå®ç°","url":"/2018/04/15/golangä¸­çš„deferå®ç°/","content":"\n\n\n`defer`æ˜¯goç‹¬æœ‰çš„å…³é”®å­—ï¼Œå¯ä»¥è¯´æ˜¯goçš„ä¸€å¤§ç‰¹è‰²ã€‚\n\nè¢«`defer`ä¿®é¥°çš„å‡½æ•°è°ƒç”¨ï¼Œä¼šåœ¨å‡½æ•°è¿”å›æ—¶è¢«æ‰§è¡Œï¼Œå› æ­¤å¸¸å¸¸è¢«ç”¨äºæ‰§è¡Œé”æˆ–è€…èµ„æºé‡Šæ”¾ç­‰ã€‚\n\nåœ¨æ¯æ¬¡è·å¾—èµ„æºæ—¶ï¼Œéƒ½ç´§æ¥`defer`è¯­å¥å¯¹å…¶è¿›è¡Œé‡Šæ”¾ï¼Œå¯ä»¥é˜²æ­¢åœ¨åç»­çš„æ“ä½œä¸­å¿˜è®°é‡Šæ”¾èµ„æºã€‚\n\nåœ¨äº«å—å…¶ä¾¿æ·ä¹‹åï¼Œä½ æœ‰æ²¡æœ‰æƒ³è¿‡deferæœºåˆ¶æ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿ\n\né¦–å…ˆç¼–å†™ç®€å•çš„mainå‡½æ•°\n\n```go\nfunc main() {\n\tdefer func() {\n\t\tfmt.Println(\"exit\")\n\t}()\n}\n```\n\nä½¿ç”¨`go tool compile -N -S main.go > main.s`å‘½ä»¤ç¼–è¯‘æŸ¥çœ‹è¾“å‡ºçš„æ±‡ç¼–ä»£ç \n\n```assembly\n\"\".main STEXT size=96 args=0x0 locals=0x18\n\tTEXT\t\"\".main(SB), $24-0\n\t...\n\tMOVL\t$0, (SP)\t;deferprocç¬¬ä¸€ä¸ªå‚æ•°0\n\tLEAQ\t\"\".main.func1Â·f(SB), AX ;åŒ¿åå‡½æ•°è¢«ç¼–è¯‘æˆmain.func1ï¼Œä¿å­˜å‡½æ•°åœ°å€åˆ°AX\n\tMOVQ\tAX, 8(SP) ;deferprocç¬¬äºŒä¸ªå‚æ•°ä¸ºåŒ¿åå‡½æ•°åœ°å€\n\tPCDATA\t$0, $0\n\tCALL\truntime.deferproc(SB) ;è°ƒç”¨deferå‡½æ•°\n\t...\n\tCALL\truntime.deferreturn(SB) ;è¿”å›ä¹‹å‰æ‰§è¡Œdeferreturnå‡½æ•°\n\tMOVQ\t16(SP), BP\n\tADDQ\t$24, SP\n\tRET\n\t...\n```\n\næ ¹æ®è¾“å‡ºçš„æ±‡ç¼–ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°deferè¯­å¥è¢«æ›¿æ¢æˆäº†è°ƒç”¨`runtime.deferproc`æ–¹æ³•ï¼ŒæŸ¥çœ‹å…·ä½“çš„å®ç°ï¼Œè€Œåœ¨å‡½æ•°è¿”å›æ—¶æ‰§è¡Œ`runtime.deferreturn`æ–¹æ³•\n\né¦–å…ˆåˆ†æ`runtime.deferproc`æ–¹æ³•\n\n```go\n// Create a new deferred function fn with siz bytes of arguments.\n// The compiler turns a defer statement into a call to this.\n//go:nosplit\n//sizè¡¨ç¤ºfnå‡½æ•°çš„å‚æ•°æ€»å¤§å°\nfunc deferproc(siz int32, fn *funcval) { // arguments of fn follow fn\n    //deferprocä¸å…è®¸åœ¨ç³»ç»Ÿæ ˆæ‰§è¡Œ\n\tif getg().m.curg != getg() {\n\t\t// go code on the system stack can't defer\n\t\tthrow(\"defer on system stack\")\n\t}\n\n\t// the arguments of fn are in a perilous state. The stack map\n\t// for deferproc does not describe them. So we can't let garbage\n\t// collection or stack copying trigger until we've copied them out\n\t// to somewhere safe. The memmove below does that.\n\t// Until the copy completes, we can only call nosplit routines.\n\tsp := getcallersp(unsafe.Pointer(&siz))\n    //fnçš„å‚æ•°ç´§è·Ÿåœ¨fnä¹‹å,å› æ­¤é€šè¿‡ç®€å•çš„æŒ‡é’ˆè¿ç®—å¯ä»¥è·å–fnçš„å‚æ•°èµ·å§‹åœ°å€\n\targp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)\n    // è·å–å½“å‰å‡½æ•°çš„è°ƒç”¨è€…çš„PC\n\tcallerpc := getcallerpc()\n\t//è·å–ä¸€ä¸ª_defer\n\td := newdefer(siz)\n\tif d._panic != nil {\n\t\tthrow(\"deferproc: d.panic != nil after newdefer\")\n\t}\n\td.fn = fn\n\td.pc = callerpc\n    // ä¿å­˜å½“å‰çš„SP\n\td.sp = sp\n\tswitch siz {\n\tcase 0:\n\t\t// Do nothing.\n\tcase sys.PtrSize:\n\t\t*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))\n\tdefault:\n        //deferArgs:åˆ†é…_deferæ—¶,è¿åŒå‚æ•°å­˜å‚¨ç©ºé—´ä¸€èµ·åˆ†é…,å‚æ•°ç´§è·Ÿ_deferä¹‹åå­˜å‚¨,è¯¥å‡½æ•°è¿›è¡ŒæŒ‡é’ˆè¿ç®—,è¿”å›å‚æ•°çš„èµ·å§‹åœ°å€ï¼š\n        //æ‹·è´å‚æ•°,å› æ­¤åœ¨æ‰§è¡Œdeferè¯­å¥è¯­ä¹‰ä¹‹å‰,éœ€è¦å…ˆå‡†å¤‡å¥½æ¥æ”¶è€…å’Œå‚æ•°\n\t\tmemmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))\n\t}\n\n\t// deferproc returns 0 normally.\n\t// a deferred func that stops a panic\n\t// makes the deferproc return 1.\n\t// the code the compiler generates always\n\t// checks the return value and jumps to the\n\t// end of the function if deferproc returns != 0.\n\treturn0()\n\t// No code can go here - the C return register has\n\t// been set and must not be clobbered.\n}\n```\n\nå…·ä½“çš„é€»è¾‘å·²ç»å¾ˆæ¸…æ¥šäº†ï¼Œè¿™é‡Œè¦è¯´æ˜çš„æ˜¯ï¼š`runtime.deferproc`æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œéœ€è¦å»¶æ—¶æ‰§è¡Œçš„å‡½æ•°fnçš„åœ°å€ä»¥åŠfnçš„å‚æ•°æ€»å¤§å°ï¼Œè€Œfnçš„å‚æ•°éœ€è¦ç´§è·Ÿç€åˆ†é…åœ¨`&fn`åé¢ã€‚\n\nåœ¨å‡½æ•°ä¸­æˆ‘ä»¬çœ‹åˆ°äº†`_defer`è¿™ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹æ˜¯å®ç°`defer`æœºåˆ¶çš„å…³é”®ï¼Œå…¶å£°æ˜å¦‚ä¸‹ï¼š\n\n```go\n// A _defer holds an entry on the list of deferred calls.\n// If you add a field here, add code to clear it in freedefer.\ntype _defer struct {\n\tsiz     int32\t//å‚æ•°size\n\tstarted bool\t//æ˜¯å¦æ‰§è¡Œè¿‡\n\tsp      uintptr // sp at time of defer\n\tpc      uintptr\n\tfn      *funcval //éœ€è¦å»¶æ—¶æ‰§è¡Œçš„å‡½æ•°åœ°å€\n\t_panic  *_panic // panic that is running defer\n\tlink    *_defer //æ¯ä¸ªgoroutineä¸­çš„_deferä»¥é“¾è¡¨ç»„ç»‡\n}\n```\n\nåœ¨`runtime.newdefer`æ–¹æ³•ä¸­ï¼Œä¼šè·å–ä¸€ä¸ª_deferç»“æ„ï¼Œ**å¹¶å°†å…¶åŠ å…¥å½“å‰goroutineçš„` _defer`é˜Ÿåˆ—å¤´éƒ¨**ã€‚\n\næ¥ç€çœ‹ä¸€ä¸‹`runtime.deferreturn`æ–¹æ³•å®ç°\n\n```go\n// Run a deferred function if there is one.\n// The compiler inserts a call to this at the end of any\n// function which calls defer.\n// If there is a deferred function, this will call runtimeÂ·jmpdefer,\n// which will jump to the deferred function such that it appears\n// to have been called by the caller of deferreturn at the point\n// just before deferreturn was called. The effect is that deferreturn\n// is called again and again until there are no more deferred functions.\n// Cannot split the stack because we reuse the caller's frame to\n// call the deferred function.\n\n// The single argument isn't actually used - it just has its address\n// taken so it can be matched against pending defers.\n//go:nosplit\nfunc deferreturn(arg0 uintptr) { //è¿™è¾¹çš„arg0åªæ˜¯ä¸ºäº†è·å–å½“å‰çš„sp\n\tgp := getg()\n\td := gp._defer\t//è·å–_deferé“¾è¡¨å¤´éƒ¨\n    //å¦‚æœæ²¡æœ‰_defer,åˆ™è¿”å›,è¯¦è§ä¸Šé¢æ³¨é‡Š\n\tif d == nil {\n\t\treturn\n\t}\n    // å½“å‰goroutineçš„æ‰€æœ‰çš„_deferé€šè¿‡é“¾è¡¨è¿æ¥\n    // è¿™é‡Œé€šè¿‡æ¯”è¾ƒSPï¼Œç¡®ä¿åªæ‰§è¡Œå½“å‰å‡½æ•°çš„_defer\n\tsp := getcallersp(unsafe.Pointer(&arg0))\n\tif d.sp != sp {\n\t\treturn\n\t}\n\n\t// Moving arguments around.\n\t//\n\t// Everything called after this point must be recursively\n\t// nosplit because the garbage collector won't know the form\n\t// of the arguments until the jmpdefer can flip the PC over to\n\t// fn.\n    //æ‹·è´å‚æ•°åˆ°spä¸­\n\tswitch d.siz {\n\tcase 0:\n\t\t// Do nothing.\n\tcase sys.PtrSize:\n\t\t*(*uintptr)(unsafe.Pointer(&arg0)) = *(*uintptr)(deferArgs(d))\n\tdefault:\n\t\tmemmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))\n\t}\n\tfn := d.fn\n\td.fn = nil\n\tgp._defer = d.link //ä»é“¾è¡¨ä¸­ç§»é™¤\n\tfreedefer(d) //é‡Šæ”¾å½“å‰_defer\n    //call runtimeÂ·jmpdefer,\n    // which will jump to the deferred function such that it appears\n    // to have been called by the caller of deferreturn at the point\n    // just before deferreturn was called. The effect is that deferreturn\n    // is called again and again until there are no more deferred fns.\n    //æ‰§è¡Œfn,å¹¶ä¿®æ”¹pcä¸º `CALL\truntime.deferreturn(SB)`,ä¸‹ä¸€æ¡æŒ‡ä»¤å†æ¬¡è¿›å…¥è¯¥å‡½æ•°,å¦‚æœgp.deferä¸ºnilæˆ–è€…spä¸ä¸€è‡´,åˆ™è¿”å›,å¦åˆ™ç»§ç»­æ‰§è¡Œdefer\n    //æ¯æ¬¡æ·»åŠ deferæ—¶,æ€»æ˜¯æ·»åŠ åˆ°head,å¤„ç†æ—¶åˆ™æ˜¯ä»headå¼€å§‹å¤„ç†,å› æ­¤deferçš„å¤„ç†é¡ºåºæ˜¯FILO\n\tjmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))\n}\n```\n\nè‡³æ­¤ï¼Œdeferè¯­å¥çš„è¿è¡Œæœºåˆ¶åˆ†æå®Œæˆäº†ï¼Œä¸»è¦ç†äº†å¤§æ¦‚çš„æ‰§è¡Œæµç¨‹ï¼Œå…¶ä¸­è¿˜æœ‰ä¸€äº›ç»†èŠ‚ç”±äºç¯‡å¹…æœ‰é™å¹¶æ²¡æœ‰ç»†è¯´ï¼Œå¯ä»¥è‡ªè¡Œåˆ†æã€‚\n\ngoä¸­è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒç‹¬ç‰¹çš„åœ°æ–¹ï¼Œå¦‚æœç¨‹åºå‘ç”Ÿå¼‚å¸¸ï¼Œä¼šä¿è¯å…ˆæ‰§è¡Œæ‰€æœ‰deferå£°æ˜çš„å»¶æ—¶å‡½æ•°ï¼Œç„¶åæ‰é€€å‡ºç¨‹åºï¼›è€Œæˆ‘ä»¬å¯ä»¥åœ¨å»¶æ—¶å‡½æ•°ä¸­è·å–åˆ°å½“å‰æ•´ä¸ªå †æ ˆçš„ä¿¡æ¯ï¼Œæ¯”å¦‚è¯´ï¼š\n\n```\nå‡½æ•°Aæ‰§è¡Œdeferè¯­å¥ï¼Œè°ƒç”¨å‡½æ•°B\nå‡½æ•°Bå‡½æ•°Bå‘ç”Ÿpanic\næ‰§è¡Œå‡½æ•°Açš„å»¶æ—¶å‡½æ•°ï¼Œè¿™æ—¶å€™æ˜¯å¯ä»¥è·å–åˆ°å‡½æ•°Bçš„æ ˆå¸§æ•°æ®çš„\n```\n\næŒ‰ç…§ä¸Šé¢çš„æ‰§è¡Œæµç¨‹ï¼Œåœ¨æ‰§è¡Œå‡½æ•°Açš„å»¶æ—¶å‡½æ•°æ—¶ï¼Œå®é™…ä¸Šè¿™æ—¶å€™å‡½æ•°Bçš„æ ˆå¸§è¿˜æ²¡æœ‰å¼¹å‡ºï¼Œç¥å¥‡å§ï¼Ÿè¿™æ˜¯å› ä¸ºæ‰§è¡Œpanicæ—¶ï¼Œå°±ä¼šå»éå†å½“å‰goroutineçš„`_defer`é“¾è¡¨ï¼Œå¹¶ä¾æ¬¡æ‰§è¡Œè¿™äº›å»¶æ—¶å‡½æ•°ï¼Œè€Œä¸æ˜¯è¿”å›å‡½æ•°Aä¹‹åå†æ‰§è¡Œå‡½æ•°Açš„å»¶æ—¶å‡½æ•°ã€‚\n\nå®é™…çš„æ‰§è¡Œæµç¨‹æ˜¯è¿™æ ·çš„ï¼š\n\n```\nå‡½æ•°Aæ‰§è¡Œdeferè¯­å¥ï¼Œè°ƒç”¨å‡½æ•°B\nå‡½æ•°Bå‡½æ•°Bå‘ç”Ÿpanic\nåœ¨panicå†…éƒ¨ï¼Œéå†_deferé“¾è¡¨ï¼Œå¹¶ä¾æ¬¡æ‰§è¡Œå»¶æ—¶å‡½æ•°\nå¦‚æœæœ‰å»¶æ—¶å‡½æ•°æ‰§è¡Œäº†recoverï¼Œåˆ™åœ¨å»¶æ—¶å‡½æ•°è¿”å›åï¼Œç›´æ¥è·³è½¬åˆ°_defer.pcï¼Œè€Œä¸ä¼šæ‰§è¡Œåç»­çš„å»¶æ—¶å‡½æ•°\n```\n\n```go\n// å†…ç½®å‡½æ•°panicçš„å®ç°\nfunc gopanic(e interface{}) {\n\tgp := getg()  // å½“å‰panicçš„g\n\t\n    // åœ¨ç³»ç»Ÿæ ˆpanic\n    if gp.m.curg != gp {\n\t\tprint(\"panic: \")\n\t\tprintany(e)\n\t\tprint(\"\\n\")\n\t\tthrow(\"panic on system stack\") // throwæ˜¯ä¸å¯æ¢å¤çš„ï¼Œç›´æ¥ç»ˆæ­¢è¿›ç¨‹\n\t}\n    \n    // åœ¨å†…å­˜åˆ†é…è¿‡ç¨‹ä¸­panic\n\tif gp.m.mallocing != 0 {\n\t\tprint(\"panic: \")\n\t\tprintany(e)\n\t\tprint(\"\\n\")\n\t\tthrow(\"panic during malloc\")\n\t}\n    \n\tif gp.m.preemptoff != \"\" {\n\t\tprint(\"panic: \")\n\t\tprintany(e)\n\t\tprint(\"\\n\")\n\t\tprint(\"preempt off reason: \")\n\t\tprint(gp.m.preemptoff)\n\t\tprint(\"\\n\")\n\t\tthrow(\"panic during preemptoff\")\n\t}\n    \n\tif gp.m.locks != 0 {\n\t\tprint(\"panic: \")\n\t\tprintany(e)\n\t\tprint(\"\\n\")\n\t\tthrow(\"panic holding locks\")\n\t}\n\n\tvar p _panic\n\tp.arg = e\n\tp.link = gp._panic\n    // åœ¨deferä¸­å¯ä»¥é€šè¿‡recoverè·å–åˆ°è¯¥_panic\n\tgp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))\n    // ç»Ÿè®¡\n\tatomic.Xadd(&runningPanicDefers, 1)\n\n    // ä¾æ¬¡æ‰§è¡Œå½“å‰goroutineçš„_defer\n\tfor {\n\t\td := gp._defer\n\t\tif d == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// If defer was started by earlier panic or Goexit (and, since we're back here, that triggered a new panic),\n\t\t// take defer off list. The earlier panic or Goexit will not continue running.\n        // deferå·²ç»å¼€å§‹æ‰§è¡Œäº†ï¼Œæ‰§è¡Œdeferçš„æ—¶å€™åˆè§¦å‘äº†panic\n\t\tif d.started {\n            // å¦‚æœå­˜åœ¨æ—©æœŸçš„panic\n\t\t\tif d._panic != nil {\n                // ç»ˆæ­¢åŸæ¥çš„panic\n\t\t\t\td._panic.aborted = true\n\t\t\t}\n\t\t\td._panic = nil\n\t\t\td.fn = nil\n\t\t\tgp._defer = d.link\n\t\t\tfreedefer(d)\n            // ç»§ç»­ä¸‹ä¸€ä¸ªdefer\n\t\t\tcontinue\n\t\t}\n\n\t\t// Mark defer as started, but keep on list, so that traceback\n\t\t// can find and update the defer's argument frame if stack growth\n\t\t// or a garbage collection happens before reflectcall starts executing d.fn.\n\t\t// æ ‡è®°å¼€å§‹æ‰§è¡Œ\n        d.started = true\n\n\t\t// Record the panic that is running the defer.\n\t\t// If there is a new panic during the deferred call, that panic\n\t\t// will find d in the list and will mark d._panic (this panic) aborted.\n\t\t// è®¾ç½®defer\n        d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))\n\n\t\tp.argp = unsafe.Pointer(getargp(0))\n        // è°ƒç”¨deferå»¶æ—¶çš„å‡½æ•°\n\t\treflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))\n\t\tp.argp = nil\n\n\t\t// reflectcall did not panic. Remove d.\n\t\tif gp._defer != d {\n\t\t\tthrow(\"bad defer entry in panic\")\n\t\t}\n\t\td._panic = nil\n\t\td.fn = nil\n\t\tgp._defer = d.link\n\n\t\t// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic\n\t\t//GC()\n\n\t\tpc := d.pc\n\t\tsp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy\n\t\tfreedefer(d)\n        \n        // å¦‚æœåœ¨deferä¸­recoveräº†\n\t\tif p.recovered {\n\t\t\tatomic.Xadd(&runningPanicDefers, -1)\n\n\t\t\tgp._panic = p.link\n\t\t\t// Aborted panics are marked but remain on the g.panic list.\n\t\t\t// Remove them from the list.\n            // ç§»é™¤å·²ç»abortedçš„panic\n\t\t\tfor gp._panic != nil && gp._panic.aborted {\n\t\t\t\tgp._panic = gp._panic.link\n\t\t\t}\n\t\t\tif gp._panic == nil { // must be done with signal\n\t\t\t\tgp.sig = 0\n\t\t\t}\n\t\t\t// Pass information about recovering frame to recovery.\n\t\t\tgp.sigcode0 = uintptr(sp)\n\t\t\tgp.sigcode1 = pc\n\t\t\t// è°ƒç”¨recoveryï¼Œæ¢å¤æ‰§è¡Œ\n            mcall(recovery)\n\t\t\tthrow(\"recovery failed\") // mcall should not return\n\t\t}\n\t}\n\n\t// ran out of deferred calls - old-school panic now\n\t// Because it is unsafe to call arbitrary user code after freezing\n\t// the world, we call preprintpanics to invoke all necessary Error\n\t// and String methods to prepare the panic strings before startpanic.\n\tpreprintpanics(gp._panic)\n\n\tfatalpanic(gp._panic) // should not return\n\t*(*int)(nil) = 0      // not reached\n}\n```\n\n\n\næœ€åï¼Œ`defer`å‡½æ•°è™½ç„¶æ–¹ä¾¿ï¼Œä½†æ˜¯éœ€è¦æœ‰é¢å¤–çš„è¿è¡Œå¼€é”€ï¼Œåœ¨ä½¿ç”¨æ—¶éœ€è¦è¿›è¡Œå–èˆï¼Œå°¤å…¶æ˜¯å…·æœ‰å¤šä¸ªå‚æ•°çš„æ—¶å€™ï¼Œä¼šå‘ç”Ÿå¤šæ¬¡å†…å­˜æ‹·è´ï¼š\n\n```\nruntime.deferprocæ‰§è¡Œä¹‹å‰ï¼šç§»åŠ¨åˆ°æ ˆä¸­\nruntime.deferprocæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæ‹·è´_deferä¹‹å\nruntime.deferreturnæ‰§è¡Œæ—¶ï¼Œç§»åŠ¨åˆ°æ ˆä¸­\n```\n\nupdateï¼šgo1.13å¯¹deferè¿›è¡Œäº†ä¼˜åŒ–ï¼Œå¦‚æœ`_defer`æ²¡æœ‰å‘ç”Ÿé€ƒé€¸ï¼Œåˆ™å°†å…¶åˆ†é…åœ¨æ ˆä¸Šï¼Œå¯ä»¥æé«˜30%çš„æ€§èƒ½ã€‚\n\n\n\n\n\n","tags":["go","defer"]},{"title":"goç¨‹åºå¯åŠ¨è¿‡ç¨‹åˆ†æ","url":"/2018/01/07/goç¨‹åºå¯åŠ¨è¿‡ç¨‹åˆ†æ/","content":"\n\n\näº‹å®ä¸Šï¼Œç¼–è¯‘å¥½çš„å¯æ‰§â¾â½‚ä»¶çœŸæ­£æ‰§â¾æ—¶å¹¶â¾®æˆ‘ä»¬æ‰€å†™çš„ main.main å‡½æ•°ï¼Œå› ä¸ºç¼–è¯‘å™¨\n\næ€»æ˜¯ä¼šæ’â¼Šâ¼€æ®µå¼•å¯¼ä»£ç ï¼Œå®Œæˆè¯¸å¦‚å‘½ä»¤â¾å‚æ•°ã€è¿â¾æ—¶åˆå§‹åŒ–ç­‰â¼¯ä½œï¼Œç„¶åæ‰ä¼šè¿›â¼Šâ½¤\n\næˆ·é€»è¾‘ã€‚ \n\nç¨‹åºçš„å…¥å£å› å¹³å°è€Œå¼‚ï¼š\n\n```sh\nrt0_android_arm.s rt0_dragonfly_amd64.s rt0_linux_amd64.s ...\nrt0_darwin_386.s rt0_freebsd_386.s rt0_linux_arm.s ...\nrt0_darwin_amd64.s rt0_freebsd_amd64.s rt0_linux_arm64.s ...\n```\n\nrt0_linux_amd64.s:\n\n```assembly\nTEXT _rt0_amd64_linux(SB),NOSPLIT,$-8\n   LEAQ   8(SP), SI ; argv\n   MOVQ   0(SP), DI ; argc\n   MOVQ   $main(SB), AX\t\t;move address of main to ax\n   JMP    AX\n   \n   TEXT main(SB),NOSPLIT,$-8\n   MOVQ   $runtimeÂ·rt0_go(SB), AX\t;è·³è½¬åˆ°runtime.rt0.goæ‰§è¡Œ\n   JMP    AX\n```\n\nasm_amd64.s:\n\n```assembly\nTEXT runtimeÂ·rt0_go(SB),NOSPLIT,$0\n\t// copy arguments forward on an even stack\n\tMOVQ\tDI, AX\t\t// argc\n\tMOVQ\tSI, BX\t\t// argv\n\tSUBQ\t$(4*8+7), SP\t\t// 2args 2auto\n\tANDQ\t$~15, SP\n\tMOVQ\tAX, 16(SP)\n\tMOVQ\tBX, 24(SP)\n   ..\nok:\n\t; set the per-goroutine and per-mach \"registers\"\n\tget_tls(BX)\n\tLEAQ\truntimeÂ·g0(SB), CX\t;å°†g0çš„åœ°å€ä¿å­˜åˆ°CX\n\tMOVQ\tCX, g(BX)\t;è®¾ç½® g(BX)ä¸ºg0\n\tLEAQ\truntimeÂ·m0(SB), AX\t\n\n\t// save m->g0 = g0\n\tMOVQ\tCX, m_g0(AX)\t;è®¾ç½®m.g0\n\t// save m0 to g0->m\n\tMOVQ\tAX, g_m(CX)\t;è®¾ç½®g.m\n    ...\n\t;è°ƒç”¨åˆå§‹åŒ–å‡½æ•°\n\tMOVL\t16(SP), AX\t\t// copy argc\n\tMOVL\tAX, 0(SP)\n\tMOVQ\t24(SP), AX\t\t// copy argv\n\tMOVQ\tAX, 8(SP)\n\tCALL\truntimeÂ·args(SB)\t\t;\n\tCALL\truntimeÂ·osinit(SB)\t\t;\n\tCALL\truntimeÂ·schedinit(SB)\t;\n\n\t// create a new goroutine to start program\n\tMOVQ\t$runtimeÂ·mainPC(SB), AX\t\t// entry\n\tPUSHQ\tAX\n\tPUSHQ\t$0\t\t\t// arg size\n\t;åˆ›å»ºä¸€ä¸ªæ–°çš„goroutineå¹¶åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ï¼Œè¯¥goroutineæ‰§è¡Œruntime.mainPCæ‰€æŒ‡å‘çš„å‡½æ•°\n\tCALL\truntimeÂ·newproc(SB)\n\tPOPQ\tAX\n\tPOPQ\tAX\n\n\t;è¯¥å‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨è°ƒåº¦ç¨‹åºï¼Œä»è€Œè°ƒåº¦åˆ°åˆšåˆšåˆ›å»ºçš„goroutineæ‰§è¡Œ\n\tCALL\truntimeÂ·mstart(SB)\n\n\tMOVL\t$0xf1, 0xf1  // crash\n\tRET\n\n;å£°æ˜å…¨å±€çš„å˜é‡mainPCä¸ºruntime.mainå‡½æ•°çš„åœ°å€ï¼Œè¯¥å˜é‡ä¸ºread only\nDATA\truntimeÂ·mainPC+0(SB)/8,$runtimeÂ·main(SB)\t\nGLOBL\truntimeÂ·mainPC(SB),RODATA,$8\n```\n\n\n\nruntime1.go:\n\n```go\nfunc args(c int32, v **byte) {\n\targc = c\n\targv = v\n\tsysargs(c, v)\n}\nfunc sysargs(argc int32, argv **byte) {\n}\n```\n\nos_windows.go:\n\n```go\nfunc osinit() {\n    ...\n\tncpu = getproccount()\t//è·å–cpuæ ¸æ•°\n    ...\n}\n```\n\n\n\nproc.go:\n```go\n    // The bootstrap sequence is:\n    //\n    //\tcall osinit\n    //\tcall schedinit\n    //\tmake & queue new G\n    //\tcall runtimeÂ·mstart\n    //\n    // The new G calls runtimeÂ·main.\n    func schedinit() {\n    \t// raceinit must be the first call to race detector.\n    \t// In particular, it must be done before mallocinit below calls racemapshadow.\n    \t_g_ := getg()\t//è·å–çš„æ˜¯g0\n    \tif raceenabled {\n    \t\t_g_.racectx, raceprocctx0 = raceinit()\n    \t}\n    \t//æœ€å¤§ç³»ç»Ÿçº¿ç¨‹æ•°é‡é™åˆ¶\n    \tsched.maxmcount = 10000\n    \n    \ttracebackinit()\n    \tmoduledataverify()\n      \t//æ ˆã€å†…å­˜åˆ†é…å™¨å’Œè°ƒåº¦å™¨çš„ç›¸å…³åˆå§‹åŒ–\n    \tstackinit()\n    \tmallocinit()\n    \tmcommoninit(_g_.m)\n      \n    \talginit()       // maps must not be used before this call\n    \tmodulesinit()   // provides activeModules\n    \ttypelinksinit() // uses maps, activeModules\n    \titabsinit()     // uses activeModules\n    \n    \tmsigsave(_g_.m)\n    \tinitSigmask = _g_.m.sigmask\n    \n      \t//å¤„ç†å‘½ä»¤è¡Œå‚æ•°å’Œç¯å¢ƒå˜é‡\n    \tgoargs()\n    \tgoenvs()\n      \t\n      \t//å¤„ç† GODEBUGã€GOTRACEBACK è°ƒè¯•ç›¸å…³çš„ç¯å¢ƒå˜é‡è®¾ç½®\n    \tparsedebugvars()\n      \n      \t//åƒåœ¾å›æ”¶å™¨åˆå§‹åŒ–\n    \tgcinit()\n    \n    \tsched.lastpoll = uint64(nanotime())\n      \t//é€šè¿‡ CPUæ ¸å¿ƒæ•°å’ŒGOMAXPROCSç¯å¢ƒå˜é‡ç¡®å®šPçš„æ•°é‡ï¼ŒPç”¨äºè°ƒåº¦gåˆ°mä¸Š\n    \tprocs := ncpu\n    \tif n, ok := atoi32(gogetenv(\"GOMAXPROCS\")); ok && n > 0 {\n    \t\tprocs = n\n    \t}\n    \tif procs > _MaxGomaxprocs {\n    \t\tprocs = _MaxGomaxprocs\n    \t}\n    \tif procresize(procs) != nil {\n    \t\tthrow(\"unknown runnable goroutine during bootstrap\")\n    \t}\n    \n    \tif buildVersion == \"\" {\n    \t\t// Condition should never trigger. This code just serves\n    \t\t// to ensure runtimeÂ·buildVersion is kept in the resulting binary.\n    \t\tbuildVersion = \"unknown\"\n    \t}\n    }\n```\n\n```go\n    // Called to start an M.\n    //go:nosplit\n    func mstart() {\n    \t....\n    \tmstart1()\n    }\n```\n```go\n    func mstart1() {\n         ...\n      \t//è°ƒåº¦goroutine\n    \tschedule()\n    }\n\n```\n```go\n// goç¨‹åºç¼–è¯‘æ—¶ï¼Œä¼šåœ¨mainåŒ…ç”Ÿæˆinitå‡½æ•°ï¼Œè¯¥å‡½æ•°å†…è°ƒç”¨æ‰€æœ‰ä¾èµ–çš„åŒ…çš„initå‡½æ•°ï¼Œå¦‚æœåŒä¸€ä¸ªåŒ…è¢«ç¨‹åºé‡å¤å¼•å…¥å¤šæ¬¡ï¼Œä»–çš„initå‡½æ•°åªä¼šæ‰§è¡Œä¸€æ¬¡\n// å½“ç¼–è¯‘æ—¶ï¼Œé“¾æ¥å™¨ä¼šå°†main.inité“¾æ¥åˆ°main_init\n//go:linkname main_init main.init\nfunc main_init()\n// ç¼–è¯‘æ—¶ï¼Œé“¾æ¥å™¨ä¼šå°†ç”¨æˆ·çš„main.mainå‡½æ•°é“¾æ¥åˆ°main_main\n//go:linkname main_main main.main\nfunc main_main()\n\n// The main goroutine.\nfunc main() {\n\tg := getg()\t//å½“å‰è·å–çš„gæ˜¯åˆšåˆšåœ¨rt0_goå†…åˆ›å»ºçš„goroutine\n\n\t// Racectx of m0->g0 is used only as the parent of the main goroutine.\n\t// It must not be used for anything else.\n\tg.m.g0.racectx = 0\n\n\t// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.\n\t// Using decimal instead of binary GB and MB because\n\t// they look nicer in the stack overflow failure message.\n  \t//æ‰§è¡Œæ ˆæœ€å¤§é™åˆ¶ï¼š1GB on 64-bitï¼Œ250MB on 32-bit\n\tif sys.PtrSize == 8 {\t//64-bitä¸‹æŒ‡é’ˆé•¿åº¦æ˜¯8ä¸ªå­—èŠ‚\n\t\tmaxstacksize = 1000000000\n\t} else {\n\t\tmaxstacksize = 250000000\n\t}\n\n\t// Allow newproc to start new Ms.\n\tmainStarted = true\n\n  \t//å¯åŠ¨ç³»ç»Ÿåå°ç›‘æ§ï¼ˆå®šæœŸåƒåœ¾å›æ”¶ä»¥åŠå¹¶å‘ä»»åŠ¡çš„è°ƒåº¦ç­‰ï¼‰\n\tsystemstack(func() {\n\t\tnewm(sysmon, nil)\n\t})\n\n\t// Lock the main goroutine onto this, the main OS thread,\n\t// during initialization. Most programs won't care, but a few\n\t// do require certain calls to be made by the main thread.\n\t// Those can arrange for main.main to run in the main thread\n\t// by calling runtime.LockOSThread during initialization\n\t// to preserve the lock.\n\tlockOSThread()\n\n\tif g.m != &m0 {\n\t\tthrow(\"runtime.main not on m0\")\n\t}\n\n  \t//æ‰§è¡ŒruntimeåŒ…å†…çš„æ‰€æœ‰åˆå§‹åŒ–å‡½æ•° init\n\truntime_init() // must be before defer\n\tif nanotime() == 0 {\n\t\tthrow(\"nanotime returning zero\")\n\t}\n\n\t// Defer unlock so that runtime.Goexit during init does the unlock too.\n\tneedUnlock := true\n\tdefer func() {\n\t\tif needUnlock {\n\t\t\tunlockOSThread()\n\t\t}\n\t}()\n\n\t// Record when the world started. Must be after runtime_init\n\t// because nanotime on some platforms depends on startNano.\n\truntimeInitTime = nanotime()\n\n  \t//å¯åŠ¨åƒåœ¾å›æ”¶å™¨çš„åå°æ“ä½œ\n\tgcenable()\n\n\tmain_init_done = make(chan bool)\n\n  \t//æ‰§è¡Œç”¨æˆ·åŒ…ï¼ˆåŒ…æ‹¬æ ‡å‡†åº“ï¼‰çš„åˆå§‹åŒ–å‡½æ•° initï¼Œç¨‹åºæ‰€æœ‰çš„åŒ…çš„initå‡½æ•°éƒ½ä¼šåœ¨è¿™ä¸ªå‡½æ•°å†…è¢«å…¨éƒ¨æ‰§è¡Œ\n    // å› ä¸ºmain_initæ˜¯åœ¨ç¼–è¯‘æ—¶è¿›è¡Œé“¾æ¥çš„ï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨é—´æ¥è°ƒç”¨\n\tfn := main_init // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n\tfn()\n\tclose(main_init_done\n\tneedUnlock = false\n\tunlockOSThread()\n\n  \t//æ‰§è¡Œç”¨æˆ·é€»è¾‘å…¥å£ main.main å‡½æ•°\n\tfn = main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n\tfn()\n   ...\n  \t//æ‰§è¡Œç»“æŸï¼Œç¨‹åºæ­£å¸¸é€€å‡º\n\texit(0)\n}\n```\n\n\n### æ€»ç»“\n\nâ€¢ æ‰€æœ‰ init å‡½æ•°éƒ½åœ¨åŒâ¼€ä¸ª goroutine å†…æ‰§â¾\n\nâ€¢ æ‰€æœ‰ init å‡½æ•°ç»“æŸåæ‰ä¼šæ‰§â¾ main.main å‡½æ•° \n\n### å‚è€ƒ\n\n- é›¨ç—•çš„ Go 1.5æºç å‰–æ","tags":["go"]},{"title":"libtaskåˆ†æ","url":"/2017/12/29/libtaskåˆ†æ/","content":"\n\n\n`libtask` æ˜¯ä¸€ä¸ªå¼€æºçš„ `C` è¯­è¨€åç¨‹åº“ã€‚\n\n`C` è¯­è¨€åç¨‹å¯ä»¥é€šè¿‡æ›´æ”¹å¯„å­˜å™¨ï¼Œåˆ‡æ¢åç¨‹ä¸Šä¸‹æ–‡å®ç°åç¨‹è°ƒåº¦ã€‚\n\næ›´æ”¹å¯„å­˜å™¨å¯ä»¥é€šè¿‡ `C` è¯­è¨€å†…è”æ±‡ç¼–å®ç°ï¼Œé€šè¿‡æ±‡ç¼–ä»£ç ç›´æ¥æ›´æ”¹å¯„å­˜å™¨çš„å†…å®¹ã€‚\n\nä¹Ÿå¯ä»¥ä½¿ç”¨ `ucontext` é…åˆ `getContext` ã€ `setContext` ã€`makeContext` ã€`swapContext` å‡½æ•°æ¥å®ç°ã€‚\n\n`ucontext` ç»“æ„å°è£…äº†å¯„å­˜å™¨ä¿¡æ¯å’Œæ ˆä¿¡æ¯ï¼Œæ˜¯åç¨‹æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ï¼Œè€Œå…¶ä»–å››ä¸ªå‡½æ•°åˆ†åˆ«ç”¨äºè·å–å½“å‰æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ï¼Œè®¾ç½®å½“å‰ä¸Šä¸‹æ–‡ï¼Œåˆ›å»ºä¸Šä¸‹æ–‡å’Œäº¤æ¢ä¸Šä¸‹æ–‡ï¼Œè¿™äº›å‡½æ•°å·²ç»å°è£…äº†å¯¹å¯„å­˜å™¨å†…å®¹çš„äº¤æ¢å·¥ä½œã€‚\n\n##### Task\n\nä¸€ä¸ªTaskå¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªéœ€è¦å¼‚æ­¥æ‰§è¡Œçš„ä»»åŠ¡ï¼Œcoroutineçš„æŠ½è±¡æè¿°ã€‚\n\n```c\ntypedef struct Context Context;\t\nstruct Context\n{\n\tucontext_t\tuc;\t//ucontextå°è£…äº†åç¨‹æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ä¿¡æ¯\n};\nstruct Task\n{\n\tchar\tname[256];\t// offset known to acid\n\tchar\tstate[256];\n\tTask\t*next;\n\tTask\t*prev;\n\tTask\t*allnext;\n\tTask\t*allprev;\n\tContext\tcontext;\t//åç¨‹ä¸Šä¸‹æ–‡\n\tuvlong\talarmtime;\n\tuint\tid;\n\tuchar\t*stk;\t//åç¨‹æ ˆæŒ‡é’ˆ\n\tuint\tstksize;\t//æ ˆå¤§å°\n\tint\texiting;\n\tint\talltaskslot;\t//åœ¨å…¨å±€taskæ•°ç»„å†…çš„index\n\tint\tsystem;\n\tint\tready;\n\tvoid\t(*startfn)(void*);\t//Taskéœ€è¦æ‰§è¡Œçš„å‡½æ•°\n\tvoid\t*startarg;\t//startfn çš„å‚æ•°\n\tvoid\t*udata;\n};\n```\n\n##### Taskåˆ›å»º\n\n```c\nint taskcreate(void (*fn)(void*), void *arg, uint stack){\n\tint id;\n\tTask *t;\n\n\tt = taskalloc(fn, arg, stack);\t//åˆ†é…taskå’Œstackçš„ç©ºé—´\n\ttaskcount++;\t\n\tid = t->id;\n  //åˆ¤æ–­æ•°ç»„æ˜¯å¦è¿˜æœ‰è¶³å¤Ÿç©ºé—´\n\tif(nalltask%64 == 0){\n      //æ‰©å±•æ•°ç»„\n\t\talltask = realloc(alltask, (nalltask+64)*sizeof(alltask[0]));\n\t\tif(alltask == nil){\n\t\t\tfprint(2, \"out of memory\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n  \t//ä¿å­˜Taskåœ¨alltaskæ•°ç»„å†…çš„index\n\tt->alltaskslot = nalltask;\n\talltask[nalltask++] = t;\t//ä¿å­˜taskåˆ°alltaskæ•°ç»„\n\ttaskready(t);\t//è®¾ç½®ä¸ºreadyï¼Œå¯ä»¥è¢«è°ƒåº¦æ‰§è¡Œ\n\treturn id;\n}\n\n//taskallocåˆ†é…taskå’Œstackçš„ç©ºé—´\nstatic Task* taskalloc(void (*fn)(void*), void *arg, uint stack){\n\tTask *t;\n\tsigset_t zero;\n\tuint x, y;\n\tulong z;\n\n\t/* allocate the task and stack together */\n\tt = malloc(sizeof *t+stack);\t//åˆ†é…å†…å­˜ï¼Œstackç´§è·Ÿåœ¨taskä¹‹å\n\tif(t == nil){\n\t\tfprint(2, \"taskalloc malloc: %r\\n\");\n\t\tabort();\n\t}\n  \t//æ¸…é™¤taskçš„å†…å­˜\n\tmemset(t, 0, sizeof *t);\n\tt->stk = (uchar*)(t+1);\t//è®¾ç½®stackæŒ‡é’ˆï¼Œstackç´§è·Ÿtaskä¹‹åï¼Œt+1æŒ‡é’ˆåç§»ä¸€ä¸ªTaskå¤§å°\n\tt->stksize = stack;\t//è®¾ç½®stackå¤§å°\n\tt->id = ++taskidgen;\t//è®¾ç½®id\n\tt->startfn = fn;\t//è®¾ç½®ä»»åŠ¡éœ€è¦æ‰§è¡Œçš„å‡½æ•°\n\tt->startarg = arg;\t//startfnçš„å‚æ•°\n\n\t/* do a reasonable initialization */\n\tmemset(&t->context.uc, 0, sizeof t->context.uc);\n\tsigemptyset(&zero);\n\tsigprocmask(SIG_BLOCK, &zero, &t->context.uc.uc_sigmask);\n\n\t/* must initialize with current context */\n\tif(getcontext(&t->context.uc) < 0){\t//è·å–å½“å‰ucontextï¼Œå¹¶ä¿å­˜åˆ°t->context.uc\n\t\tfprint(2, \"getcontext: %r\\n\");\n\t\tabort();\n\t}\n\n\t/* call makecontext to do the real work. */\n\t/* leave a few words open on both ends */\n  \t//è®¾ç½®æ ˆé¡¶æŒ‡é’ˆå’Œæ ˆå¤§å°ï¼Œä¸¤ç«¯éƒ½ä¿ç•™ä¸€ç‚¹ç©ºé—´\n\tt->context.uc.uc_stack.ss_sp = t->stk+8;\t\n\tt->context.uc.uc_stack.ss_size = t->stksize-64;\n#if defined(__sun__) && !defined(__MAKECONTEXT_V2_SOURCE)\t\t/* sigh */\n#warning \"doing sun thing\"\n\t/* can avoid this with __MAKECONTEXT_V2_SOURCE but only on SunOS 5.9 */\n\tt->context.uc.uc_stack.ss_sp = \n\t\t(char*)t->context.uc.uc_stack.ss_sp\n\t\t+t->context.uc.uc_stack.ss_size;\n#endif\n\t/*\n\t * All this magic is because you have to pass makecontext a\n\t * function that takes some number of word-sized variables,\n\t * and on 64-bit machines pointers are bigger than words.\n\t */\n//print(\"make %p\\n\", t);\n  //è®¡ç®—startfnçš„å‚æ•°:y,x\n  /**\n  taskstartçš„å‚æ•°æ˜¯uintï¼Œå³32ä½ï¼Œè€ŒæŒ‡é’ˆå¦‚æœæ˜¯64ä½ï¼Œåˆ™éœ€è¦å°†æŒ‡é’ˆçš„é«˜32ä½å’Œä½32ä½åˆ†ç¦»ï¼Œåˆ†åˆ«ä¼ é€’\n  å°†æŒ‡é’ˆåˆ†ç¦»ä¸ºé«˜32ä½(x)å’Œä½32ä½(y)ï¼Œåœ¨taskstartå†…å†é€šè¿‡ä¸¤ä¸ªå‚æ•°åˆæˆtaskæŒ‡é’ˆ\n  è¯¥æ–¹æ³•å¯ä»¥åŒæ—¶é€‚ç”¨äº32ä½å’Œ64ä½çš„ç¼–è¯‘å™¨\n  **/\n\tz = (ulong)t;\n\ty = z;\n\tz >>= 16;\t/* hide undefined 32-bit shift from 32-bit compilers */\n\tx = z>>16;\n  //è¿™é‡Œä¼ å…¥çš„æ˜¯taskstartå‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°å†…æ‰§è°ƒç”¨t->startfnï¼Œå¹¶ä¼ å…¥t->startarg\n\tmakecontext(&t->context.uc, (void(*)())taskstart, 2, y, x);\n\n\treturn t;\n}\n\n/**\nåˆå§‹åŒ–uc_contextï¼Œset the context of coroutine\n**/\n#ifdef NEEDAMD64MAKECONTEXT\nvoid\nmakecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)\n{\n\tlong *sp;\n\tva_list va;\t//ç”¨äºéå†å¯å˜é•¿å‚æ•°çš„æŒ‡é’ˆ\n\n\tmemset(&ucp->uc_mcontext, 0, sizeof ucp->uc_mcontext);\n\tif(argc != 2)\n\t\t*(int*)0 = 0;\t//æŠ¥é”™\n\tva_start(va, argc);\t//éå†å¯å˜å‚æ•°\n\t//å‰6ä¸ªå‚æ•°å¯ä»¥ä½¿ç”¨å¯„å­˜å™¨ï¼ˆ%rdiï¼Œ%rsiï¼Œ%rdxï¼Œ%rcxï¼Œ%r8ï¼Œ%r9ï¼‰ä¿å­˜ï¼Œåé¢å‚æ•°å…¥æ ˆ\n\t//ç”¨äºä¼ é€’å‡½æ•°å‚æ•°ï¼Œrdiï¼šç¬¬ä¸€ä¸ªå‚æ•°ï¼Œrsiï¼šç¬¬äºŒä¸ªå‚æ•°ï¼›è°ƒç”¨funcæ—¶ä¼ å…¥rdiå’Œrsi\n\tucp->uc_mcontext.mc_rdi = va_arg(va, int);\n\tucp->uc_mcontext.mc_rsi = va_arg(va, int);\n\tva_end(va);\n\t/**è®¾ç½®æ ˆæŒ‡é’ˆ**/\n\tsp = (long*)ucp->uc_stack.ss_sp+ucp->uc_stack.ss_size/sizeof(long);\t//ç§»åŠ¨spæŒ‡é’ˆ\n\tsp -= argc;\t\n\tsp = (void*)((uintptr_t)sp - (uintptr_t)sp%16);\t/* 16-align for OS X */ //åœ°å€å¯¹é½\n\t*--sp = 0;\t/* return address */\n\tucp->uc_mcontext.mc_rip = (long)func;\t//ipï¼Œripå­˜æ”¾ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€\n\tucp->uc_mcontext.mc_rsp = (long)sp;\t//æ ˆé¡¶æŒ‡é’ˆ\n}\n#endif\n\nstatic void\ntaskstart(uint y, uint x)\n{\n\tTask *t;\n\tulong z;\n\t// t = (x<<32)|y\n\tz = x<<16;\t/* hide undefined 32-bit shift from 32-bit compilers */\n\tz <<= 16;\n\tz |= y;\n\tt = (Task*)z;\t//è·å–taskåœ°å€\n\n//print(\"taskstart %p\\n\", t);\n\tt->startfn(t->startarg);\t//è°ƒç”¨startfn\n//print(\"taskexits %p\\n\", t);\n\ttaskexit(0);\t//startfnç»“æŸï¼Œè®¾ç½®é€€å‡ºæ ‡å¿—ä½\n//print(\"not reacehd\\n\");\n}\n```\n\n### Taskè°ƒåº¦\n\n```c\ntypedef struct Tasklist Tasklist;\nstruct Tasklist\t/* used internally */\n{\n\tTask\t*head;\n\tTask\t*tail;\n};\n```\n\n```c\nContext\ttaskschedcontext;\t\nTasklist\ttaskrunqueue;\nTask\t*taskrunning;\n\nvoid\nneedstack(int n)\n{\n\tTask *t;\n\n\tt = taskrunning;\n\n\tif((char*)&t <= (char*)t->stk\n\t|| (char*)&t - (char*)t->stk < 256+n){\n\t\tfprint(2, \"task stack overflow: &t=%p tstk=%p n=%d\\n\", &t, t->stk, 256+n);\n\t\tabort();\n\t}\n}\n\nvoid\ntaskswitch(void)\n{\n\tneedstack(0);\n\tcontextswitch(&taskrunning->context, &taskschedcontext);\n}\n\nint\nswapcontext(ucontext_t *oucp, const ucontext_t *ucp)\n{\n\tif(getcontext(oucp) == 0)\t//get the context into *oucp\n\t\tsetcontext(ucp);\t//set the context as *ucp\n\treturn 0;\n}\n\nvoid\ntaskready(Task *t)\n{\n\tt->ready = 1;\n\taddtask(&taskrunqueue, t);\t//åŠ å…¥è°ƒåº¦é˜Ÿåˆ—\n}\n\nint\ntaskyield(void)\n{\n\tint n;\n\t\n\tn = tasknswitch;\n\ttaskready(taskrunning);\t//å°†å½“å‰taskåŠ å…¥ç­‰å¾…é˜Ÿåˆ—\n\ttaskstate(\"yield\");\n\ttaskswitch();\t//åˆ‡æ¢\n\treturn tasknswitch - n - 1;\n}\n\nint\nanyready(void)\n{\n\treturn taskrunqueue.head != nil;\t//åˆ¤æ–­ç­‰å¾…é˜Ÿåˆ—é˜Ÿé¦–æ˜¯å¦ä¸ºç©º\n}\n\nvoid\ntaskexit(int val)\n{\n\ttaskexitval = val;\n\ttaskrunning->exiting = 1;\n\ttaskswitch();\t//åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œæ‰§è¡Œè°ƒåº¦ç¨‹åº\n}\n\n\nstatic void\ntaskscheduler(void)\n{\n\tint i;\n\tTask *t;\n\n\ttaskdebug(\"scheduler enter\");\n\tfor(;;){\n\t\tif(taskcount == 0)\n\t\t\texit(taskexitval);\n\t\tt = taskrunqueue.head;\n\t\tif(t == nil){\n\t\t\tfprint(2, \"no runnable tasks! %d tasks stalled\\n\", taskcount);\n\t\t\texit(1);\n\t\t}\n\t\tdeltask(&taskrunqueue, t);\n\t\tt->ready = 0;\n\t\ttaskrunning = t;\t//è®¾ç½®taskrunning\n\t\ttasknswitch++;\n\t\ttaskdebug(\"run %d (%s)\", t->id, t->name);\n      //å½“å‰contextä¿å­˜åˆ°taskschedcontextï¼Œå³taskschedcontextä¸ºè°ƒåº¦ä¸Šä¸‹æ–‡\n\t\tcontextswitch(&taskschedcontext, &t->context);\t//äº¤æ¢ task context\n//print(\"back in scheduler\\n\");\n\t\ttaskrunning = nil;\n\t\tif(t->exiting){\t//å¦‚æœé€€å‡º\n\t\t\tif(!t->system)\n\t\t\t\ttaskcount--;\n\t\t\ti = t->alltaskslot;\n\t\t\talltask[i] = alltask[--nalltask];\t//æ›¿æ¢ä¸ºå…¨å±€æ•°ç»„çš„æœ€åä¸€ä¸ªtask\n\t\t\talltask[i]->alltaskslot = i;\n\t\t\tfree(t);\t//é‡Šæ”¾task\n\t\t}\n\t}\n}\n\n/*\n * startup\n */\n\nstatic int taskargc;\nstatic char **taskargv;\nint mainstacksize;\n\nstatic void\ntaskmainstart(void *v)\n{\n\ttaskname(\"taskmain\");\n\ttaskmain(taskargc, taskargv);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tstruct sigaction sa, osa;\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_handler = taskinfo;\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGQUIT, &sa, &osa);\n\n#ifdef SIGINFO\n\tsigaction(SIGINFO, &sa, &osa);\n#endif\n\n\targv0 = argv[0];\n\ttaskargc = argc;\n\ttaskargv = argv;\n\n\tif(mainstacksize == 0)\n\t\tmainstacksize = 256*1024;\n\ttaskcreate(taskmainstart, nil, mainstacksize);\n\ttaskscheduler();\n\tfprint(2, \"taskscheduler returned in main!\\n\");\n\tabort();\n\treturn 0;\n}\n```\n","tags":["libtask"]},{"title":"kotlinå‡½æ•°åˆçº§å…¥é—¨","url":"/2017/12/11/kotlinå‡½æ•°åˆçº§å…¥é—¨/","content":"\n\n\n### æ™®é€šå‡½æ•°å£°æ˜\nä½¿ç”¨ `func` å…³é”®å­—å£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œåƒè¿™æ ·\n\n```kotlin\nfun add(a:Int,b:Int):Int{\n    return a+b\n}\n```\n**åœ¨`kotlin`ä¸­ï¼Œæ‰€æœ‰å‡½æ•°çš„å‚æ•°éƒ½æ˜¯`val`çš„ï¼Œå³ä¸å¯å˜å‚æ•°**\nå¦‚æœå‡½æ•°ä½“åªæœ‰ä¸€è¡Œä»£ç ï¼Œå¯ä»¥ç®€æ´ç‚¹ï¼š\n```kotlin\nfun add(a: Int, b: Int): Int = a + b\n```\næ›´ç®€å•ç‚¹ï¼Œè¿”å›å€¼è‡ªåŠ¨æ¨æ–­ï¼š\n```kotlin\nfun add(a: Int, b: Int) = a + b\n```\n###å¸¦é»˜è®¤å€¼çš„å‡½æ•°\nå¯ä»¥åœ¨å£°æ˜å‡½æ•°å‚æ•°çš„æ—¶å€™ï¼Œç›´æ¥æŒ‡å®šé»˜è®¤å€¼ï¼Œå¦‚æœè°ƒç”¨æ—¶æ²¡æœ‰ä¼ å…¥ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼ï¼Œå¸¦æœ‰é»˜è®¤å€¼çš„å‚æ•°å¯ä»¥åœ¨ä»»ä½•ä½ç½®\n```kotlin\nfun add(a: Int=1, b: Int) = a + b\n```\nè°ƒç”¨çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨`å‚æ•°å=å€¼`çš„å½¢å¼ç»™å‡ºå‚æ•°\n```kotlin\nadd(b=1)\n```\næ¢ä¸ªä½ç½®å£°æ˜é»˜è®¤å€¼ï¼š\n```kotlin\nfun add(a: Int , b: Int=1) = a + b\nfun adds (a:Int,b:Int=1,c:Int)= a+b+c\nfun main(vararg args:String){\n    add(1)    //è‡ªåŠ¨åŒ¹é…ç¬¬ä¸€ä¸ªå‚æ•°\n    adds (1,c=2)    //é»˜è®¤å€¼ä¹‹åçš„å‚æ•°éœ€è¦æ˜¾ç¤ºæŒ‡å‡ºå‚æ•°å\n}\n```\nå‡½æ•°åŒ¹é…ä¼˜å…ˆçº§ï¼š\n```kotlin\nfun add(a:Int) = a*a\nfun add(a: Int , b: Int=1) = a + b\nfun main(vararg args:String){\n   println(add(3))  //è¾“å‡º 9 \n}\n```\nå½“æœ‰å¤šä¸ªå‡½æ•°åŒ¹é…æ—¶ï¼Œå¸¦é»˜è®¤å€¼å‚æ•°ä¸ªæ•°å°‘çš„ä¼˜å…ˆçº§è¶Šé«˜ï¼Œä¸å¸¦é»˜è®¤å€¼çš„ä¼˜å…ˆçº§æœ€é«˜\n\n### å¯å˜å‚æ•°\nåœ¨`kotlin`ä¸­ï¼Œä½¿ç”¨ `vararg` å…³é”®å­—æ¥æ ‡è¯†å¯å˜å‚æ•°\nå’Œ`java`ä¸€æ ·ï¼Œå¤šä¸ªå‚æ•°ä¼šè¢«å°è£…æˆæ•°ç»„èµ‹å€¼ç»™a\n\n```kotlin\nfun add(vararg a: Int, b: Int):Int{\n    var sum :Int = 0\n    a.forEach { \n        sum+=it\n    }\n    return sum+b\n}\n```\nå’Œ`java`ä¸åŒçš„æ˜¯ï¼Œåœ¨javaä¸­æˆ‘ä»¬å¯ä»¥ç›´æ¥å°†ä¸€ä¸ªæ•°ç»„èµ‹å€¼ç»™å¯å˜å‚æ•°ï¼Œè¿™æœ‰æ—¶å€™ä¼šå¼•èµ·æ··æ·†ï¼Œå› æ­¤åœ¨kotlinä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ˜¾ç¤ºä½¿ç”¨è¿ç®—ç¬¦`*`å°†æ•°ç»„è§£æ„æˆå…ƒç´ \næ¯”å¦‚æˆ‘ä»¬å¯ä»¥è¿™æ ·è°ƒç”¨ä¸Šé¢çš„æ–¹æ³•ï¼š\n```kotlin\nfun main(vararg args: String) {\n    var arr = IntArray(10) { it }\n    add(*arr, b = 1)\n}\n```\næ³¨æ„ï¼Œç¬¬äºŒä¸ªå‚æ•°æˆ‘ä»¬éœ€è¦æ˜ç¡®æŒ‡å‡ºä»–çš„å‚æ•°åï¼Œå¦åˆ™ä»–ä¼šè¢«å½“ä½œå¯å˜å‚æ•°ä¸­çš„ä¸€ä¸ªå€¼\n\n### ä½¿ç”¨lambda\n`lambda`æ˜¯ä¸€ç§ç‰¹æ®Šçš„å‡½æ•°ã€‚å’Œä¼ ç»Ÿå‡½æ•°ä¸åŒçš„æ˜¯ï¼Œä»–å¯ä»¥è¢«å­˜å‚¨ï¼Œä¼ é€’ï¼Œå¹¶ä¸”å¯ä»¥æ•è·å¤–éƒ¨å˜é‡å½¢æˆé—­åŒ…ã€‚\n#####`lambda`çš„ç±»å‹\nå› ä¸º`lambda`æœ¬è´¨ä¸Šè¿˜æ˜¯å¯¹è±¡ï¼Œå› æ­¤ä»–æ˜¯æœ‰ç±»å‹çš„ã€‚\n `lambda`çš„ç±»å‹æ ¼å¼ä¸ºï¼š\n\n```kotlin\n(å‚æ•°åˆ—è¡¨)->è¿”å›å€¼ç±»å‹\n```\n`lambda`çš„`body`ç»“æ„ä¸ºï¼š\n```kotlin\n{å½¢å‚åˆ—è¡¨->\n  è¯­å¥\n  ...\n  æœ€åä¸€ä¸ªè¯­å¥çš„å€¼ä¸ºè¿”å›å€¼ï¼ˆå¦‚æœéœ€è¦è¿”å›å€¼ï¼‰\n}\n```\næ¯”å¦‚ï¼š\n```kotlin\nval max:(Int,Int)->Int = {a,b -> if (a>b) a else b}\n```\n`max`ç”¨äºæ¯”è¾ƒä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬ä¸­çš„æœ€å¤§è€…ã€‚å› ä¸ºè¿™è¾¹æ¥æ”¶äº†ä¸¤ä¸ªå‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨`lambda`çš„`body`ä¸­æ˜¾ç¤ºçš„ä¸ºè¿™ä¸¤ä¸ªå‚æ•°æŒ‡å®šä¸€ä¸ªåå­—ï¼Œå°±åƒæˆ‘ä»¬éœ€è¦ä¸ºå‡½æ•°æŒ‡å®šå½¢å‚åã€‚\nä¸Šé¢çš„ä¾‹å­ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š\n```kotlin\nval max =  { a:Int,b:Int-> if (a>b) a else b}  as (Int,Int)->Unit\n```\nä¸è¿‡è¿™æ˜¯æ¯”è¾ƒ2bçš„å†™æ³•äº†ï¼Œä½¿ç”¨`as`å¯¹`lambda`è¿›è¡Œç±»å‹è½¬æ¢ï¼Œç„¶å`max`çš„ç±»å‹è‡ªåŠ¨æ¨å‡ºï¼Œè¿™é‡Œæˆ‘åªæ˜¯æƒ³è¯´æ˜`lambda`æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸ªå¯¹è±¡ï¼Œå› æ­¤ä¸€æ ·å¯ä»¥è¿›è¡Œç±»å‹è½¬æ¢ã€‚\n\n### é«˜é˜¶å‡½æ•°\n`lambda`å¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°æˆ–è€…è¿”å›å€¼ï¼Œä¸¾ä¸ªä¾‹å­ï¼š\n\n```kotlin\nfun <T> forEach(list:List<T>,block:(t:T)->Unit){\n    for (t in list){\n        block(t)\n    }\n}\n\nfun main(vararg args:String){\n    var list = listOf(1,2,3,4,5)\n    forEach(list){\n        println(it)\n    }\n}\n```\nåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ª`forEach`çš„å‡½æ•°ï¼Œä»–çš„åŠŸèƒ½æ˜¯éå†ä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶å¯¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨æŒ‡å®šçš„`lambda`ï¼Œç„¶åæˆ‘ä»¬åœ¨`main`å‡½æ•°ä¸­è°ƒç”¨å®ƒã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå½“æˆ‘ä»¬çš„`lambda`æ˜¯å‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶å†™åœ¨`()`å¤–é¢ï¼Œå½“å‡½æ•°å‚æ•°åªæœ‰ä¸€ä¸ª`lambda`æ—¶ï¼Œå¯ä»¥ç›´æ¥çœç•¥`()`ï¼›\nè¿˜æœ‰ç¬¬äºŒä¸ªè¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†åŒ¿åå‚æ•°ï¼Œå½“`lambda`åªæœ‰ä¸€ä¸ªå‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨æ˜¾ç¤ºçš„æŒ‡å®šä¸€ä¸ªå‚æ•°åï¼Œè€Œæ˜¯ä½¿ç”¨é»˜è®¤çš„`it`æ¥å¼•ç”¨ã€‚\n\n### æ‰©å±•å‡½æ•°\nåœ¨`kotlin`ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿çš„æ‰©å±•æŸä¸ªç±»ï¼Œä¸ºå…¶å¢åŠ æ–¹æ³•ï¼š\n\n```kotlin\nfun Int.compareWith(a: Int): Int {\n    return when {\n        this > a -> 1\n        this < a -> -1\n        else -> 0\n    }\n}\n\nfun main(vararg args: String) {\n    println(10.compareWith(4))\n}\n```\nå¦‚ä¸Šæ‰€ç¤ºï¼Œå£°æ˜ä¸€ä¸ªæ‰©å±•å‡½æ•°çš„è¯­æ³•å¾ˆç®€å•ï¼Œåªéœ€è¦åœ¨æ–¹æ³•åå‰é¢åŠ ä¸Š`ç±»å.`ï¼Œåœ¨æ–¹æ³•ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`this`æ¥å¼•ç”¨ä»–ï¼Œä½†æ˜¯åªèƒ½è®¿é—®`public`çš„æˆå‘˜ã€‚è¿™ä¸ª`ç±»å`æˆ‘ä»¬ä½¿ç”¨`receiver`æ¥æè¿°å®ƒã€‚\næ‰©å±•å‡½æ•°åªæ˜¯`kotlin`ä¸­ä¼—å¤šè¯­æ³•ç³–ä¸­çš„ä¸€ä¸ªï¼Œä»–å¹¶æ²¡æœ‰çœŸæ­£çš„æ‰©å±•è¿™ä¸ªç±»ï¼Œåªæ˜¯å°†æ–¹æ³•çš„ä¸€ä¸ªå‚æ•°æåˆ°äº†æ–¹æ³•åå‰é¢ä½œä¸º`receiver`ï¼š\n```kotlin\nfun Int.compareWith(a:Int):Int\n===>\nfun compareWith(this:Int,a:Int):Int  \n```\næ‰€ä»¥è°ƒç”¨æ‰©å±•å‡½æ•°å’Œæ™®é€šçš„å‡½æ•°è°ƒç”¨æ²¡æœ‰åŒºåˆ«ï¼Œå‡½æ•°çš„`receiver`æœ¬è´¨ä¸Šè¿˜æ˜¯è¿™ä¸ªå‡½æ•°çš„å‚æ•°ï¼Œè€Œä¸æ˜¯è¿™ä¸ªæ–¹æ³•çš„æ‰€æœ‰è€…ï¼Œå› æ­¤åœ¨è°ƒç”¨æ—¶ä½¿ç”¨çš„æ˜¯é™æ€åˆ†æ´¾ï¼Œå¹¶ä¸æ”¯æŒå¤šæ€ã€‚\nè€Œä¸”å½“æ‰©å±•å‡½æ•°ä¸ç±»çš„æ–¹æ³•å†²çªæ—¶ï¼Œé»˜è®¤ä½¿ç”¨çš„æ˜¯ç±»çš„æ–¹æ³•ã€‚\n\n##### ç»“åˆæ³›å‹çš„æ‰©å±•å‡½æ•°\n\n```kotlin\nfun <T:Any> T?.toStr(){\n    println(this?.toString()?:\"this is a null ref\")\n}\nfun main(vararg args:String){\n    null.toStr()\n}\n```\næ­£å¦‚ä¸Šé¢çš„ä¾‹å­ä¸­æ‰€çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ³›å‹å‚æ•°ä½œä¸ºå‡½æ•°çš„`receiver`ï¼Œè€Œä¸”æˆ‘ä»¬ä½¿ç”¨äº†`T?`ï¼Œè¯´æ˜æ”¯æŒ`null`\n\n##### å‡½æ•°å‚æ•°ä½¿ç”¨æ‰©å±•å‡½æ•°\nå¯¹åˆšåˆšçš„`forEach`å‡½æ•°ç¨åŠ æ”¹é€ ï¼š\n\n```kotlin\nfun <T> forEach(list:List<T>,block:T.()->Unit){\n    for (t in list){\n       t.block()\n    }\n}\n\nfun main(vararg args:String){\n    var list = listOf(1,2,3,4,5)\n    forEach(list){\n        println(this)\n    }\n}\n```\næ³¨æ„åœ¨å£°æ˜å‡½æ•°å‚æ•°æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`T.()->Unit`ï¼Œä¹Ÿå°±æ˜¯å£°æ˜äº†ä¸€ä¸ªå…·æœ‰`receiver`çš„`lambda`\n\n ","tags":["kotlin"]},{"title":"ä½¿ç”¨kotlinè‡ªå®šä¹‰ç”Ÿæˆå™¨","url":"/2017/12/02/ä½¿ç”¨kotlinè‡ªå®šä¹‰ç”Ÿæˆå™¨/","content":"\nä½¿ç”¨kotlinçš„coroutineæœºåˆ¶ï¼Œå¯ä»¥å¾ˆå®¹æ˜“å®ç°ä¸€ä¸ªgenerator\n\n```kotlin\nimport java.util.concurrent.atomic.AtomicReference\nimport kotlin.coroutines.experimental.*\n\n\nclass Generater<T : Any> private constructor() {\n    private var mContinuation: AtomicReference<Continuation<Unit>?> = AtomicReference(null)\n    private val values: ThreadLocal<T?> = ThreadLocal()\n    /**\n     * -1:ç»“æŸ\n     *  0:æœªå¼€å§‹\n     *  1:å¼€å§‹\n     */\n    @Volatile\n    private var status: Int = 0\n\n    companion object {\n        fun <T : Any> build(block: suspend Generater<T>.() -> Unit): Generater<T> {\n            val g = Generater<T>()\n            var c = object : Continuation<Unit> {\n                override val context: CoroutineContext\n                    get() = EmptyCoroutineContext\n\n                override fun resume(value: Unit) {\n                    g.status = -1\n                }\n\n                override fun resumeWithException(exception: Throwable) {\n                    g.status = -1\n                    throw exception\n                }\n            }\n            g.mContinuation.compareAndSet(null, block.createCoroutine(g, c))\n            g.status = 1\n            return g\n        }\n    }\n\n    suspend fun yield(t: T?) {\n        suspendCoroutine<Unit> {\n            values.set(t)\n            mContinuation.compareAndSet(null, it)\n            //Thread.sleep(100)\n        }\n    }\n\n    fun next(): T? {\n        while (true) {\n            if (status == -1) {\n                values.set(null)\n                break\n            }\n          \t//å¯ä»¥æåˆ°å¾ªç¯å¤–é¢\n            if (status == 0) {\n                throw IllegalStateException(\"ç”Ÿæˆå™¨æœªå¯åŠ¨\")\n            }\n            val c = mContinuation.getAndSet(null)\n            c ?: continue\n\n            synchronized(this) {\n                c.resume(Unit)\n            }\n            break\n        }\n        return values.get()\n    }\n\n}\n```\n\nä½¿ç”¨\n\n```kotlin\n\nfun main(vararg args: String) {\n\t//å£°æ˜ç”Ÿæˆå™¨\n    var g = Generater.build {\n        yield(0L)\n        var i = 0L\n        var j = 1L\n        while (true) {\n            yield(j)\n            var next = i + j\n            i = j\n            j = next\n        }\n    }\n\t//å¤šçº¿ç¨‹è®¿é—®\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n\n    Thread {\n        for (i in 0..2)\n            println(Thread.currentThread().name + \":\" + g.next())\n    }.start()\n}\n```\n\n","tags":["kotlin","coroutine","generator"]},{"title":"ä½¿ç”¨kotlinåç¨‹æœºåˆ¶æ’¸ä¸€ä¸ªç®€æ˜“çš„å¼‚æ­¥æ‰§è¡Œåº“","url":"/2017/11/10/ä½¿ç”¨kotlinåç¨‹æœºåˆ¶æ’¸ä¸€ä¸ªç®€æ˜“çš„å¼‚æ­¥æ‰§è¡Œåº“/","content":"\n\n\n> ç”±äºandroidé™åˆ¶äº†åªèƒ½åœ¨UIçº¿ç¨‹æ›´æ–°è§†å›¾ï¼Œè€Œåœ¨UIçº¿ç¨‹ä¸­åšè€—æ—¶ä»»åŠ¡åˆä¼šå¯¼è‡´ANRï¼Œå› æ­¤åœ¨å¹³æ—¶çš„å¼€å‘ä¸­ï¼Œéœ€è¦å°†è€—æ—¶çš„æ•°æ®è¯·æ±‚å·¥ä½œæ”¾åˆ°å­çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œè€Œè§†å›¾æ›´æ–°å·¥ä½œæ”¾åˆ°UIçº¿ç¨‹ä¸­ï¼Œä½¿ç”¨ä¼ ç»Ÿçš„handleræˆ–è€…asyncTaskï¼Œéœ€è¦å°†é€»è¾‘åˆ†åˆ°å¤šä¸ªå‡½æ•°å†…\n\n**ä½¿ç”¨`kotlin`çš„åç¨‹æœºåˆ¶ï¼Œå¯ä»¥ç”¨åŒæ­¥çš„æ–¹å¼å®ç°å¼‚æ­¥**\nkotlinçš„åç¨‹æœºåˆ¶æ˜¯åŸºäºçŠ¶æ€æœºæ¨¡å‹å’Œ`C-P-S`é£æ ¼å®ç°çš„ã€‚\nä¸€ä¸ªåç¨‹é€šè¿‡`resume`å¯åŠ¨ï¼Œå½“åç¨‹å†…éƒ¨è°ƒç”¨`supended`å‡½æ•°æ—¶ï¼Œåç¨‹ä¼šè¢«æš‚åœï¼Œé€šè¿‡è°ƒç”¨ `resume`å¯ä»¥å†æ¬¡å¯åŠ¨åç¨‹ã€‚æ¯æ¬¡æš‚åœéƒ½ä¼šä¿®æ”¹åç¨‹çš„çŠ¶æ€ï¼Œå†æ¬¡å¯åŠ¨åç¨‹æ—¶ï¼Œä¼šä»æ–°çš„çŠ¶æ€å¤„å¼€å§‹æ‰§è¡Œã€‚\n\nç°åœ¨é€šè¿‡kotlinçš„åŸºç¡€apiå®ç°ä¸€ä¸ªç®€å•çš„å¼‚æ­¥è°ƒç”¨æ¥å£ï¼Œæœ€åçš„æ•ˆæœå¦‚ä¸‹ï¼š\n\n ```\n btn.setOnClickListener {\n            runOnUI {  \n                //æ‰§è¡Œåœ¨ä¸»çº¿ç¨‹ï¼Œå¯ä»¥åšä¸€äº›åˆå§‹åŒ–æ“ä½œ                         \n                Log.e(\"log\", Thread.currentThread().name)\n                var used = async {               //ä»å·¥ä½œçº¿ç¨‹ç›´æ¥è¿”å›æ•°æ®åˆ°ä¸»çº¿ç¨‹\n                   //åˆ‡æ¢åˆ°å·¥ä½œçº¿ç¨‹æ‰§è¡Œï¼Œè€Œä¸”lambdaå¯ä»¥ç›´æ¥è®¿é—®å¤–éƒ¨å˜é‡ï¼Œæ„æˆé—­åŒ…\n                    Log.e(\"log\", Thread.currentThread().name)\n                    var start = System.currentTimeMillis()\n                    Thread.sleep(3000)\n                    System.currentTimeMillis() - start\n                }\n                //ç»§ç»­æ‰§è¡Œåœ¨ä¸»çº¿ç¨‹\n                Log.e(\"log\", Thread.currentThread().name)\n                Toast.makeText(this@MainActivity, \"åå°çº¿ç¨‹ç”¨æ—¶${used}ms\", Toast.LENGTH_SHORT).show()\n            }\n        }\n ```\n>åœ¨åç»­çš„å†…å®¹ä¸­ï¼Œæˆ‘å°†åœ¨å®ç°çš„è¿‡ç¨‹ä¸­é€æ­¥åˆ†ækotlinåç¨‹æœºåˆ¶çš„åŸºæœ¬åŸç†\n\né¦–å…ˆå£°æ˜ä¸€ä¸ªåˆ›å»ºåç¨‹çš„å‡½æ•°ï¼š\n```\n//è¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ª suspendç±»å‹çš„lambda\ninline fun runOnUI(noinline block: suspend () -> Unit) {\n    var continuation = object : Continuation<Unit> {\n      //ThreadSwitcheræ˜¯ContinuationInterceptorçš„å­ç±»ï¼Œç”¨äºåœ¨åç¨‹resumeæ—¶åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ‰§è¡Œ\n        override val context: CoroutineContext\n            get() = ThreadSwitcher()  \n\n        override inline fun resume(value: Unit) = Unit\n\n        override inline fun resumeWithException(exception: Throwable) = Unit\n    }\n        //ä½¿ç”¨suspendç±»å‹çš„lambdaåˆ›å»ºä¸€ä¸ªåç¨‹å¹¶å¯åŠ¨\n        block.createCoroutine(continuation).resume(Unit)\n}\n```\n`createCoroutine`æ˜¯å®˜æ–¹æä¾›çš„ä¸€ä¸ªåŸºç¡€apiï¼Œè¯¥å‡½æ•°å¦‚ä¸‹ï¼š\n```\npublic fun <T> (suspend () -> T).createCoroutine(\n        completion: Continuation<T>\n): Continuation<Unit> = SafeContinuation(createCoroutineUnchecked(completion), COROUTINE_SUSPENDED)\n```\nå¯ä»¥çœ‹åˆ°è°ƒç”¨äº†`createCoroutineUnchecked`åˆ›å»ºä¸€ä¸ª`Coroutine`ï¼Œç»§ç»­æŸ¥çœ‹è¯¥æ–¹æ³•ï¼š\n```\n@SinceKotlin(\"1.1\")\n@kotlin.jvm.JvmVersion\npublic fun <T> (suspend () -> T).createCoroutineUnchecked(\n        completion: Continuation<T>\n): Continuation<Unit> =\n//è¿™é‡Œçš„thisæ˜¯æ‰§è¡ŒcreateCoroutineå‡½æ•°çš„block\n        if (this !is kotlin.coroutines.experimental.jvm.internal.CoroutineImpl)\n            buildContinuationByInvokeCall(completion) {\n                @Suppress(\"UNCHECKED_CAST\")\n                (this as Function1<Continuation<T>, Any?>).invoke(completion)\n            }\n        else\n//ç¼–è¯‘æ—¶ï¼Œblockä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªCoroutineImplçš„å­ç±»ï¼Œæ‰€ä»¥èµ°è¿™ä¸ªåˆ†æ”¯\n            (this.create(completion) as kotlin.coroutines.experimental.jvm.internal.CoroutineImpl).facade\n```\næŸ¥çœ‹ç¼–è¯‘ä¹‹åç”Ÿæˆçš„`block`ï¼š\n```\n//æŸ¥çœ‹åœ¨Activity#onCreateè°ƒç”¨runOnUIå¤„ä¼ å…¥çš„lambdaçš„ç¼–è¯‘ç±»\nfinal class ymc/demo/com/asyncframe/MainActivity$onCreate$1$1 \n          extends kotlin/coroutines/experimental/jvm/internal/CoroutineImpl   \n          implements kotlin/jvm/functions/Function1  {      //lambdaç¼–è¯‘ç±»éƒ½å®ç°FunctionNå‡½æ•°\n  ...\n}\n```\nå¯ä»¥çœ‹åˆ°ä¼ å…¥`runOnUI`çš„`lambda`ç¡®å®è¢«ç¼–è¯‘æˆäº†ä¸€ä¸ª`CoroutineImpl`ï¼Œè¿™æ˜¯å› ä¸ºç¼–è¯‘å™¨æ¨æ–­å‡ºäº†è¿™ä¸ª`lambda`æ˜¯`suspend`ç±»å‹çš„ã€‚\n\nç»§ç»­ä¸Šé¢çš„åˆ†æï¼Œåˆ›å»ºåç¨‹æ‰€æ¶‰åŠåˆ°çš„ä¸¤ä¸ªæ–¹æ³•ä¸­éƒ½å‡ºç°äº† `Continuation`è¿™ä¸ªç±»ï¼Œé‚£ä¹ˆè¿™ä¸ªç±»æ˜¯å¹²å˜›çš„å‘¢ï¼Ÿ\né¦–å…ˆï¼Œå…ˆçœ‹çœ‹`completion`ï¼Œè¿™ä¸ªæ˜¯æˆ‘ä»¬è°ƒç”¨`createCoroutine`æ‰‹åŠ¨ä¼ å…¥çš„ï¼Œå½“åç¨‹ç»“æŸæ—¶ï¼Œä»–çš„`resume`ä¼šè¢«è°ƒç”¨ï¼Œå½“åç¨‹å¼‚å¸¸ç»“æŸæ—¶ï¼Œä»–çš„`resumeWithException`ä¼šè¢«è°ƒç”¨ã€‚\nå†çœ‹çœ‹`createCoroutineUnchecked`ï¼Œè¿™ä¸ªå‡½æ•°ä¹Ÿè¿”å›äº†ä¸€ä¸ª`Continuation`ï¼Œé‚£ä¹ˆè¿™ä¸ªåˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ\n```\n (this.create(completion) as kotlin.coroutines.experimental.jvm.internal.CoroutineImpl).facade\n```\nå¯ä»¥çœ‹åˆ°ï¼Œè¿”å›çš„æ˜¯`CoroutineImpl`çš„`facade`ï¼Œé‚£è¿™ä¸ªåˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ\næˆ‘ä»¬è¿›å…¥`CoroutineImpl`ï¼Œå¯ä»¥çœ‹åˆ°\n```\nabstract class CoroutineImpl(\n        arity: Int,\n        @JvmField\n        protected var completion: Continuation<Any?>?\n) : Lambda(arity), Continuation<Any?> {     //Coroutineæœ¬èº«æ˜¯ä¸€ä¸ªContinuation\n\n  override val context: CoroutineContext\n          get() = _context!!\n\n  private var _facade: Continuation<Any?>? = null\n \n  val facade: Continuation<Any?> get() {\n          if (_facade == null) _facade = interceptContinuationIfNeeded(_context!!, this)\n          return _facade!!\n      }\n  ...\n}\n```\nåŸæ¥è¿™æ˜¯ä¸€ä¸ªä»£ç†å±æ€§ï¼Œæ¥ç€æŸ¥çœ‹`interceptContinuationIfNeeded`ï¼Œ\n```\ninternal fun <T> interceptContinuationIfNeeded(\n        context: CoroutineContext,\n        continuation: Continuation<T>\n) = context[ContinuationInterceptor]?.interceptContinuation(continuation) ?: continuation\n```\nè¿™ä¸ªå‡½æ•°ä»`Coroutine`çš„ä¸Šä¸‹æ–‡ä¸­æŸ¥æ‰¾`ContinuationInterceptor`ï¼Œå¦‚æœæœ‰å°±è°ƒç”¨ä»–çš„`interceptContinuation`å¯¹ä¼ å…¥çš„`continuation`è¿›è¡ŒåŒ…è£…ï¼Œå¦åˆ™ç›´æ¥è¿”å›ä¼ å…¥çš„`continuation`\n\n**`Continuation`**æ˜¯ä¸€ä¸ªå¯**ç»§ç»­æ‰§è¡Œ**ä½“çš„æŠ½è±¡ï¼Œæ¯ä¸ª`Coroutine`éƒ½æ˜¯ä¸€ä¸ªå¯ç»§ç»­æ‰§è¡Œä½“ï¼Œ`Continuation`æ˜¯ä¸€ä¸ªåç¨‹å¯¹å¤–çš„æ¥å£ï¼Œå¯åŠ¨/æ¢å¤åç¨‹çš„`resume`å°±æ˜¯åœ¨è¯¥æ¥å£ä¸­å®šä¹‰çš„ã€‚\nåç¨‹å¯ä»¥æ˜¯é“¾å¼è¿æ¥çš„ï¼Œä¸€ä¸ªåç¨‹å¯ä»¥æœ‰å­åç¨‹ï¼Œå­åç¨‹æŒæœ‰çˆ¶åç¨‹çš„å¼•ç”¨ï¼Œå½“å­åç¨‹æ‰§è¡Œæ—¶ï¼Œçˆ¶åç¨‹æš‚åœï¼Œå­åç¨‹ç»“æŸæ—¶ï¼Œå†…éƒ¨é€šè¿‡è°ƒç”¨çˆ¶åç¨‹çš„`resume`è¿”å›çˆ¶åç¨‹ã€‚\n\nè¿˜è®°å¾—æˆ‘ä»¬å‰é¢ç”¨åˆ°çš„`ThreadSwitcher`å—ï¼Œä»–å°±æ˜¯ä¸€ä¸ª`ContinuationInterceptor`\næˆ‘ä»¬æ¥çœ‹çœ‹æ¥çœ‹`ThreadSwitcher`çš„å®ç°ï¼š\n```\n/**\nInterceptorç”¨äºç”¨äºæ‹¦æˆªå¹¶åŒ…è£…Continuationï¼Œè®©æˆ‘ä»¬æœ‰æœºä¼šåœ¨åç¨‹resumeå‰åšä¸€äº›é¢å¤–çš„æ“ä½œï¼Œæ¯”å¦‚çº¿ç¨‹åˆ‡æ¢\n**/\nclass ThreadSwitcher : ContinuationInterceptor, AbstractCoroutineContextElement(ContinuationInterceptor.Key) {\n\n    override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n            = object : Continuation<T> by continuation {\n\n        override fun resume(value: T) {\n          //å¦‚æœåœ¨ä¸»çº¿ç¨‹ï¼Œç›´æ¥æ‰§è¡Œ\n            if (Looper.getMainLooper() === Looper.myLooper()) {\n                continuation.resume(value)\n            } else {\n            //å¦åˆ™ï¼Œä½¿ç”¨handleræœºåˆ¶poståˆ°ä¸»çº¿ç¨‹æ‰§è¡Œ\n                postman.post {\n                    resume(value)\n                }\n            }\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            if (Looper.getMainLooper() === Looper.myLooper()) {\n                continuation.resumeWithException(exception)\n            } else {\n                postman.post {\n                    resumeWithException(exception)\n                }\n            }\n        }\n    }\n}\n```\nä»ä¸Šé¢çš„åˆ†æä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³è±¡ï¼Œæˆ‘ä»¬åˆ›å»ºçš„åç¨‹ä¼šè¢«`ThreadSwitcher`åŒ…è£…ï¼Œ\n```\nblock.createCoroutine(continuation).resume(Unit)\n```\n`createCoroutine`è¿”å›çš„å®é™…æ˜¯`ThreadSwitcher`è¿”å›çš„`Continuation`ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬æ‰§è¡Œ`resume`å¯åŠ¨åç¨‹æ—¶ï¼Œä¼šå…ˆåˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ‰§è¡Œã€‚\n\nç´§æ¥ç€ï¼Œæˆ‘ä»¬æ¥å®ç°`async`ï¼š\n```\nsuspend inline fun <T> async(crossinline block: () -> T): T\n        = suspendCoroutine {\n//dispatcheræ˜¯ä¸€ä¸ªå¯¹çº¿ç¨‹æ± çš„å°è£…ï¼Œå°†ä»»åŠ¡åˆ†å‘åˆ°å­çº¿ç¨‹ä¸­\n    dispatcher.dispatch {\n        it.resume(block())\n    }\n}\n```\nä½¿ç”¨`suspend`ä¿®é¥°çš„æ–¹æ³•åªå¯ä»¥åœ¨åç¨‹å†…éƒ¨è°ƒç”¨ï¼Œè€Œ`suspendCoroutine`æ–¹æ³•æ˜¯`kotlin`æä¾›çš„ä¸€ä¸ªåŸºç¡€api,ç”¨äºå®ç°æš‚åœåç¨‹ã€‚\næˆ‘ä»¬æ¥ç€æ¥åˆ†æ`suspendCoroutine`ï¼ŒæŸ¥çœ‹ä»–çš„å®ç°ï¼š\n```\npublic inline suspend fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T =\n        suspendCoroutineOrReturn { c: Continuation<T> ->\n            val safe = SafeContinuation(c)\n            block(safe)\n            safe.getResult()\n        }\n```\nå¯ä»¥çœ‹åˆ°è¿™ä¸ªæ–¹æ³•æ¥æ”¶çš„`block`æ˜¯å¸¦`Continuation`å‚æ•°çš„\nçœŸæ­£å®ç°åŠŸèƒ½çš„æ˜¯`suspendCoroutineOrReturn`ï¼Œå½“æˆ‘ä»¬ç»§ç»­è·Ÿè¿›æ—¶ï¼Œå‘ç°ï¼š\n```\npublic inline suspend fun <T> suspendCoroutineOrReturn(crossinline block: (Continuation<T>) -> Any?): T =\n        throw NotImplementedError(\"Implementation is intrinsic\")\n```\nwhat!ç›´æ¥æŠ›å‡ºå¼‚å¸¸äº†???\nè¿™æ˜¯å› ä¸ºè¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•°ï¼Œéœ€è¦ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†ï¼Œä»–éœ€è¦å°†å½“å‰åç¨‹å†…çš„`_facade`å±æ€§ï¼ŒåŒ…è£…æˆ`SafeContinuation`ï¼Œå†ä½œä¸ºæˆ‘ä»¬ä¼ å…¥çš„`block`çš„å‚æ•°ï¼Œè€Œä¸”è¿™ä¸ª`_facade`æ˜¯ç»è¿‡`ContinuationInterceptor`å¤„ç†è¿‡çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å½“æˆ‘ä»¬è°ƒç”¨`resume`æ¢å¤çº¿ç¨‹æ—¶ï¼Œä¼šå…ˆåˆ‡æ¢åˆ°ä¸»çº¿ç¨‹ã€‚\nä¸ºäº†éªŒè¯ä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬æŸ¥çœ‹`async`ç¼–è¯‘ä¹‹åçš„å­—èŠ‚ç ï¼š\n```\n//å¯ä»¥çœ‹åˆ°ç¼–è¯‘ä¹‹åï¼Œæˆ‘ä»¬çš„asyncå¤šäº†ä¸€ä¸ªContinuationç±»å‹çš„å‚æ•°\n private final static async(Lkotlin/jvm/functions/Function0;Lkotlin/coroutines/experimental/Continuation;)Ljava/lang/Object;\n   L0\n    LINENUMBER 70 L0\n    NOP\n   L1\n    LINENUMBER 77 L1\n    ICONST_0\n    INVOKESTATIC kotlin/jvm/internal/InlineMarker.mark (I)V\n    ALOAD 1  //å°†ç¬¬äºŒä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯Continuationå…¥æ ˆ\n//è°ƒç”¨CoroutineIntrinsics.normalizeContinuation \n    INVOKESTATIC kotlin/coroutines/experimental/jvm/internal/CoroutineIntrinsics.normalizeContinuation (Lkotlin/coroutines/experimental/Continuation;)Lkotlin/coroutines/experimental/Continuation;  \n//å°†è¿”å›å€¼å­˜åˆ°slot3\n    ASTORE 3\n   L2\n    LINENUMBER 78 L2\n//new ä¸€ä¸ªSafeContinuation\n    NEW kotlin/coroutines/experimental/SafeContinuation\n    DUP  \n  //å°†åˆšåˆšnormalizeContinuationè¿”å›çš„continuationä¼ å…¥SafeContinuationçš„æ„é€ å‡½æ•°\n    ALOAD 3\n    INVOKESPECIAL kotlin/coroutines/experimental/SafeContinuation.<init> (Lkotlin/coroutines/experimental/Continuation;)V\n    ASTORE 4\n   L3\n  ...\n```\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç¼–è¯‘ä¹‹åçš„å­—èŠ‚ç å·²ç»æ²¡æœ‰äº†`suspendCoroutine`å’Œ`suspendCoroutineOrReturn`çš„èº«å½±ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå‡½æ•°éƒ½æ˜¯`inline`å‡½æ•°ã€‚\næˆ‘ä»¬æ¥ç€æ¥çœ‹`CoroutineIntrinsics.normalizeContinuation`çš„å®ç°ï¼š\n```\nfun <T> normalizeContinuation(continuation: Continuation<T>): Continuation<T> =\n        (continuation as? CoroutineImpl)?.facade ?: continuation\n```\n è¿˜è®°å¾—æˆ‘ä»¬åˆšåˆšåˆ†æè¿‡`facade`è¿™ä¸ªå±æ€§å—ï¼Ÿä»–æ˜¯å¯¹`_facade`çš„ä»£ç†ï¼Œè¿™ä¸ªå‡½æ•°è¿”å›çš„æ˜¯ç»è¿‡æ‹¦æˆªå™¨å¤„ç†è¿‡çš„`Continuation`\næ ¹æ®åˆšåˆšçš„å­—èŠ‚ç ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°`suspend`ç±»å‹çš„å‡½æ•°ï¼Œéƒ½ä¼š**éšå¼**é¢å¤–æ¥å—ä¸€ä¸ªå½“å‰åç¨‹çš„å¼•ç”¨ï¼Œä½†æ˜¯åˆä¸èƒ½åœ¨å‡½æ•°ä¸­ç›´æ¥è®¿é—®ã€‚\n\næœ€åï¼Œè¿˜æœ‰ä¸¤ä¸ªä¸Šæ–‡å‡ºç°è¿‡çš„çº¿ç¨‹åˆ‡æ¢å¤„ç†ç±»ï¼Œ`postman`å’Œ`dispatcher`ï¼Œä½¿ç”¨çš„æ˜¯å•ä¾‹æ¨¡å¼ï¼š\n```\nobject postman : Handler(Looper.getMainLooper()) {\n    override fun handleMessage(msg: Message?) {\n        msg?.callback?.run()\n    }\n}\n\nobject dispatcher {\n    val mCachedThreads = Executors.newCachedThreadPool()\n    inline fun dispatch(noinline block: () -> Unit) {\n        mCachedThreads.execute(block)\n    }\n}\n```\nåˆ°æ­¤ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªç®€æ˜“çš„å¼‚æ­¥è°ƒç”¨åº“ï¼","tags":["kotlin","coroutine"]},{"title":"è‡ªå®šä¹‰classLoader","url":"/2017/10/19/è‡ªå®šä¹‰classLoader/","content":"\n\n\nåœ¨`java`ä¸­ï¼ŒåŠ è½½ä¸€ä¸ªç±»åˆ°`jvm`è™šæ‹Ÿæœºå¹¶ä¸ºå…¶å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡æ˜¯ç”±`ClassLoader`å®ç°çš„\næœ‰æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ç‰¹æ®Šçš„ç±»åŠ è½½æ–¹å¼ï¼Œå°±éœ€è¦è‡ªå·±å®ç°ä¸€ä¸ª`ClassLoader `\n`ClassLoader`ä¸­æœ‰å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„æ–¹æ³•ï¼š\n\n- `loadClass`ï¼š\n  è¯¥æ–¹æ³•å®ç°äº†åŒäº²å§”æ‰˜æœºåˆ¶ï¼Œä¸€èˆ¬ä¸ä¼šé‡å†™è¯¥æ–¹æ³•ï¼Œä»–çš„æ‰§è¡Œæ­¥éª¤æ˜¯å…ˆå§”æ‰˜çˆ¶åŠ è½½å™¨åŠ è½½ï¼Œå¦‚æœåŠ è½½ä¸åˆ°ï¼Œåœ¨æ‰§è¡Œè‡ªå·±çš„`findClass `åŠ è½½\n- `findClass`ï¼š\n  ä¸€èˆ¬å®ç°è‡ªå·±çš„`ClassLoader`éƒ½æ˜¯é‡å†™è¯¥æ–¹æ³•ï¼Œå¦‚æœæ–¹æ³•æ‰¾ä¸ç€ï¼Œåˆ™æŠ›å‡ºä¸€ä¸ª`ClassNotFound`å¼‚å¸¸\n- `defineClass`ï¼š\n  è¯¥æ–¹æ³•æ˜¯`jvm`æä¾›çš„ä¸€ä¸ªæ¥å£ï¼ŒéªŒè¯ä¸€ä¸ª`class`å­—èŠ‚ç æ•°ç»„ï¼Œå¹¶ä¸ºå…¶åˆ›å»ºä¸€ä¸ª`Class`å¯¹è±¡\n>ä¸‹é¢ç®€å•å®ç°ä¸€ä¸ª`ClassLoader`ï¼Œç”¨äºåŠ è½½æŒ‡å®šç›®å½•ä¸‹çš„`jar`åŒ…å†…çš„ç±»\n```java\npublic class JarsClassLoader extends ClassLoader {\n    private String basePath;  //jaråŒ…å­˜æ”¾çš„ç›®å½•\n\n    public JarsClassLoader(String path, ClassLoader parentClasss) {\n        super(parentClasss); //æŒ‡å®šçˆ¶åŠ è½½å™¨\n        basePath = path;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classByte = getClassByte(name); //æ ¹æ®ç±»çš„å…¨è·¯å¾„åå»è·å–ä¸€ä¸ªå­—èŠ‚ç æ•°ç»„\n        try {\n            return defineClass(name, classByte, 0, classByte.length);//ç”Ÿæˆä¸€ä¸ªclass\n        } catch (Exception e) {\n            throw new ClassNotFoundException(\"æ‰¾ä¸åˆ°ç±»ï¼š\"+name);\n        }\n    }\n    /**\n     * è¯¥æ–¹æ³•éå†basePathä¸‹çš„jaråŒ…ï¼ŒæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨æŒ‡å®šçš„ç±»æ–‡ä»¶\n    **/\n    private byte[] getClassByte(String className) {\n        try {\n            File baseDir = new File(basePath); \n            File[] childrens = baseDir.listFiles();\n            for (File child : childrens) {\n                if (!child.getName().endsWith(\".jar\"))\n                    continue;\n                //jaråŒ…çš„å…¨è·¯å¾„å\n                String jarName = basePath + File.separator + child.getName();\n                //åˆ›å»ºä¸€ä¸ªZipæ–‡ä»¶å¯¹è±¡\n                ZipFile zip = new ZipFile(jarName);\n                //éå†Zipå†…çš„æ‰€æœ‰å®ä½“é¡¹\n                Enumeration<ZipEntry> zipEntries = (Enumeration<ZipEntry>) zip.entries();\n                ZipEntry zn;\n                while (zipEntries.hasMoreElements()) {\n                    zn = zipEntries.nextElement();\n                    if (!zn.getName().endsWith(\".class\"))\n                        continue;\n                    //å¤„ç†å®ä½“åï¼Œå°†`/`æ›¿æ¢æˆ`.`ï¼Œå¹¶å»é™¤`.class`åç¼€\n                    String znName =\n                            zn.getName().replace(\"/\", \".\").replace(\".class\", \"\");\n                    //å¦‚æœæ‰¾åˆ°æŒ‡å®šçš„ç±»æ–‡ä»¶\n                    if (znName.equals(className)) {\n                        BufferedInputStream bis = new BufferedInputStream(zip.getInputStream(zn));\n                        ByteArrayOutputStream bos = new ByteArrayOutputStream((int) zn.getSize());\n                        byte[] bytes = new byte[1024];\n                        int cnt;\n                        while ((cnt = (bis.read(bytes, 0, bytes.length))) > 0) {\n                             bos.write(bytes, 0, cnt);\n                        }\n                        return bos.toByteArray();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n        return null;\n    }\n}\n```","tags":["java","classloader"]},{"title":"kotlinä¸­çš„objectæ›´åƒæ˜¯è¯­æ³•ç³–","url":"/2017/06/10/kotlinä¸­çš„objectæ›´åƒæ˜¯è¯­æ³•ç³–/","content":"\n\n\n### å•ä¾‹å£°æ˜\n\n\n\nkotlinä¸­ï¼Œå£°æ˜ä¸€ä¸ªå•ä¾‹çš„è¯­æ³•å¾ˆç®€å•ï¼š\n```\nobject obj\n```\næˆ‘ä»¬ä½¿ç”¨`object`å…³é”®å­—æ›¿ä»£`class`å…³é”®å­—å°±å¯ä»¥å£°æ˜ä¸€ä¸ªå•ä¾‹å¯¹è±¡\n`object`ä¸€æ ·å¯ä»¥ç»§æ‰¿å…¶ä»–ç±»ï¼Œæˆ–è€…å®ç°å…¶ä»–æ¥å£ï¼š\n```kotlin\ninterface IObj\nabstract class AbstractObj\nobject obj : AbstractObj(),IObj  \n```\nåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è®©`obj`è¿™ä¸ªå•ä¾‹ç»§æ‰¿äº†`AbstractObj`ï¼Œå¹¶ä¸”å®ç°äº†`IObj`æ¥å£\nå£°æ˜ä¸€ä¸ªå•ä¾‹å¯¹è±¡ï¼Œå’Œå£°æ˜ä¸€ä¸ª`class`å¾ˆç±»ä¼¼\nä½†æ˜¯ï¼Œ`object`å£°æ˜çš„å•ä¾‹å¯¹è±¡**ä¸èƒ½å£°æ˜æ„é€ å‡½æ•°**ï¼Œå› ä¸ºå•ä¾‹å¯¹è±¡åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨å°†å®ƒåˆ›å»ºå‡ºæ¥ï¼Œå› æ­¤è‡ªç„¶ä¸éœ€è¦æ„é€ å‡½æ•°ã€‚\n> å¦‚æœéœ€è¦å¯¹å•ä¾‹å¯¹è±¡åšåˆå§‹åŒ–æ“ä½œï¼Œå¯ä»¥åœ¨`init`åˆå§‹åŒ–å—å†…è¿›è¡Œ\n\né‚£ä¹ˆ`object`æ˜¯ä»€ä¹ˆæ—¶å€™è¢«åˆ›å»ºçš„å‘¢ï¼Ÿ\n>å®˜æ–¹æ–‡æ¡£çš„è§£é‡Šæ˜¯ï¼Œ`object`æ˜¯`lazy-init`ï¼Œå³åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶è¢«åˆ›é€ å‡ºæ¥çš„\n\n`object`å•ä¾‹åŸºæœ¬çš„ä½¿ç”¨å°±åƒä¸Šé¢è¿™æ ·äº†ï¼ŒåŸºæœ¬çš„ç”¨æ³•å‚ç…§å®˜æ–¹çš„æ–‡æ¡£è¯´æ˜å°±å¥½äº†\n\n### å®ç°\n\nåœ¨javaä¸­ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨ä¸€ä¸ªå•ä¾‹æ¨¡å¼æ—¶ï¼Œä¸€èˆ¬ä½¿ç”¨åŒé‡æ£€æŸ¥é”ï¼š\n\n```java\npublic class Obj {\n      private Obj(){}\n      private static volatile Obj INSTANCE;\t\t//volatileé˜²æ­¢æŒ‡ä»¤é‡æ’\n      public static Obj getObj(){\n          if(INSTANCE==null){\n              synchronized(Obj.class){\n                  if (INSTANCE==null){\n                      INSTANCE=new Obj();\n                  }\n              }\n          }\n          return INSTANCE;\n      }\n}\n```\nè€Œç›¸åŒçš„åŠŸèƒ½ï¼Œåœ¨kotlinåªè¦`object Obj`å°±æå®šäº†ï¼Œè¿™æ ·çš„é»‘é­”æ³•æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ\nä¸ºäº†æ¢ç©¶ä¸€äºŒï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ç¼–è¯‘ä¹‹åçš„å­—èŠ‚ç :\n\n```kotlin\n//æºä»£ç :\nobject Obj{\n    init{\n        println(\"object init...\")\n    }\n}\n```\n```java\n//å¯¹åº”çš„å­—èŠ‚ç ï¼š\npublic final class Obj {   //å¯ä»¥çœ‹åˆ°ç”Ÿæˆäº†ä¸€ä¸ªclassï¼Œè€Œç±»åå°±æ˜¯object name\n  // access flags 0x2\n  private <init>()V     //æ³¨æ„çœ‹ï¼Œ<init>çš„å¯è§æ€§æ˜¯`private`\n   L0\n    LINENUMBER 8 L0\n    ALOAD 0  //å°†å±€éƒ¨å˜é‡è¡¨slot 0å¤„çš„å¼•ç”¨å…¥æ ˆï¼Œå³thiså¼•ç”¨\n    INVOKESPECIAL java/lang/Object.<init> ()V   //è°ƒç”¨çˆ¶ç±»çš„<init>\n    ALOAD 0  //å’Œä¸Šé¢ä¸€æ ·ï¼Œå°†å±€éƒ¨å˜é‡è¡¨slot 0å¤„çš„å¼•ç”¨å…¥æ ˆï¼Œå³thiså¼•ç”¨\n    CHECKCAST Obj    //ç±»å‹æ£€æŸ¥\n    PUTSTATIC Obj.INSTANCE : LObj;     //ä¿å­˜thiså¼•ç”¨åˆ°`INSTANCE`è¿™ä¸ªé™æ€åŸŸ\n   L1\n    LINENUMBER 10 L1\n    LDC \"object init...\"    //ä»å¸¸é‡æ± å°†å­—ç¬¦ä¸²å¼•ç”¨é€è‡³æ ˆé¡¶\n    ASTORE 1    //å°†æ ˆé¡¶çš„å¼•ç”¨ä¿å­˜åˆ°å±€éƒ¨éå†è¡¨ç¬¬ä¸€ä¸ªslotå¤„\n   L2\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    //è·å–outå®ä¾‹\n    ALOAD 1    //ä»å±€éƒ¨å˜é‡è¡¨ç¬¬ä¸€ä¸ªslotå¤„åŠ è½½å¼•ç”¨åˆ°æ ˆé¡¶\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V   //è¾“å‡º\n   L3\n   L4\n   L5\n    RETURN  //è¿”å›\n   L6\n    LOCALVARIABLE this LObj; L0 L6 0\n    MAXSTACK = 2    //æ“ä½œæ•°æ ˆæ·±åº¦ä¸º2\n    MAXLOCALS = 2    //å±€éƒ¨å˜é‡è¡¨ä¸º2ä¸ªslot\n  // access flags 0x19\n  public final static LObj; INSTANCE    //**é™æ€åŸŸ**ï¼Œç±»å‹ä¸ºObj\n  // access flags 0x8\n  static <clinit>()V    //é™æ€åˆå§‹åŒ–å—ï¼Œç±»åˆå§‹åŒ–æ—¶æ‰§è¡Œ\n   L0\n    LINENUMBER 8 L0\n    NEW Obj     //åˆ›å»ºä¸€ä¸ªObjå®ä¾‹ï¼Œå¼•ç”¨ä¿å­˜åœ¨æ ˆé¡¶\n    INVOKESPECIAL Obj.<init> ()V   //è°ƒç”¨å…¶<init>ï¼Œåˆå§‹åŒ–å¯¹è±¡ï¼Œæ­¤æ—¶ä¼šæŠŠæ ˆé¡¶å¼•ç”¨ä½œä¸ºthiså¼•ç”¨ä¼ å…¥\n    RETURN\n    MAXSTACK = 1\n    MAXLOCALS = 0\n}\n```\nä»ä¸Šé¢çš„å­—èŠ‚ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå£°æ˜ä¸€ä¸ª`object`ï¼Œå®é™…ä¸Šå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ª`class`ï¼Œåœ¨ç±»é™æ€åˆå§‹åŒ–æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ªè¯¥ç±»çš„å®ä¾‹ï¼Œä¿å­˜åˆ°å…¶é™æ€åŸŸ`INSTANCE`ä¸­\nè¿›è€Œå¯ä»¥çŒœæƒ³ï¼Œæºç ä¸­å¯¹å•ä¾‹çš„å¼•ç”¨ä¼šè¢«ç¼–è¯‘å™¨æ›¿æ¢ä¸ºå¯¹`INSTANCE`è¿™ä¸ªé™æ€åŸŸçš„å¼•ç”¨\nä¸ºäº†éªŒè¯æˆ‘ä»¬çš„åˆ†æï¼Œç°åœ¨æ¥çœ‹çœ‹ä½¿ç”¨å•ä¾‹æ—¶ï¼Œå¯¹åº”çš„å­—èŠ‚ç \n```kotlin\næºç ï¼š\nfun main(args:Array<String>){\n    Obj is Any\n}\n```\n```\nå¯¹åº”çš„å­—èŠ‚ç ï¼š\npublic final static main([Ljava/lang/String;)V\n    @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0\n   L0\n    ALOAD 0\n    LDC \"args\"\n    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V\n   L1\n    LINENUMBER 5 L1\n    GETSTATIC Obj.INSTANCE : LObj;    //è·å–Objçš„é™æ€åŸŸ`INSTANCE`\n    INSTANCEOF java/lang/Object        //åˆ¤æ–­æ˜¯å¦æ˜¯`Object`ç±»å‹\n    POP\n   L2\n    LINENUMBER 6 L2\n    RETURN\n   L3\n    LOCALVARIABLE args [Ljava/lang/String; L0 L3 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n```\n\nå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åœ¨æºç ä¸­ç›´æ¥ä½¿ç”¨`object name`è®¿é—®å•ä¾‹å¯¹è±¡ï¼Œè€Œç¼–è¯‘å™¨å¸®æˆ‘ä»¬åšäº†ç¿»è¯‘ï¼Œå®é™…ä½¿ç”¨çš„æ˜¯å†…éƒ¨çš„é™æ€åŸŸ`INSTANCE`\nè€Œä¸”ï¼Œä»å¯¹ä¸Šé¢`Obj`è¿™ä¸ªç”Ÿæˆçš„ç±»çš„åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œ`object`åœ¨javaä¸­çš„å¯¹åº”çš„å®ç°æ˜¯ç±»å‹è¿™æ ·çš„ï¼š\n\n```java\npublic class  Obj {\n    private Obj(){}\n    private static Obj INSTANCE=null;\n    static {\n        INSTANCE=new Obj();\n    }\n}\n```\nè¿™æ˜¯æœ€ç®€å•çš„å•ä¾‹å®ç°æ–¹æ³•ï¼Œåœ¨ç±»åŠ è½½å™¨åŠ è½½classåæ‰§è¡Œé™æ€åˆå§‹åŒ–æ—¶å°±åˆ›å»ºå•ä¾‹å¯¹è±¡ã€‚\n\nè€Œ`object`å•ä¾‹åˆå§‹åŒ–çš„æ—¶æœºï¼Œå‡†ç¡®æ¥è¯´ï¼Œåº”è¯¥æ˜¯è¿™ä¸ªç±»è¢«åŠ è½½æ—¶ï¼Œé™æ€åˆå§‹åŒ–çš„æ—¶å€™ã€‚\nåšä¸ªå°å®éªŒï¼š\n\n```kotlin\nobject Obj{\n    init{\n        println(\"object init...\")\n    }\n}\n```\n```kotlin\nfun main(args:Array<String>){\n         Class.forName(\"Obj\")\n    }\n```\n>æ§åˆ¶å°è¾“å‡ºï¼šobject init...\n\nå¯è§ï¼Œå½“æˆ‘ä»¬åŠ è½½è¿™ä¸ªç±»çš„æ—¶å€™ï¼Œå•ä¾‹å°±è¢«åˆ›å»ºäº†ã€‚\nè€Œå•ä¾‹åå°±æ˜¯ç±»åã€‚\n\né‚£ä¹ˆï¼Œ`object`çœŸçš„å°±æ˜¯å•ä¾‹å—ï¼Ÿ\nä¸€èˆ¬æƒ…å†µä¸‹æ˜¯çš„ï¼Œå› ä¸ºå­—èŠ‚ç ä¸­`<init>`æ–¹æ³•è¢«å£°æ˜ä¸º`private`ï¼Œè™½ç„¶ä¸å¤ªå‡†ç¡®ä½†æ˜¯æˆ‘ä»¬å¯ä»¥è®¤ä¸ºå¯¹åº”äº†ç±»çš„ä¸€ä¸ª`private`çš„æ— å‚æ„é€ å‡½æ•°ï¼Œè¿™å°±ä½¿å¾—æˆ‘ä»¬æ— æ³•åˆ›å»ºå‡ºä¸€ä¸ªæ–°çš„å¯¹è±¡å‡ºæ¥ã€‚\nä½†æ˜¯ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥ä½¿ç”¨åå°„æœºåˆ¶ï¼Œä»ä¸€ä¸ª`private`çš„æ„é€ å‡½æ•°ä¸­åˆ›å»ºä¸€ä¸ªå¯¹è±¡å‡ºæ¥ï¼š\n```kotlin\nfun main(args:Array<String>){\n    println(Obj)\n    var clazz=Class.forName(\"Obj\")\n    var constrouctor=clazz.getDeclaredConstructor()\n    constrouctor.setAccessible(true)\n    var instance=constrouctor.newInstance()\n    constrouctor.setAccessible(false)\n    println(instance)\n}\nè¾“å‡ºï¼š\nobject init...\nObj@511d50c0\nobject init...\nObj@60e53b93\n```\nå¯è§ï¼Œä¸¤æ¬¡è¾“å‡ºçš„å¯¹è±¡å¼•ç”¨æ˜¯ä¸ä¸€æ ·çš„ã€‚\n\né‚£ä¹ˆï¼Œè¿™å°±è¯´æ˜kotlinçš„å•ä¾‹æ˜¯ä¸å®‰å…¨çš„å—ï¼Ÿè¿™åˆ°æœªå¿…\næˆ‘ä»¬åœ¨åŸå…ˆçš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šå‡ ä¸ªå±æ€§å£°æ˜ï¼š\n```\nobject Obj{\n    var name=\"name\"\n    var age=\"10\"\n    init{\n        println(\"object init...\")\n    }\n}\n```\nè§‚å¯Ÿå¯¹åº”çš„å­—èŠ‚ç ï¼š\n```\npublic final class Obj {\n  private static Ljava/lang/String; name\n   ...\n  private static Ljava/lang/String; age\n  ....\n  public final static LObj; INSTANCE\n  ...  \n}\n```\nå¯ä»¥çœ‹åˆ°ï¼Œè¿™äº›å±æ€§çš„`field`éƒ½è¢«å£°æ˜ä¸º`static`äº†ï¼Œå°½ç®¡å¯ä»¥é€šè¿‡åå°„æ‰‹æ®µåˆ›å»ºå¤šä¸ª`object`çš„å®ä¾‹ï¼Œä½†æ˜¯å®ƒä»¬çš„çŠ¶æ€éƒ½æ˜¯å…±äº«çš„\næ€»ç»“ï¼š\n\n- `object`å®é™…ä¸Šè¿˜æ˜¯ç”Ÿæˆä¸€ä¸ª`class`ï¼Œä½†æ˜¯è¿™ä¸ª`class`åœ¨`kotlin`ä¸­æ˜¯é€æ˜çš„ï¼Œæ— æ³•ç›´æ¥è®¿é—®ï¼Œæ¯”å¦‚`Obj.INSTANCE`åœ¨kotlinä¸­æ˜¯ä¸å…è®¸çš„ï¼Œåªèƒ½é€šè¿‡`Obj`æ¥å¼•ç”¨è¿™ä¸ªå•ä¾‹\n- `object name`æœ¬è´¨ä¸Šæ˜¯ç±»åï¼Œåªæ˜¯ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶è‡ªåŠ¨å°†`object name`æ¢æˆäº† `object`çš„`INSTANCE`\n- `object`æ›´åƒæ˜¯è¯­æ³•ç³–","tags":["kotlin"]},{"title":"kotlinä¹‹ä»£ç†å±æ€§","url":"/2017/05/16/kotlinä¹‹ä»£ç†å±æ€§/","content":"\n### å±æ€§ä»£ç†\n\n##### å§”æ‰˜ç±»\n\nå§”æ‰˜ç±»å¯ä»¥è‡ªå·±å®šä¹‰ï¼Œå¿…é¡»æä¾›`getValue`ï¼Œå¦‚æœç”¨äºä»£ç†varå±æ€§ï¼Œè¿˜å¿…é¡»æä¾›`setValue` \n\n```kotlin\nclass Delegate {\n  \t/**\n     * @param thisRef è¢«ä»£ç†ç±»å®ä¾‹\n     * @param property è¢«ä»£ç†å±æ€§\n     */\n    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {\n        return \"$thisRef, thank you for delegating '${property.name}' to me!\"\n    } \n    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {\n        println(\"$value has been assigned to '${property.name} in $thisRef.'\")\n    }\n}\n```\n\n##### ä½¿ç”¨\n\nå…·ä½“çš„ä½¿ç”¨æ–¹æ³•ï¼š\n\n```\nvar å˜é‡å:type by å§”æ‰˜å¯¹è±¡\nval å˜é‡å:type by å§”æ‰˜å¯¹è±¡\n```\n\nä½¿ç”¨ä»£ç†å±æ€§ç¦æ­¢è‡ªå®šä¹‰setterå’Œgetterï¼Œä»£ç†çš„æœ¬è´¨å°±æ˜¯å°†setterå’Œgetterå§”æ‰˜ç»™å…¶ä»–å¯¹è±¡\n\nkotlinæä¾›äº†å‡ ä¸ªæ ‡å‡†çš„ä»£ç†å·¥å‚æ–¹æ³•ï¼š\n\n- æ‡’åŠ è½½ï¼š **the value gets computed only upon first access** \n\n```kotlin\n//é€šè¿‡ä½¿ç”¨å·¥å‚æ–¹æ³•lazy()è·å¾—Lazy<T>å®ä¾‹\nfun main(args:Array<String>){\n\t//lazyæ²¡æœ‰æä¾›setterï¼Œæ‰€ä»¥ä½¿ç”¨lazyä»£ç†çš„å±æ€§å¿…é¡»ä¸ºval\n    val str:String by lazy{  //Lazy<T>æ‡’åŠ è½½ï¼Œåªä¼šåœ¨ç¬¬ä¸€æ¬¡æ—¶æ‰§è¡Œ\n        println(\"lazy\")\n        \"hello\"\n    }\n    println(str)\n    println(str)\n}\n```\n\n- observable properties: **listeners get notified about changes to this property** \n\n```kotlin\nfun main(args:Array<String>){\n    var p=Person()\n    println(p.name)\n    p.name=\"Jim\"\n    println(p.name)\n}\n\nclass Person{\n    var name by Delegates.observable(\"no-name\"){  //setæ—¶è¢«è°ƒç”¨\n        prop,old,new->\n        println(\"$prop($old->$new)\")\n    }\n}\n```\n\n- **storing properties in a map, not in separate field each **\n\n```kotlin\nfun main(args:Array<String>){\n    var p=Person(mutableMapOf(\"name\" to \"Tim\",\"age\" to 10))\n    println(p.name)\n    println(p.age)\n\n}\n\nclass Person(map:MutableMap<String,Any?>){\n    var name:String by map\n    var age:Int by map\n}\n```\n\n##### å·¥ä½œåŸç†\n\n```kotlin\nclass C {\n    var prop: Type by MyDelegate()\n} \n// this code is generated by the compiler\n// when the 'provideDelegate' function is available:\nclass C {\n    // calling \"provideDelegate\" to create the additional \"delegate\" property\n    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)\n    val prop: Type\n        get() = prop$delegate.getValue(this, this::prop)\n}\n```\n\nkotlin 1.1ä¹‹åï¼Œä»£ç†å±æ€§å¯ä»¥ç”¨äºlocal-properties\n\n\n\n### æ–¹æ³•ä»£ç†\n\n```kotlin\nfun main(args:Array<String>){\n    var b=B(AImpl())\n    b.echo()\n}\n\ninterface A{\n    fun echo()\n}\n\nclass AImpl:A{\n    override fun echo(){\n        println(\"a implemention of A\")\n    }\n}\nclass B(impl:AImpl):A by impl  //implæä¾›Bçš„æ¥å£æ–¹æ³•\n```\næ–¹æ³•ä»£ç†çš„å®ç°åŸç†å°±æ˜¯ç¼–è¯‘æ—¶ï¼Œè‡ªåŠ¨ä¸ºBç”Ÿæˆechoæ–¹æ³•çš„å®ç°ï¼Œå¹¶åœ¨è¯¥æ–¹æ³•ä¸­è°ƒç”¨implçš„echoæ–¹æ³•ï¼Œå› æ­¤Bå®ä¾‹ä¼šæŒæœ‰implçš„å¼•ç”¨","tags":["kotlin"]},{"title":"ä½¿ç”¨kotlinå†™è‡ªå·±çš„dsl","url":"/2017/04/25/ä½¿ç”¨kotlinå†™è‡ªå·±çš„dsl/","content":"\n\n\nç›¸æ¯”äºjavaï¼Œkotlinå¯¹**FP**æ›´åŠ å‹å¥½ï¼Œæ”¯æŒæ‰©å±•å‡½æ•°å’Œæ“ä½œç¬¦é‡è½½ï¼Œè¿™å°±ä¸ºå®šä¹‰dslæä¾›äº†æ”¯æŒã€‚\nä»€ä¹ˆæ˜¯dslå‘¢ï¼Ÿå°±æ˜¯ä¸€ç§é¢å‘ç‰¹å®šé—®é¢˜çš„è¯­è¨€ã€‚gradleå°±æ˜¯æ˜¯ä¸€ç§ç”¨groovyå®šä¹‰çš„dslã€‚è€Œkotlinä¸€æ ·å¯¹å®šä¹‰dslæä¾›äº†å‹å¥½çš„æ”¯æŒã€‚\næœ¬ç¯‡æ–‡ç« å°±æ¥å®šä¹‰ä¸€ä¸ªç®€å•ç”¨äºé…ç½®hibernateæ¡†æ¶çš„dslï¼Œå†™èµ·æ¥å°±åƒï¼š\n\n```kotlin\nvar conf= buildConfiguration{\n                connection {\n                    username = \"***\"\n                    password = \"******\"\n                    url = \"jdbc:mysql://localhost:3306/******\"\n                    driver = Driver::class.java\n                }\n                c3p0 {\n                    max_size = 30\n                    min_size = 10\n                    timeout=5000\n                    max_statements=100\n                    idle_test_period=300\n                    acquire_increment=2\n                    validate=true\n                }\n                entity {\n                    mapping = Client::class.java\n                    mapping = Financial_account::class.java\n                    mapping = FundHolding::class.java\n                    mapping=Fund::class.java\n                }\n                dialect=\"org.hibernate.dialect.MySQL5InnoDBDialect\"\n            }\n```\n\nä¸Šé¢æ˜¯ä¸€ä¸ªå¯¹hibernateçš„ç®€å•é…ç½®ï¼Œæœ€åè·å–ä¸€ä¸ªconfigurationå®ä¾‹ã€‚é€šè¿‡ä½¿ç”¨dslï¼Œå¯ä»¥é¿å…åœ¨è¿è¡Œæ—¶è§£æxmlæ–‡ä»¶ï¼ŒåŒæ—¶åˆæ¯”ä½¿ç”¨javaä»£ç é…ç½®ç®€æ´ï¼Œå…¼å…·xmlçš„ç»“æ„åŒ–å’Œjavaçš„é«˜æ•ˆã€‚\né‚£ä¹ˆï¼Œè¿™æ ·ä¸€ä¸ªdslæ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿ\n\n> å…ˆä»‹ç»ä¸€ä¸‹é¢„å¤‡çŸ¥è¯†ï¼š\n> æ‰©å±•å‡½æ•°ï¼š\n```kotlin\nfun Type.foo():Unit{\n  ...\n}\n```\nè¿™æ ·å°±ä¸º`Type`å¯¹è±¡åˆ›å»ºäº†ä¸€ä¸ªæ‰©å±•å‡½æ•°ï¼Œå‡å¦‚`t`æ˜¯`Type`çš„ä¸€ä¸ªå®ä¾‹ï¼Œå°±å¯ä»¥ï¼š\n```t.foo()```\n`Type`ç§°ä½œ`reciver`ï¼Œè€Œåœ¨`foo`å‡½æ•°ä½“å†…ï¼Œå¯ä»¥ä½¿ç”¨`this`è®¿é—®å…¶`public`æˆå‘˜ï¼Œç”šè‡³å¯ä»¥çœç•¥`this`ï¼Œä»¿ä½›`foo`å‡½æ•°æ˜¯å®šä¹‰åœ¨`class Type`å†…\nè€Œå£°æ˜ä¸€ä¸ªå‡½æ•°çš„å‚æ•°æ˜¯æ‰©å±•å‡½æ•°ï¼Œä¸€èˆ¬çš„è¯­æ³•ï¼š\n`fun funName(block:Type.(params...)->ReturnType):ReturnType{...}`\nå…³äºæ‰©å±•å‡½æ•°æ›´å¤šçš„ç”¨æ³•ï¼Œå¯ä»¥å‚è€ƒå®˜æ–¹çš„æ–‡æ¡£\n\né¦–å…ˆå…ˆå£°æ˜ä¸€ä¸ªæ–¹æ³•ï¼š\n```kotlin\nfun buildConfiguration(block:ConfigurationBuilder.()->Unit):Configuration{\n    var cfg=ConfigurationBuilder()\n    cfg.block()\n    return cfg.cfg\n} \n```\nè¿™ä¸ªæ–¹æ³•æ¥æ”¶ä¸€ä¸ªæœ‰receiverçš„lambdaè¡¨è¾¾å¼ï¼Œå› ä¸ºè¿™æ ·åœ¨blockçš„å†…éƒ¨å°±å¯ä»¥ç›´æ¥è®¿é—®receiverçš„å…¬å…±æˆå‘˜äº†ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦\nç´§æ¥ç€å¯¹è¿™ä¸ªConfigurationè¿™ä¸ªç±»è¿›è¡Œå®šä¹‰\n```kotlin\nclass ConfigurationBuilder{\n     val TAG=\"hibernate\"\n     val cfg=Configuration()\n     var dialect:String? get() = null\n        set(value){\n            cfg.setProperty(\"$TAG.dialect\",value!!)\n        }\n     inline fun connection(block:ConnectionBuilder.()->Unit)=ConnectionBuilder(cfg).block()\n     inline fun c3p0(block:C3p0Builder.()->Unit)=C3p0Builder(cfg).block()\n     inline fun entity(block:Entity.()->Unit)=Entity(cfg).block()\n}\n```\n\nåœ¨é‡Œé¢æˆ‘å®šä¹‰äº†ä¸‰ä¸ªæˆå‘˜å‡½æ•°ï¼Œåˆ†åˆ«å¯¹åº”å‰é¢ç¤ºä¾‹ä¸­çš„\n```kotlin\nvar conf= buildConfiguration{\n                connection {\n                    ...\n                }\n                c3p0 {\n                    ...\n                }\n                entity {\n                    ...\n                }\n               ...\n            }\n```\n\nåœ¨è¿™ä¸ªlambdaé‡Œé¢ï¼Œæˆ‘å°±ç›´æ¥è°ƒç”¨äº†buildConfigurationçš„æˆå‘˜å‡½æ•°ï¼Œé‚£ä¹ˆå¯¹è±¡å¼•ç”¨å‘¢ï¼Ÿè¿˜è®°å¾—æˆ‘å‰é¢è¯´è¿‡çš„å—ï¼ŸbuildConfigurationè¿™ä¸ªæ–¹æ³•çš„å‚æ•°æ˜¯ä¸€ä¸ªæœ‰receiverçš„lambdaï¼Œè€Œåœ¨buildConfigurationä¸­å£°æ˜äº†ä¸€ä¸ªConfigurationBuilderå¯¹è±¡å¹¶é€šè¿‡è¿™ä¸ªå¯¹è±¡è°ƒç”¨äº†è¿™ä¸ªlambdaã€‚é‚£ä¹ˆè¿™ä¸ªlambdaå°±ä¼šåœ¨è¿™ä¸ªå¯¹è±¡çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®¿é—®å®ƒçš„å…¬å…±æˆå‘˜ï¼Œç”šè‡³å¯ä»¥ä½¿ç”¨thiså¼•ç”¨è¿™ä¸ªå¯¹è±¡ã€‚\nåç»­çš„æ­¥éª¤éƒ½å·®ä¸å¤š,æˆ‘è¿™é‡Œä¸ºäº†çœäº‹ç›´æ¥å°±å£°æ˜äº†ä¸€ä¸ªConfigurationå¯¹è±¡ï¼Œå¹¶ä¼ åˆ°äº†å…¶ä»–å¯¹è±¡é‡Œé¢\nåé¢çš„æºç \n```kotlin\nclass ConnectionBuilder(val cfg:Configuration){//ç›´æ¥æ¥å—äº†ä¸€ä¸ªconfigurationå¯¹è±¡\n     val TAG=\"hibernate.connection\"\n     var username:String? get() = null  //é‡å†™äº†setterå’Œgetterï¼Œé˜²æ­¢å±æ€§æœ‰field\n        set(name){\n            cfg.setProperty(\"$TAG.username\",name!!)  //ç›´æ¥ç¡¬ç¼–ç è®¾ç½®å±æ€§\n        }\n     var password:String?  get() = null\n        set(password) {\n            cfg.setProperty(\"$TAG.password\", password!!)\n        }\n      var url:String? get() = null\n        set(url){\n            cfg.setProperty(\"$TAG.url\",url!!)\n        }\n      var driver:Class<*>? get() = null\n        set(driver){\n            cfg.setProperty(\"$TAG.driver_class\",driver!!.name)\n        }\n      var pool_size:Int? get() = null\n        set(size){\n            cfg.setProperty(\"$TAG.pool_size\",size!!.toString())\n        }\n}\n//åé¢çš„éƒ½å·®ä¸å¤šã€‚ã€‚ã€‚\n class C3p0Builder(val cfg:Configuration){\n     val TAG=\"hibernate.c3p0\"\n     var max_size:Int? get() = null\n        set(max_size){\n            cfg.setProperty(\"$TAG.max_size\",max_size!!.toString())\n        }\n     var min_size:Int? get() = null\n        set(min_size){\n            cfg.setProperty(\"$TAG.min_size\",min_size!!.toString())\n        }\n     var timeout:Int? get() = null\n        set(timeout){\n            cfg.setProperty(\"$TAG.timeout\",timeout!!.toString())\n        }\n     var max_statements:Int? get() = null\n        set(max_stmt){\n            cfg.setProperty(\"$TAG.max_statements\",max_stmt!!.toString())\n        }\n     var idle_test_period:Int? get() = null\n        set(idle_test_period){\n            cfg.setProperty(\"$TAG.idle_test_period\",idle_test_period!!.toString())\n        }\n     var acquire_increment:Int? get() = null\n        set(acquire){\n            cfg.setProperty(\"$TAG.acquire_increment\",acquire!!.toString())\n        }\n     var validate:Boolean? get() = null\n        set(validate){\n            cfg.setProperty(\"$TAG.validate\",validate!!.toString())\n        }\n}\n class Entity(val cfg:Configuration){\n     var mapping:Class<*>?\n        get()=null\n        set(clazz){\n            cfg.addAnnotatedClass(clazz!!)\n        }\n}\n```\n\nè‡³æ­¤ï¼Œä¸€ä¸ªç®€å•çš„dslå°±å®Œæˆäº†\næ€»ä½“æ¥è¯´ï¼Œå®šä¹‰ä¸€ä¸ªdslçš„è¿‡ç¨‹åŸºæœ¬æ˜¯ä¸€ä¸ªé€’å½’ä¸‹å»çš„è¿‡ç¨‹ï¼Œæ¯ä¸ªæ­¥éª¤éƒ½å¾ˆç±»ä¼¼","tags":["kotlin","dsl"]}]