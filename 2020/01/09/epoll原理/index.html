<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        epoll实现探究 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i> blog </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO多路复用"><span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll实现"><span class="toc-text">epoll实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll的结构以及创建"><span class="toc-text">epoll的结构以及创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll实例"><span class="toc-text">epoll实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll-ctl的实现"><span class="toc-text">epoll_ctl的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#添加监听文件"><span class="toc-text">添加监听文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#修改监听文件"><span class="toc-text">修改监听文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#删除监听文件"><span class="toc-text">删除监听文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#等待就绪事件"><span class="toc-text">等待就绪事件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wait-queue-hook"><span class="toc-text">wait queue hook</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#惊群效应"><span class="toc-text">惊群效应</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#多个进程-线程等待同一个epoll实例"><span class="toc-text">多个进程/线程等待同一个epoll实例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同一个fd被加入到多个epoll实例"><span class="toc-text">同一个fd被加入到多个epoll实例</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i> blog </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        epoll实现探究
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-01-09 21:16:16</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#linux - epoll" title="linux - epoll">linux - epoll</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>在以前，传统的网络编程是多线程模型，一个线程单独处理一个请求。</p>
<p>然而，线程是很昂贵的资源：</p>
<ol>
<li>线程的创建和销毁成本很高，linux的线程实际上是特殊的进程；因此通常会使用线程池来减少线程创建和销毁的开销</li>
<li>线程本身占用较大的内存，如果并发比较高，那么光是线程本身占用的内存就很大了</li>
<li>线程上下文切换的成本也比较高，如果频繁切换，可能cpu用于处理线程切换的时间会大于业务执行时间</li>
<li>容易导致系统负载升高</li>
</ol>
<p>因此，当面对海量连接的时候，传统的多线程模式就无能为力了。</p>
<p>而且：</p>
<ol>
<li>处理请求的很大比重时间，线程都是在等待网络io，线程很多时候都是在等待io</li>
<li>在推送服务场景下，有海量连接，但是大多数时候只有少数连接是活跃的</li>
</ol>
<p>这时候，我们就想，能不能有一种机制，可不可以让多个连接复用一个线程？就像cpu的分时复用一样。</p>
<p>答案肯定是可以的，这就是IO多路复用。要能够实现IO多路复用，需要：</p>
<ol>
<li>非阻塞IO。传统的阻塞IO，当需要等待IO时，会阻塞线程，这还复用个屁？</li>
<li>需要有一个poller，能够轮询连接的io事件。比如当需要往一个连接写入内容，这个连接当前缓冲区是满的，无法写入，我们希望当它的缓存区空闲的时候能够收到通知，从而完成写入</li>
</ol>
<p>对于非阻塞io，我们可以在<code>accept</code>连接的时候指定<code>SOCK_NONBLOCK</code>标志，或者在一些低版本的linux内核上，通过<code>fcntl</code>系统调用来设置。</p>
<p>而poller，linux提供了<a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">select</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">poll</a>和<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll</a>三种系统接口。本篇文章的主角是epoll。</p>
<p>首先来看select接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>An fd_set is a fixed size buffer. The Linux kernel allows fd_set of arbitrary size, determining the length of the sets to be checked from the value of nfds. However, the glibc implementation make the fd_set a fixed-size type is fixed in size, with size defined as 1024.</p>
<p>Three independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to see if characters become available for reading (more precisely, to see if a read will not block; in particular, a file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is available for write (though a large write may still block). The file descriptors in exceptfds will be watched for exceptional conditions.</p>
<p>The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready. If both fields of the timeval structure are zero, then select() returns immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can block indefinitely.</p>
</blockquote>
<p>select具有如下几个缺陷：</p>
<ol>
<li>如果一个fd需要同时监听readab和writable事件，那么需要同时加入到readfds和writefds列表中</li>
<li>每次调用select，都需要将要监听的fd列表从用户空间传到内核空间，内核每次都需要COPY FROM USER，而往往fd列表是固定的内容</li>
<li>glibc的实现中，限制了fd_set的大小固定为1024，因此当需要监听的fd列表超过了这个大小，就无能为力了</li>
</ol>
<p>poll接口相对select接口有所改进：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fds is a pollfd array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>首先，poll使用结构体<code>pollfd</code>来描述需要监听的文件，并且可以通过设置<code>pollfd#events</code>来描述感兴趣的事件，同时当返回时，可以通过<code>pollfd#revents</code>来获取就绪的事件类型。这样就不需要像select接口分别指定三种类型的文件描述符集合了，而且事件类型也更加丰富。而且poll接口对于fds数组的大小也没有限制。</p>
<p>但是，每次调用poll，依然需要传入感兴趣的fd列表。</p>
<p>也正是因为poll的不足，才有了后来epoll的出现。</p>
<p>接下来简单看一下epoll的接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往一个epoll实例中添加/移除/修改对fd的事件监听 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待就绪事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>光从接口就可以看到epoll的强大。select和poll才只有一个接口，而epoll自己就足足有3个啊！</p>
<p>epoll本身也是一个file，我们需要先调用<code>epoll_create</code>创建它，才能使用，该方法会在内核空间创建一个<code>epoll</code>实例，然后返回对应的<code>fd</code>。<br>既然<code>epoll</code>是一个file，那么当不再使用的时候，需要被close掉，就像我们close一个打开的文件一样。</p>
<p>当我们通过epoll_create创建一个epoll实例，然后通过epoll_ctl来添加，移除或者修改对文件的就绪事件的监听。比如，当一个连接到达时，我们将其加入epoll，并监听其EPOLLIN/EPOLLOUT/EPOLLRDHUP事件。然后可以多次调用epoll_wait方法来轮询是否有就绪事件，而不用重新加入；当接收到EPOLLRDHUP事件时，移除对该文件的监听，并将其关闭。</p>
<p>epoll也可以被别的epoll轮询！！！</p>
<p>接下来我们基于linux kernel 5 的代码看一下epoll的实现。</p>
<h3 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h3><h5 id="epoll的结构以及创建"><a href="#epoll的结构以及创建" class="headerlink" title="epoll的结构以及创建"></a>epoll的结构以及创建</h5><p>我们首先来看一下epoll的创建过程。</p>
<p>在<code>fs/eventpoll.c</code>文件下，可以看到<code>epoll_create</code>系统调用的定义，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_epoll_create(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SYSCALL_DEFINEN</code>是一系列用于定义系统调用的宏，<code>N</code>表示系统调用的参数个数。因为<code>epoll_create</code>只有一个参数，因此使用的是<code>SYSCALL_DEFINE1</code>。</p>
<p>我们可以看到，如果传入的<code>size</code>小于或者等于<code>0</code>，则会返回<code>EINVAL</code>，表示参数错误。在早期的版本中，<code>epoll</code>是使用哈希表来管理注册的文件列表，需要传入一个<code>size</code>参数；但是现在的版本已经换做红黑树了，该参数已经没有具体的意义了，但是为了兼容性还是保留了下来，使用时传入一个任意大于0的数就好了。</p>
<p>接下来，我们看一下<code>do_epoll_create</code>的实现，该方法才是真正干活的主：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span> <span class="comment">// eventpoll是epoll实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 前面说过epoll实例本身也是一个file</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// flags只支持设置EPOLL_CLEXEC</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配一个epoll实例</span></span><br><span class="line">	error = ep_alloc(&amp;ep);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配一个未使用的文件描述符fd</span></span><br><span class="line">	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = fd;</span><br><span class="line">		<span class="keyword">goto</span> out_free_ep;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个具有匿名inode的file，并设置file-&gt;f_op为eventpoll_fops</span></span><br><span class="line">    <span class="comment">// 同时设置file-&gt;private_date为ep</span></span><br><span class="line">	file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">				 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		error = PTR_ERR(file);</span><br><span class="line">		<span class="keyword">goto</span> out_free_fd;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 管理epoll实例和file</span></span><br><span class="line">	ep-&gt;file = file;</span><br><span class="line">    <span class="comment">// 设置fd对应的file</span></span><br><span class="line">	fd_install(fd, file);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    <span class="comment">// 创建失败，释放fd</span></span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    <span class="comment">// 创建失败，释放内存</span></span><br><span class="line">	ep_free(ep);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>do_epoll_create</code>接收一个<code>flags</code>参数，如果我们使用<code>epoll_create</code>来创建，默认是没有设置任何<code>flags</code>的。但是内核后面又添加了<code>epoll_create1</code>系统调用，使用该系统调用是可以设置<code>flags</code>的，具体可以查看<code>man</code>手册。</p>
<p>上面代码已经加了具体的注释了。在linux中正所谓一切皆文件，可以看到当我们创建epoll实例的时候，同时会创建一个<code>file</code>。其实<code>linux</code>的文件系统正是面向对象的思想，我们可以把<code>file</code>看成是一个统一的接口，具体的实现只需要把对应的方法实现注册到<code>file-&gt;f_op</code>中就好了，而且<code>file-&gt;private_data</code>保存了实际实现的指针。那些支持接口的语言，背后的实现无外乎也就是这样。</p>
<h5 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h5><p>既然是创建epoll实例，那我们是不是应该看一下这个epoll实例到底是什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">// 资源保护锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞在epoll_wait的等待队列</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wq; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// epoll实例本身实现了file-&gt;f_op-&gt;poll方法，对应的poll等待队列</span></span><br><span class="line">    <span class="comment">// 比如epoll实例本身也可以被添加到其他epoll实例中</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 就绪队列，保存已经就绪的事件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保护rdllist和ovflist的锁</span></span><br><span class="line">	<span class="keyword">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存储添加到epoll实例的fd的红黑树</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rbr</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当正在转移就绪队列中的事件到用户空间时，这段时期就绪的事件会被暂时加入该队列，等待转移结束再添加到rdllist。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建epoll实例的用户</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll本身也是一个文件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line">	<span class="keyword">int</span> visited;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">	<span class="comment">/* used to track busy poll napi_id */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> napi_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>epoll实例使用红黑树来管理注册的需要监听的fd，关于红黑树的介绍可以参考<a href="https://mcll.top/2019/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91/" target="_blank" rel="noopener">该篇</a>，这里就不介绍了。</p>
<p>每个被添加到epoll实例的fd对应一个<code>epitem</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 红黑树节点，linux内核中红黑树被广泛使用，因此有必要实现成通用结构，通过rb_node连接到rb-tree</span></span><br><span class="line">        <span class="comment">// 当需要访问具体结构体时，通过简单的指针运算以及类型转换就可以了</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于添加到epoll实例的就绪队列的链表节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将就绪列表中的事件转移到用户空间期间，新的就绪事件会先加入到epoll的ovflist；为什么不复用rdllink字段呢？因为同一个fd，可能还在就绪队列中，但是又有了新的就绪事件了，这时候它既在就绪队列中，也在ovflist中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该epitem关联的fd和file信息，用于红黑树中的比较；我们知道，红黑树是二叉搜索树，在查找的时候，是需要比较大小的</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of active wait queue attached to poll operations </span></span><br><span class="line">	<span class="keyword">int</span> nwait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List containing poll wait queues</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该epitem注册的epoll实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// used to link this item to the "struct file" items list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wakeup_source used when EPOLLWAKEUP is set </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该结构体保存epitem对应的fd和感兴趣的事件列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个<code>fd</code>被添加到epoll实例时，epoll实例会调用对应file的poll方法，poll方法有两个作用：</p>
<ul>
<li>设置callback，当文件有新的就绪事件产生时，调用该callback</li>
<li>返回文件当前的就绪事件</li>
</ul>
<p>而当我们从epoll实例移除一个fd时，需要从file中移除注册的callback。</p>
<p>注册callback，实际上是添加一个<code>eppoll_entry</code>到file的等待队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait structure used by the poll hooks</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">	<span class="comment">// 用于链接到epitem的pwdlist</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对应的epitem</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存回调函数</span></span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> wait; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// The wait queue head that linked the "wait" wait queue item</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>eppoll_entry</code>使用<code>wait</code>链接到目标文件的等待队列，这样当目标文件有就绪事件到来时，就可以调用<code>wait</code>中的回调函数了；而<code>whead</code>保存等待队列的<code>head</code>，使用<code>llink</code>链接到<code>epitem</code>的<code>pwdlist</code>队列，这样当从<code>epoll</code>删除目标文件时，可以遍历<code>epitem</code>的<code>pwdlist</code>队列，然后通过<code>whead</code>删除添加到file中的回调。</p>
<p>接下来看一下 <code>epoll_filefd</code>以及在搜索红黑树时，是如果通过该结构体比较大小的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 对应file</span></span><br><span class="line">	<span class="keyword">int</span> fd;            <span class="comment">// 对应的fd</span></span><br><span class="line">&#125; __packed;            <span class="comment">// _packed设置内存对齐为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare RB tree keys */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ep_cmp_ffd</span><span class="params">(struct epoll_filefd *p1,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct epoll_filefd *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p1-&gt;file &gt; p2-&gt;file ? +<span class="number">1</span>:</span><br><span class="line">	        (p1-&gt;file &lt; p2-&gt;file ? <span class="number">-1</span> : p1-&gt;fd - p2-&gt;fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，比较的逻辑是：</p>
<ol>
<li>首先比较file的地址</li>
<li>如果属于同一个file，则比较fd；比如使用dup系统调用，就可以产生两个fd指向同一个file</li>
</ol>
<h5 id="epoll-ctl的实现"><a href="#epoll-ctl的实现" class="headerlink" title="epoll_ctl的实现"></a>epoll_ctl的实现</h5><p>我们要添加，修改或者移除对目标文件的监听，都是通过<code>epoll_ctl</code>系统调用实现的，接下来看一下该方法的实现。</p>
<p>首先，我们看一下<code>syscall</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">		struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	error = -EFAULT;</span><br><span class="line">	<span class="comment">// ep_op_has_event：对应操作是否需要从用户空间拷贝event</span></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">	 	<span class="comment">// 拷贝用户空间的event到epds中</span></span><br><span class="line">	    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event))) </span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	<span class="comment">// 获取对应的epoll实例</span></span><br><span class="line">	f = fdget(epfd); </span><br><span class="line">	<span class="keyword">if</span> (!f.file)  </span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取目标文件</span></span><br><span class="line">	tf = fdget(fd);  </span><br><span class="line">	<span class="keyword">if</span> (!tf.file)</span><br><span class="line">		<span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	error = -EPERM;</span><br><span class="line">	<span class="comment">// 方法定义在`linux/poll.h`中，检查目标文件是否实现了poll方法，只有实现了poll方法才可以添加到epoll中监听</span></span><br><span class="line">	<span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if EPOLLWAKEUP is allowed */</span></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">		ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="comment">// 检查是否是epoll实例，并且epoll不能监听自己</span></span><br><span class="line">	<span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只有当op=EPOLL_CTL_ADD，才会加入到唤醒队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">	 	<span class="comment">// 如果目标文件是epoll，不允许设置EPOLLEXCLUSIVE</span></span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">			<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">		<span class="comment">// 监听其他epoll时，也不允许设置EPOLLEXCLUSIVE</span></span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">				<span class="comment">// 有些flag不允许和EPOLLEXCLUSIVE同时使用</span></span><br><span class="line">				(epds.events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">			<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取epoll实例，我们会将其保存到file的private_data中</span></span><br><span class="line">	ep = f.file-&gt;private_data; </span><br><span class="line"></span><br><span class="line">	mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 如果是添加新文件</span></span><br><span class="line">	<span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;</span><br><span class="line">		<span class="comment">// 如果目标文件也是一个epoll实例，那么有可能导致循环监听，需要执行循环检测</span></span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;f.file-&gt;f_ep_links) ||  </span><br><span class="line">						is_file_epoll(tf.file)) &#123; </span><br><span class="line">			full_check = <span class="number">1</span>;</span><br><span class="line">			mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">			mutex_lock(&amp;epmutex);</span><br><span class="line">			<span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">				error = -ELOOP;</span><br><span class="line">				<span class="keyword">if</span> (ep_loop_check(ep, tf.file) != <span class="number">0</span>) &#123;</span><br><span class="line">					clear_tfile_check_list();</span><br><span class="line">					<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				list_add(&amp;tf.file-&gt;f_tfile_llink,</span><br><span class="line">							&amp;tfile_check_list);</span><br><span class="line">			mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">				tep = tf.file-&gt;private_data;</span><br><span class="line">				mutex_lock_nested(&amp;tep-&gt;mtx, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先先到rb-tree查找，是否已经添加过该目标文件</span></span><br><span class="line">	epi = ep_find(ep, tf.file, fd);</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">		<span class="comment">// 添加目标文件</span></span><br><span class="line">		<span class="comment">// 如果没有添加过</span></span><br><span class="line">		<span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">			<span class="comment">// 默认接收EPOLLERR和EPOLLHUB事件</span></span><br><span class="line">			epds.events |= EPOLLERR | EPOLLHUP;  </span><br><span class="line">			<span class="comment">// 执行插入逻辑，包括插入rb-tree，设置callback等</span></span><br><span class="line">			error = ep_insert(ep, &amp;epds, tf.file, fd, full_check); </span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -EEXIST;</span><br><span class="line">		<span class="keyword">if</span> (full_check)</span><br><span class="line">			clear_tfile_check_list();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">		<span class="comment">// 删除目标文件</span></span><br><span class="line">		<span class="keyword">if</span> (epi)</span><br><span class="line">			<span class="comment">// 目标文件存在，执行删除逻辑</span></span><br><span class="line">			error = ep_remove(ep, epi); <span class="comment">// 执行删除逻辑</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = -ENOENT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">		<span class="keyword">if</span> (epi) &#123;</span><br><span class="line">			<span class="comment">// 如果添加的时候设置了EPOLLEXCLUSIVE，则不允许修改</span></span><br><span class="line">			<span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">				<span class="comment">// 默认监听EPOLLERR和EPOLLHUP </span></span><br><span class="line">				epds.events |= EPOLLERR | EPOLLHUP;</span><br><span class="line">				<span class="comment">// 执行更新</span></span><br><span class="line">				error = ep_modify(ep, epi, &amp;epds); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOENT; </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tep != <span class="literal">NULL</span>)</span><br><span class="line">		mutex_unlock(&amp;tep-&gt;mtx);</span><br><span class="line">	mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux典型的错误处理，挺巧妙的</span></span><br><span class="line">error_tgt_fput:</span><br><span class="line">	<span class="keyword">if</span> (full_check)</span><br><span class="line">		mutex_unlock(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">	fdput(tf);</span><br><span class="line">error_fput:</span><br><span class="line">	fdput(f);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体逻辑在代码中已经注释了，我们可以看到，只有实现了<code>poll</code>方法才可以被添加到<code>epoll</code>中</p>
<h6 id="添加监听文件"><a href="#添加监听文件" class="headerlink" title="添加监听文件"></a>添加监听文件</h6><p>接下来看一下<code>ep_insert</code>的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在linux/poll.h中定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 在poll方法中被调用，用于添加eppoll_entry到file的等待队列</span></span><br><span class="line">	poll_queue_proc _qproc;</span><br><span class="line">	<span class="comment">// 监听的事件列表</span></span><br><span class="line">	<span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, <span class="keyword">const</span> struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">		     struct file *tfile, <span class="keyword">int</span> fd, <span class="keyword">int</span> full_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">__poll_t</span> revents;</span><br><span class="line">	<span class="keyword">long</span> user_watches;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先检查一下，是否达到用户最大允许监听的文件数量</span></span><br><span class="line">	user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从slab cache分配一个epitem</span></span><br><span class="line">	<span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化为空指针</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">	<span class="comment">// 设置ep</span></span><br><span class="line">	epi-&gt;ep = ep; </span><br><span class="line">	<span class="comment">// 设置ffd字段</span></span><br><span class="line">	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	<span class="comment">// 设置监听的事件</span></span><br><span class="line">	epi-&gt;event = *event;</span><br><span class="line">	epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// next指针用于加入就绪列表</span></span><br><span class="line">	epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123; </span><br><span class="line">		error = ep_create_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> error_create_wakeup_source;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化ep_pqueue</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	<span class="comment">// 设置pt._qproc=ep_ptable_queue_proc，pt._key=~0</span></span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用file对应的poll方法，该方法会返回当前正在监听的已经就绪的事件列表</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_unregister;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">	<span class="comment">// 添加epitem到file的f_ep_links尾部</span></span><br><span class="line">	list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">	spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入红黑树</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now check if we've created too many backpaths */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (full_check &amp;&amp; reverse_path_check())</span><br><span class="line">		<span class="keyword">goto</span> error_remove_epi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* record NAPI ID of new item if present */</span></span><br><span class="line">	ep_set_busy_poll_napi_id(epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有就绪事件并且还没有添加到就绪列表</span></span><br><span class="line">	<span class="keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span><br><span class="line">		<span class="comment">// 添加到就绪列表表尾</span></span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 唤醒等待epoll_wait的线程</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="comment">// 如果当前epoll实例被添加到别的epoll中，需要通知</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			<span class="comment">// 这里不能直接通知，会产生死锁</span></span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这里通知当前epoll的监听者</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加成功，正常返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">error_remove_epi:</span><br><span class="line">	spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">	list_del_rcu(&amp;epi-&gt;fllink);</span><br><span class="line">	spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">error_unregister:</span><br><span class="line">	ep_unregister_pollwait(ep, epi);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (ep_is_linked(epi))</span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line"></span><br><span class="line">error_create_wakeup_source:</span><br><span class="line">	kmem_cache_free(epi_cache, epi);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下<code>ep_item_poll</code>方法，该方法会调用file对应的poll方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法返回正在监听的已经就绪的事件列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">__poll_t</span> ep_item_poll(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span><br><span class="line">				 <span class="keyword">int</span> depth) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> locked;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置poll_table的_key</span></span><br><span class="line">	pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">	<span class="comment">// 如果目标文件不是epoll实例，走这个分支</span></span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">	    <span class="comment">// vfs_poll方法，该方法会调用file的poll方法，并返回file当前所有的就绪事件列表</span></span><br><span class="line">		<span class="comment">// 我们只需要获取关心的事件列表，因此 &amp; event.events</span></span><br><span class="line">		<span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标文件是epoll实例</span></span><br><span class="line">	ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">	<span class="comment">// 添加到epoll实例的poll_wait链表</span></span><br><span class="line">	poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">	locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">				  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">				  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，会调用<code>vfs_poll</code>方法，来设置<code>callback</code>，而不同的文件实现有不同的<code>poll</code>方法，这里我们看一下<code>tcp</code>的<code>sock</code>的<code>poll</code>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在 linux/poll.h 中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__poll_t</span> vfs_poll(struct file *file, struct poll_table_struct *pt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">	<span class="comment">// 调用file的poll方法</span></span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">__poll_t</span> tcp_poll(struct file *file, struct socket *sock, poll_table *wait)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">__poll_t</span> mask;</span><br><span class="line">	<span class="comment">// 获取network sock</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法回调wait._qproc，设置callback</span></span><br><span class="line">	sock_poll_wait(file, sock, wait);</span><br><span class="line"></span><br><span class="line">	state = inet_sk_state_load(sk);</span><br><span class="line">	<span class="keyword">if</span> (state == TCP_LISTEN)</span><br><span class="line">		<span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... 获取当前所有就绪事件列表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法定义在 linux/net/sock.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_poll_wait</span><span class="params">(struct file *filp, struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">				  poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// p不为空且p._qproc不为空，具体实现在linux/poll.h中</span></span><br><span class="line">	<span class="keyword">if</span> (!poll_does_not_wait(p)) &#123; </span><br><span class="line">		<span class="comment">// 调用p._qproc，具体实现在linux/poll.h中</span></span><br><span class="line">		poll_wait(filp, &amp;sock-&gt;wq.wait, p);</span><br><span class="line">		</span><br><span class="line">		smp_mb();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，file的poll方法主要有两个作用：</p>
<ol>
<li>如果<code>poll_table</code>和<code>poll_table._qproc</code>不为空，则调用该方法，设置监听回调</li>
<li>返回file当前所有已经就绪的事件</li>
</ol>
<p>根据前面的分析，我们知道<code>poll_table._qproc</code>实际上就是<code>fs/eventpoll.c</code>中的<code>ep_ptable_queue_proc</code>方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> <span class="title">wait_queue_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">void</span>			*<span class="keyword">private</span>;</span><br><span class="line">	<span class="keyword">wait_queue_func_t</span>	func; <span class="comment">// 回调函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span> <span class="comment">// 用于链接到file的等待队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">				 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// poll_table保存在ep_pqueue，通过指针运算就可以获取到ep_pqueue中对应的epitem</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="comment">// 从slab cache分配pwq</span></span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">		<span class="comment">// 设置回调函数到pwq-&gt;wait-&gt;wait_queue_func_t</span></span><br><span class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback); </span><br><span class="line">		pwq-&gt;whead = whead;</span><br><span class="line">		pwq-&gt;base = epi;</span><br><span class="line">		<span class="comment">// 如果设置了EPOLLEXCLUSIVE</span></span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">			<span class="comment">// 方法声明在linux/wait.h中， 链接pwd-&gt;wait到whead，同时会设置EXCLUSIVE标志位</span></span><br><span class="line">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait); </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		<span class="comment">// 将pwd添加到epi-&gt;pwdlist中</span></span><br><span class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); </span><br><span class="line">		epi-&gt;nwait++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">		epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到添加的逻辑，主要就是调用file的poll方法，设置添加回调函数到file的等待队列，并且如果已经有正在监听的就绪事件，则唤醒正在等待队列中的线程。</p>
<h6 id="修改监听文件"><a href="#修改监听文件" class="headerlink" title="修改监听文件"></a>修改监听文件</h6><p>接下来看一下修改的逻辑：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_modify</span><span class="params">(struct eventpoll *ep, struct epitem *epi,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">const</span> struct epoll_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">	poll_table pt;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里将poll_table._qproc初始化为空指针，</span></span><br><span class="line">	<span class="comment">// 这样在调用file的poll方法时，只会返回就绪事件列表，而不会设置回调函数</span></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的事件掩码</span></span><br><span class="line">	epi-&gt;event.events = event-&gt;events; </span><br><span class="line">	<span class="comment">// 设置新的data，用户空间可以使用event.data来保存连接相关的上下文信息</span></span><br><span class="line">	epi-&gt;event.data = event-&gt;data;</span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ep_has_wakeup_source(epi))</span><br><span class="line">			ep_create_wakeup_source(epi);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ep_has_wakeup_source(epi)) &#123;</span><br><span class="line">		ep_destroy_wakeup_source(epi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	smp_mb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为pt._qproc==NULL，只会检查就绪事件列表</span></span><br><span class="line">	<span class="keyword">if</span> (ep_item_poll(epi, &amp;pt, <span class="number">1</span>)) &#123;</span><br><span class="line">		write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(epi)) &#123; </span><br><span class="line">			<span class="comment">// 还不在就绪队列中</span></span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">			<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">				wake_up(&amp;ep-&gt;wq);</span><br><span class="line">			<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">				pwake++;</span><br><span class="line">		&#125;</span><br><span class="line">		write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，修改的逻辑，就是更新<code>epitem</code>中<code>evnet</code>的相关信息，然后检查一下是否有就绪事件，因为有可能存在之前没有监听的就绪事件。</p>
<h6 id="删除监听文件"><a href="#删除监听文件" class="headerlink" title="删除监听文件"></a>删除监听文件</h6><p>接下来看一下删除的逻辑：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_remove</span><span class="params">(struct eventpoll *ep, struct epitem *epi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">epi</span>-&gt;<span class="title">ffd</span>.<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Removes poll wait queue hooks.</span></span><br><span class="line">	ep_unregister_pollwait(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove the current item from the list of epoll hooks</span></span><br><span class="line">	spin_lock(&amp;file-&gt;f_lock);</span><br><span class="line">	list_del_rcu(&amp;epi-&gt;fllink);</span><br><span class="line">	spin_unlock(&amp;file-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从红黑树删除</span></span><br><span class="line">	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (ep_is_linked(epi))</span><br><span class="line">		<span class="comment">// 从就绪列表删除</span></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line"> </span><br><span class="line">	call_rcu(&amp;epi-&gt;rcu, epi_rcu_free);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用户监听数量减1</span></span><br><span class="line">	atomic_long_dec(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_unregister_pollwait</span><span class="params">(struct eventpoll *ep, struct epitem *epi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lsthead</span> = &amp;<span class="title">epi</span>-&gt;<span class="title">pwqlist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历epi-&gt;pwdlist</span></span><br><span class="line">	<span class="keyword">while</span> (!list_empty(lsthead)) &#123;</span><br><span class="line">		<span class="comment">// list_first_entry是一个宏</span></span><br><span class="line">		pwq = list_first_entry(lsthead, struct eppoll_entry, llink);</span><br><span class="line"></span><br><span class="line">		list_del(&amp;pwq-&gt;llink);</span><br><span class="line">		<span class="comment">// 从等待回来移除hook</span></span><br><span class="line">		ep_remove_wait_queue(pwq);</span><br><span class="line">		<span class="comment">// 回收内存</span></span><br><span class="line">		kmem_cache_free(pwq_cache, pwq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除操作主要是做一些清除工作。</p>
<h5 id="等待就绪事件"><a href="#等待就绪事件" class="headerlink" title="等待就绪事件"></a>等待就绪事件</h5><p>接下来看一下<code>epoll_wait</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">		<span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 调用do_epoll_wait</span></span><br><span class="line">	<span class="keyword">return</span> do_epoll_wait(epfd, events, maxevents, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// epoll_wait，需要将就绪事件列表拷贝到用户空间</span></span><br><span class="line">	<span class="comment">// 验证用户空间传过来的内存空间是否可写</span></span><br><span class="line">	<span class="keyword">if</span> (!access_ok(events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据epfd获取对应的file</span></span><br><span class="line">	f = fdget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="comment">// epll_wait的fd参数必须是epoll file</span></span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(f.file)) </span><br><span class="line">		<span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">	ep = f.file-&gt;private_data; <span class="comment">// 获取对应的epoll实例</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用ep_poll</span></span><br><span class="line">	error = ep_poll(ep, events, maxevents, timeout); </span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，最后调用了<code>ep_poll</code>方法，接下来看一下该方法实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, eavail, timed_out = <span class="number">0</span>;</span><br><span class="line">	u64 slack = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> waiter = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">	<span class="keyword">ktime_t</span> expires, *to = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">// 设置过期时间</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">end_time</span> = <span class="title">ep_set_mstimeout</span>(<span class="title">timeout</span>);</span></span><br><span class="line"></span><br><span class="line">		slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">		to = &amp;expires;</span><br><span class="line">		*to = timespec64_to_ktime(end_time);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如果timeout为0，则epoll_wait不会阻塞，设置time_out为true</span></span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">		<span class="comment">// 获取就绪队列事件长度</span></span><br><span class="line">		eavail = ep_events_available(ep);  </span><br><span class="line">		write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line">		<span class="comment">// 拷贝已经就绪的事件到用户空间，如果有的话</span></span><br><span class="line">		<span class="keyword">goto</span> send_events;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果timeout小于0，则会阻塞直到有就绪事件到来</span></span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line">    <span class="comment">// 如果没有就绪事件可以获取</span></span><br><span class="line">	<span class="keyword">if</span> (!ep_events_available(ep))</span><br><span class="line">		<span class="comment">// 如果没有定义CONFIG_NET_RX_BUSY_POLL宏，则该方法为空实现</span></span><br><span class="line">		ep_busy_loop(ep, timed_out);</span><br><span class="line"></span><br><span class="line">	eavail = ep_events_available(ep); </span><br><span class="line">	<span class="keyword">if</span> (eavail)</span><br><span class="line">		<span class="comment">// 如果已经有就绪事件了</span></span><br><span class="line">		<span class="keyword">goto</span> send_events;</span><br><span class="line"></span><br><span class="line">	ep_reset_busy_poll_napi_id(ep);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!waiter) &#123; </span><br><span class="line">		<span class="comment">// 当前任务还没有加入epoll的等待队列</span></span><br><span class="line">	    <span class="comment">// 加入ep的等待队列，如果有新的就绪事件到达，则会在ep_poll_callback唤醒当前任务</span></span><br><span class="line">		waiter = <span class="literal">true</span>;</span><br><span class="line">		init_waitqueue_entry(&amp;wait, current);</span><br><span class="line"></span><br><span class="line">		spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待就绪事件到达</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * PROCESS STATE CODES</span></span><br><span class="line"><span class="comment">         *  R  running or runnable (on run queue)</span></span><br><span class="line"><span class="comment">         *  D  uninterruptible sleep (usually IO)</span></span><br><span class="line"><span class="comment">         *  S  interruptible sleep (waiting for an event to complete)</span></span><br><span class="line"><span class="comment">         *  Z  defunct/zombie, terminated but not reaped by its parent</span></span><br><span class="line"><span class="comment">         *  T  stopped, either by a job control signal or because it is being traced</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 设置任务状态为S</span></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查是否有 fatal_signal</span></span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current)) &#123; </span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查就绪事件列表</span></span><br><span class="line">		eavail = ep_events_available(ep); </span><br><span class="line">		<span class="keyword">if</span> (eavail)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查是否有signal</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; </span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep util timeout</span></span><br><span class="line">        <span class="comment">// 返回0则表示timeout</span></span><br><span class="line">        <span class="comment">// 由于当前任务状态设置为TASK_INTERRUPTIBLE，因此可能由于signal到来而被唤醒，比如在ep_poll_callback被唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">		    <span class="comment">// 由于timeout而唤醒，设置超时</span></span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置为RUNNING</span></span><br><span class="line">	__set_current_state(TASK_RUNNING); </span><br><span class="line"></span><br><span class="line">send_events:</span><br><span class="line">	<span class="comment">// 如果由于signal退出等待，res为true</span></span><br><span class="line">	<span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">		<span class="comment">// ep_send_events遍历就绪队列，拷贝就绪事件到用户空间</span></span><br><span class="line">	    !(res = ep_send_events(ep, events, maxevents))</span><br><span class="line">		<span class="comment">// 如果还未超时，继续等待就绪事件到来</span></span><br><span class="line">		 &amp;&amp; !timed_out) </span><br><span class="line">		<span class="comment">// 还没有就绪事件，并且还未超时，等待就绪事件到来</span></span><br><span class="line">		<span class="keyword">goto</span> fetch_events; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waiter) &#123;</span><br><span class="line">		spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">		<span class="comment">// 从epoll的等待队列移除</span></span><br><span class="line">		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait); </span><br><span class="line">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们看一下<code>ep_send_events</code>方法的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxevents表示最多获取多少个event</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">			  struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line"></span><br><span class="line">	esed.maxevents = maxevents;</span><br><span class="line">	esed.events = events;</span><br><span class="line">	<span class="comment">// 在ep_scan_ready_list方法中调用ep_send_events_proc</span></span><br><span class="line">	ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, <span class="number">0</span>, <span class="literal">false</span>); </span><br><span class="line">	<span class="keyword">return</span> esed.res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">__poll_t</span> ep_scan_ready_list(struct eventpoll *ep,</span><br><span class="line">			      <span class="keyword">__poll_t</span> (*sproc)(struct eventpoll *,</span><br><span class="line">					   struct list_head *, <span class="keyword">void</span> *),</span><br><span class="line">			      <span class="keyword">void</span> *priv, <span class="keyword">int</span> depth, <span class="keyword">bool</span> ep_locked)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">__poll_t</span> res;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">	LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="comment">// 将rdllist链表拼接到txlist，同时重新初始化rdllist</span></span><br><span class="line">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist); </span><br><span class="line">	<span class="comment">// 设置ep-&gt;ovflist为NULL，后续新的就绪事件都将暂时加入到该列表中</span></span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, <span class="literal">NULL</span>); </span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回调ep_send_events_proc方法</span></span><br><span class="line">	res = (*sproc)(ep, &amp;txlist, priv); </span><br><span class="line"></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将ep-&gt;ovflist中的事件移动到rdllist</span></span><br><span class="line">	<span class="keyword">for</span> (nepi = READ_ONCE(ep-&gt;ovflist); (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(epi)) &#123;</span><br><span class="line">			<span class="comment">// 如果还没有加入rdllist</span></span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置ep-&gt;ovflist为EP_UNACTIVE_PTR，后续的就绪事件将加入到rdllist</span></span><br><span class="line">	WRITE_ONCE(ep-&gt;ovflist, EP_UNACTIVE_PTR); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将txlist剩余的就绪事件重新加入ep-&gt;rdllist</span></span><br><span class="line">	list_splice(&amp;txlist, &amp;ep-&gt;rdllist); </span><br><span class="line">	__pm_relax(ep-&gt;ws);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_locked)</span><br><span class="line">		mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下<code>ep_send_events_proc</code>方法，该方法拷贝就绪事件到用户空间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">__poll_t</span> ep_send_events_proc(struct eventpoll *ep, struct list_head *head,</span><br><span class="line">			       <span class="keyword">void</span> *priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> = <span class="title">priv</span>;</span></span><br><span class="line">	<span class="keyword">__poll_t</span> revents;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span> = <span class="title">esed</span>-&gt;<span class="title">events</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line"></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line">	esed-&gt;res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是一个宏，本质上还是for循环，从头遍历head链表中的就绪事件</span></span><br><span class="line">	list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="comment">// 如果已经超过maxevents</span></span><br><span class="line">		<span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents) </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		ws = ep_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (ws) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">				__pm_stay_awake(ep-&gt;ws);</span><br><span class="line">			__pm_relax(ws);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从就绪队列删除对应事件</span></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取就绪事件列表，因为ep._proc==NULL，这里只会检查是否有关心的就绪事件</span></span><br><span class="line">		revents = ep_item_poll(epi, &amp;pt, <span class="number">1</span>); </span><br><span class="line">		<span class="comment">// 如果已经没有感兴趣的就绪事件了，跳过</span></span><br><span class="line">		<span class="keyword">if</span> (!revents)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 拷贝到用户空间</span></span><br><span class="line">		<span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">		    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">		    <span class="comment">// 拷贝失败，重新加入就绪队列</span></span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">			<span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">				esed-&gt;res = -EFAULT;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		esed-&gt;res++;</span><br><span class="line">		uevent++;</span><br><span class="line">		<span class="comment">// 如果设置了EPLLONESHOT</span></span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT) </span><br><span class="line">			<span class="comment">// 将events mask设置为EP_PRIVATE_BITS，不会再触发通知，但是并没有从epoll中删除</span></span><br><span class="line">			epi-&gt;event.events &amp;= EP_PRIVATE_BITS; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123; </span><br><span class="line">			<span class="comment">// 如果是水平触发模式</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 重新加入rdllist就绪队列，下次epoll_wait会重新扫描对应文件是否有就绪事件</span></span><br><span class="line">            <span class="comment">// 当前遍历的就绪队列已经不是ep-&gt;rdllist，因此不会被重新扫描到</span></span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>epoll_wait</code>返回有三种情况：</p>
<ol>
<li>由于timeout大于或者等于0而超时返回</li>
<li>有signal产生</li>
<li>有就绪事件到来</li>
</ol>
<p><code>epoll_wait</code>会将就绪事件拷贝到用户空间，并且在拷贝之前会重新检查是否还存在就绪事件</p>
<p><strong>如果使用水平触发模式，就绪事件在被拷贝到用户空间之后，会被重新加入到就绪队列中</strong>，这样如果用户没有消费完对应事件，就会一直获得该事件的通知。</p>
<p>如果设置了<code>EPLLONESHOT</code>，那么在被拷贝到用户空间之后，<code>events</code>将被设置为<code>EP_PRIVATE_BITS</code>，将不会再监听任何事件，并且没有被从epoll中移除，如果需要重新监听，需要使用<code>epoll_modify</code>。</p>
<h6 id="wait-queue-hook"><a href="#wait-queue-hook" class="headerlink" title="wait queue hook"></a>wait queue hook</h6><p>接下来看一下回调函数，当file有新的就绪事件时就会回调该方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 通过wait获取对应的epitem</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line">	<span class="comment">// 获取对应的epoll实例 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span> </span><br><span class="line">	<span class="comment">// 事件列表             </span></span><br><span class="line">	<span class="keyword">__poll_t</span> pollflags = key_to_poll(key);       </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="comment">// 是否唤醒</span></span><br><span class="line">	<span class="keyword">int</span> ewake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取epoll的锁，防止与其他fd的竞争</span></span><br><span class="line">	read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	ep_set_busy_poll_napi_id(epi);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可能设置了EPOLLONESHOT，处于disable状态，直接解锁退出</span></span><br><span class="line">	<span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查就绪的事件类型是否有感兴趣的事件</span></span><br><span class="line">	<span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果ovflist!=EP_UNACTIVE_PTR，说明当前正在转移readyList中的事件到用户空间</span></span><br><span class="line">	<span class="comment">// 在此期间到达的事件暂时加入到ovflist</span></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp;</span><br><span class="line">		<span class="comment">// 将epi添加到ovflist链表尾部</span></span><br><span class="line">		    chain_epi_lockless(epi))</span><br><span class="line">			ep_pm_stay_awake_rcu(epi);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还没有加入到就绪队列，将其加入</span></span><br><span class="line">	<span class="keyword">if</span> (!ep_is_linked(epi) &amp;&amp;</span><br><span class="line">	    list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123; </span><br><span class="line">		ep_pm_stay_awake_rcu(epi);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果等待列表不为空</span></span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">	    <span class="comment">// 如果一个file同时使用EPOLLEXCLUSIVE添加到多个epoll实例中，那么在这些epoll实例中，每次只会唤醒一个有阻塞队列的epoll</span></span><br><span class="line">		<span class="comment">// 因此当设置了EPOLLEXCLUSIVE，只有真正唤醒了epoll的等待队列才会返回true</span></span><br><span class="line">		<span class="keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span><br><span class="line">		<span class="comment">// 如果存在POLLFREE，需执行一些清理操作，其他epoll也应该得到通知，因此需要返回false</span></span><br><span class="line">					!(pollflags &amp; POLLFREE)) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (pollflags &amp; EPOLLINOUT_BITS) &#123;</span><br><span class="line">			<span class="keyword">case</span> EPOLLIN:</span><br><span class="line">				<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)</span><br><span class="line">					ewake = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> EPOLLOUT:</span><br><span class="line">				<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)</span><br><span class="line">					ewake = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				ewake = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wake_up(&amp;ep-&gt;wq); <span class="comment">// 唤醒epoll对应的wq</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">		pwake++; <span class="comment">// 这里不能直接唤醒，存在锁竞争</span></span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">	<span class="comment">// 唤醒等待epoll本身事件的等待队列</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有设置EPOLLEXCLUSIVE，该方法会直接返回true</span></span><br><span class="line">	<span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span><br><span class="line">		ewake = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存在POLLFREE，执行清理操作</span></span><br><span class="line">	<span class="keyword">if</span> (pollflags &amp; POLLFREE) &#123;</span><br><span class="line">		</span><br><span class="line">		list_del_init(&amp;wait-&gt;entry);</span><br><span class="line">		</span><br><span class="line">		smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h5><p> In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, the <strong>thundering herd problem</strong> occurs <strong>when a large number of processes or threads waiting for an event are awoken when that event occurs, but only one process is able to handle the event</strong>. After all the processes wake up, they will start to handle the event, but only one will win. All processes will compete for resources, possibly freezing the computer, until the herd is calmed down again. </p>
<h6 id="多个进程-线程等待同一个epoll实例"><a href="#多个进程-线程等待同一个epoll实例" class="headerlink" title="多个进程/线程等待同一个epoll实例"></a>多个进程/线程等待同一个epoll实例</h6><p>如果多个进程或者线程通过<code>epoll_wait</code>阻塞在同一个<code>epoll</code>上，从上面的代码我们知道，<strong>当使用水平触发模式的时候，就绪的fd会被重新加入到就绪队列中</strong>，从而导致多个线程/进程被同一个就绪fd唤醒。我们可以使用边缘触发模式，或者设置<code>EPOLLONESHOT</code>来规避该问题。</p>
<h6 id="同一个fd被加入到多个epoll实例"><a href="#同一个fd被加入到多个epoll实例" class="headerlink" title="同一个fd被加入到多个epoll实例"></a>同一个fd被加入到多个epoll实例</h6><p>当一个file被同时添加到多个<code>epoll</code>中，并且监听了相同的事件。当该file对应事件就绪时，默认该file会被添加到每个epoll的就绪队列中。<br>可以在添加file到每个epoll的时候，设置<code>EPOLLEXCLUSIVE</code>这个flag来解决该问题：</p>
<blockquote>
<p>Sets an exclusive wakeup mode for the epoll file descriptor that is being attached to the target file descriptor, fd. When a wakeup event occurs and multiple epoll file descriptors are attached to the same target file using EPOLLEXCLUSIVE, one or more of the epoll file descriptors will receive an event with epoll_wait(2).  The default in this scenario (when EPOLLEXCLUSIVE is not set) is for all epoll file descriptors to receive an event.  EPOLLEXCLUSIVE is thus useful for avoiding thundering herd problems in certain scenarios.<br>If the same file descriptor is in multiple epoll instances, some with the EPOLLEXCLUSIVE flag, and others without, then events will be provided to all epoll instances that did not specify EPOLLEXCLUSIVE, and at least one of the epoll instances that did specify EPOLLEXCLUSIVE.</p>
</blockquote>
<p>注意：</p>
<ul>
<li><code>EPOLLEXCLUSIVE</code>只能在<code>EPOLL_CTL_ADD</code>操作中设置</li>
<li>无法有效的和<code>EPOLLONESHOT</code>共用，因为在<code>ep_send_events_proc</code>中，如果设置了<code>EPOLLONESHOT</code>，EPOLLEXCLUSIVE这个flag会被清除，但是该flag又不能在<code>EPOLL_CTL_MOD</code>调用时设置</li>
</ul>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>