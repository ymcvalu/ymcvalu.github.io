<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        epoll原理 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i>  </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO多路复用"><span class="toc-text">IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll实现"><span class="toc-text">epoll实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll的创建"><span class="toc-text">epoll的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll实例"><span class="toc-text">epoll实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#添加fd到epoll实例"><span class="toc-text">添加fd到epoll实例</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i>  </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        epoll原理
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-01-09 21:16:16</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#linux - epoll" title="linux - epoll">linux - epoll</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>在以前，传统的网络编程是多线程模型，一个线程单独处理一个请求。</p>
<p>然而，线程是很昂贵的资源：</p>
<ol>
<li>线程的创建和销毁成本很高，linux的线程实际上是特殊的进程；因此通常会使用线程池来减少线程创建和销毁的开销</li>
<li>线程本身占用较大的内存，如果并发比较高，那么光是线程本身占用的内存就很大了</li>
<li>线程上下文切换的成本也比较高，如果频繁切换，可能cpu用于处理线程切换的时间会大于业务执行时间</li>
<li>容易导致系统负载升高</li>
</ol>
<p>因此，当面对海量连接的时候，传统的多线程模式就无能为力了。</p>
<p>而且：</p>
<ol>
<li>处理请求的很大比重时间，线程都是在等待网络io，线程很多时候都是在等待io</li>
<li>在推送服务场景下，有海量连接，但是大多数时候只有少数连接是活跃的</li>
</ol>
<p>这时候，我们就想，能不能有一种机制，可不可以让多个连接复用一个线程？就像cpu的分时复用一样。</p>
<p>答案肯定是可以的，这就是IO多路复用。要能够实现IO多路复用，需要：</p>
<ol>
<li>非阻塞IO。传统的阻塞IO，当需要等待IO时，会阻塞线程，这还复用个屁？</li>
<li>需要有一个poller，能够轮询连接的io事件。比如当需要往一个连接写入内容，这个连接当前缓冲区是满的，无法写入，我们希望当它的缓存区空闲的时候能够收到通知，从而完成写入</li>
</ol>
<p>对于非阻塞io，我们可以在<code>accept</code>连接的时候指定<code>SOCK_NONBLOCK</code>标志，或者在一些低版本的linux内核上，通过<code>fcntl</code>系统调用来设置。</p>
<p>而poller，linux提供了<a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">select</a>、<a href="http://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">poll</a>和<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll</a>三种系统接口。本篇文章的主角是epoll。</p>
<p>首先来看select接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>An fd_set is a fixed size buffer. The Linux kernel allows fd_set of arbitrary size, determining the length of the sets to be checked from the value of nfds. However, the glibc implementation make the fd_set a fixed-size type is fixed in size, with size defined as 1024.</p>
<p>Three independent sets of file descriptors are watched.  The file descriptors listed in readfds will be watched to see if characters become available for reading (more precisely, to see if a read will not block; in particular, a file descriptor is also ready on end-of-file).  The file descriptors in writefds will be watched to see if space is available for write (though a large write may still block). The file descriptors in exceptfds will be watched for exceptional conditions.</p>
<p>The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready. If both fields of the timeval structure are zero, then select() returns immediately.  (This is useful for polling.)  If timeout is NULL (no timeout), select() can block indefinitely.</p>
</blockquote>
<p>select具有如下几个缺陷：</p>
<ol>
<li>如果一个fd需要同时监听readab和writable事件，那么需要同时加入到readfds和writefds列表中</li>
<li>每次调用select，都需要将要监听的fd列表从用户空间传到内核空间，内核每次都需要COPY FROM USER，而往往fd列表是固定的内容</li>
<li>glibc的实现中，限制了fd_set的大小固定为1024，因此当需要监听的fd列表超过了这个大小，就无能为力了</li>
</ol>
<p>poll接口相对select接口有所改进：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fds is a pollfd array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>首先，poll使用结构体<code>pollfd</code>来描述需要监听的文件，并且可以通过设置<code>pollfd#events</code>来描述感兴趣的事件，同时当返回时，可以通过<code>pollfd#revents</code>来获取就绪的事件类型。这样就不需要像select接口分别指定三种类型的文件描述符集合了，而且事件类型也更加丰富。而且poll接口对于fds数组的大小也没有限制。</p>
<p>但是，每次调用poll，依然需要传入感兴趣的fd列表。</p>
<p>也正是因为poll的不足，才有了后来epoll的出现。</p>
<p>接下来简单看一下epoll的接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往一个epoll实例中添加/移除/修改对fd的事件监听 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待就绪事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>光从接口就可以看到epoll的强大。select和poll才只有一个接口，而epoll自己就足足有3个啊！</p>
<p>epoll本身也是一个file，我们需要先调用<code>epoll_create</code>创建它，才能使用，该方法会在内核空间创建一个<code>epoll</code>实例，然后返回对应的<code>fd</code>。<br>既然<code>epoll</code>是一个file，那么当不再使用的时候，需要被close掉，就像我们close一个打开的文件一样。</p>
<p>当我们通过epoll_create创建一个epoll实例，然后通过epoll_ctl来添加，移除或者修改对文件的就绪事件的监听。比如，当一个连接到达时，我们将其加入epoll，并监听其EPOLLIN/EPOLLOUT/EPOLLRDHUP事件。然后可以多次调用epoll_wait方法来轮询是否有就绪事件，而不用重新加入；当接收到EPOLLRDHUP事件时，移除对该文件的监听，并将其关闭。</p>
<p>epoll也可以被别的epoll轮询！！！</p>
<p>接下来我们基于linux kernel 5 的代码看一下epoll的实现。</p>
<h3 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h3><h5 id="epoll的创建"><a href="#epoll的创建" class="headerlink" title="epoll的创建"></a>epoll的创建</h5><p>我们首先来看一下epoll的创建过程。</p>
<p>在<code>fs/eventpoll.c</code>文件下，可以看到<code>epoll_create</code>系统调用的定义，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_epoll_create(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SYSCALL_DEFINEN</code>是一系列用于定义系统调用的宏，<code>N</code>表示系统调用的参数个数。因为<code>epoll_create</code>只有一个参数，因此使用的是<code>SYSCALL_DEFINE1</code>。</p>
<p>我们可以看到，如果传入的<code>size</code>小于或者等于<code>0</code>，则会返回<code>EINVAL</code>，表示参数错误。在早期的版本中，<code>epoll</code>是使用哈希表来管理注册的文件列表，需要传入一个<code>size</code>参数；但是现在的版本已经换做红黑树了，该参数已经没有具体的意义了，但是为了兼容性还是保留了下来，使用时传入一个任意大于0的数就好了。</p>
<p>接下来，我们看一下<code>do_epoll_create</code>的实现，该方法才是真正干活的主：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">NULL</span>;</span> <span class="comment">// eventpoll是epoll实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 前面说过epoll实例本身也是一个file</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// flags只支持设置EPOLL_CLEXEC</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配一个epoll实例</span></span><br><span class="line">	error = ep_alloc(&amp;ep);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配一个未使用的文件描述符fd</span></span><br><span class="line">	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = fd;</span><br><span class="line">		<span class="keyword">goto</span> out_free_ep;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取一个具有匿名inode的file，并设置file-&gt;f_op为eventpoll_fops</span></span><br><span class="line">    <span class="comment">// 同时设置file-&gt;private_date为ep</span></span><br><span class="line">	file = anon_inode_getfile(<span class="string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">				 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		error = PTR_ERR(file);</span><br><span class="line">		<span class="keyword">goto</span> out_free_fd;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 管理epoll实例和file</span></span><br><span class="line">	ep-&gt;file = file;</span><br><span class="line">    <span class="comment">// 设置fd对应的file</span></span><br><span class="line">	fd_install(fd, file);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    <span class="comment">// 创建失败，释放fd</span></span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    <span class="comment">// 创建失败，释放内存</span></span><br><span class="line">	ep_free(ep);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>do_epoll_create</code>接收一个<code>flags</code>参数，如果我们使用<code>epoll_create</code>来创建，默认是没有设置任何<code>flags</code>的。但是内核后面又添加了<code>epoll_create1</code>系统调用，使用该系统调用是可以设置<code>flags</code>的，具体可以查看<code>man</code>手册。</p>
<p>上面代码已经加了具体的注释了。在linux中正所谓一切皆文件，可以看到当我们创建epoll实例的时候，同时会创建一个<code>file</code>。其实<code>linux</code>的文件系统正是面向对象的思想，我们可以把<code>file</code>看成是一个统一的接口，具体的实现只需要把对应的方法实现注册到<code>file-&gt;f_op</code>中就好了，而且<code>file-&gt;private_data</code>保存了实际实现的指针。那些支持接口的语言，背后的实现无外乎也就是这样。</p>
<h5 id="epoll实例"><a href="#epoll实例" class="headerlink" title="epoll实例"></a>epoll实例</h5><p>既然是创建epoll实例，那我们是不是应该看一下这个epoll实例到底是什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">// 资源保护锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞在epoll_wait的等待队列</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wq; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// epoll实例本身实现了file-&gt;f_op-&gt;poll方法，对应的poll等待队列</span></span><br><span class="line">    <span class="comment">// 比如epoll实例本身也可以被添加到其他epoll实例中</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 就绪队列，保存已经就绪的事件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保护rdllist和ovflist的锁</span></span><br><span class="line">	<span class="keyword">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存储添加到epoll实例的fd的红黑树</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rbr</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当正在转移就绪队列中的事件到用户空间时，这段时期就绪的事件会被暂时加入该队列，等待转移结束再添加到rdllist。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建epoll实例的用户</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll本身也是一个文件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line">	<span class="keyword">int</span> visited;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">	<span class="comment">/* used to track busy poll napi_id */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> napi_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>epoll实例使用红黑树来管理注册的需要监听的fd，每个被添加到epoll实例的fd对应一个<code>epitem</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// 红黑树节点，linux内核中红黑树被广泛使用，因此有必要实现成通用结构，通过rb_node连接到rb-tree</span></span><br><span class="line">        <span class="comment">// 当需要访问具体结构体时，通过简单的指针运算以及类型转换就可以了</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于添加到epoll实例的就绪队列的链表节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将就绪列表中的事件转移到用户空间期间，新的就绪事件会先加入到epoll的ovflist；为什么不复用rdllink字段呢？因为同一个fd，可能还在就绪队列中，但是又有了新的就绪事件了，这时候它既在就绪队列中，也在ovflist中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该epitem关联的fd和file信息，用于红黑树中的比较；我们知道，红黑树是二叉搜索树，在查找的时候，是需要比较大小的</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of active wait queue attached to poll operations </span></span><br><span class="line">	<span class="keyword">int</span> nwait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List containing poll wait queues</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该epitem注册的epoll实例</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// used to link this item to the "struct file" items list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wakeup_source used when EPOLLWAKEUP is set </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该结构体保存epitem对应的fd和感兴趣的事件列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个<code>fd</code>被添加到epoll实例时，epoll实例会调用对应file的poll方法，poll方法有两个作用：</p>
<ul>
<li>设置callback，当文件有新的就绪事件产生时，调用该callback</li>
<li>返回文件当前的就绪事件</li>
</ul>
<p>而当我们从epoll实例移除一个fd时，需要从file中移除注册的callback。</p>
<p>注册callback，实际上就是添加到file的poll wait列表；而这个时候，也会把file的poll wait列表加入到epitem的pwdlist这个列表中。当需要移除注册的callback时，遍历epitem的pwdlist就好了。</p>
<p>接下来看一下 <code>epoll_filefd</code>以及在搜索红黑树时，是如果通过该结构体比较大小的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 对应file</span></span><br><span class="line">	<span class="keyword">int</span> fd;            <span class="comment">// 对应的fd</span></span><br><span class="line">&#125; __packed;            <span class="comment">// _packed设置内存对齐为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare RB tree keys */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ep_cmp_ffd</span><span class="params">(struct epoll_filefd *p1,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct epoll_filefd *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p1-&gt;file &gt; p2-&gt;file ? +<span class="number">1</span>:</span><br><span class="line">	        (p1-&gt;file &lt; p2-&gt;file ? <span class="number">-1</span> : p1-&gt;fd - p2-&gt;fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，比较的逻辑是：</p>
<ol>
<li>首先比较file的地址</li>
<li>如果属于同一个file，则比较fd；比如使用dup系统调用，就可以产生两个fd指向同一个file</li>
</ol>
<h5 id="添加fd到epoll实例"><a href="#添加fd到epoll实例" class="headerlink" title="添加fd到epoll实例"></a>添加fd到epoll实例</h5>
        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>