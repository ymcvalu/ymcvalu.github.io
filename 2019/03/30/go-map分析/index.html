<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        go map分析 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i> blog </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构定义"><span class="toc-text">结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map创建"><span class="toc-text">map创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map的访问"><span class="toc-text">map的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-text">get</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete"><span class="toc-text">delete</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-range"><span class="toc-text">for-range</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容"><span class="toc-text">扩容</span></a></li>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i> blog </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        go map分析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-03-30 19:43:26</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#go" title="go">go</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p><code>map</code>其实就是一个<code>hash table</code>，今天我们来看一下<code>go</code>中<code>map</code>的实现，相关代码位于<code>runtime/map.go</code>中。</p>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><p>我们首先来看一下<code>map</code>的相关结构定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// 当前map中存放的元素，我们可以通过内置函数`len`来获取</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// 当前map的backet数量为2^B，其中最大能够存放loadFactor * 2^B个元素，当超过这个阈值时就会进行扩容，loadFactor默认为13/2，这个值是全局定义的常量</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// 总的overflow的数量</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// bucket数组，长度为2^B，这里bucket实际是bmap</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 如果发生扩容，旧的buckets就会保存到oldbuckets，在后续的操作中会慢慢迁移到新的buckets中</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// 扩容时需要从原来的buckets将数据迁移到新的buckets中，该字段表示小于该数值的buckets当前都已经迁移完成</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// 如果map中保存的key和value都没有包含指针，那么gc时就不需要对buckets里面的内容进行扫描，但是每个bucket本质上是一个链表，buckets头部保存的是每个bucket链表的头节点，这时候会将每个链表的后续节点保存到该字段内，从而gc时可以对这些后续节点进行扫描，防止被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>map</code>的key和value，如果都没有包含指针，那么会对其进行优化，<code>gc</code>的时候就不需要去扫描每个键值对了</strong></p>
<p>上面<code>extra</code>字段对应的<code>mapextra</code>类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow    *[]*bmap <span class="comment">// 对应buckets</span></span><br><span class="line">	oldoverflow *[]*bmap <span class="comment">// 对应oldbuckets</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">	nextOverflow *bmap <span class="comment">// 分配bmap时，可能会预先分配一些，当需要时可以直接从这里获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说的，每个<code>bucket</code>实际上是一个<code>bmap</code>链表，而<code>hmap</code>中的<code>buckets</code>是一个<code>bmap</code>链表数组，这实际上就是<a href="https://en.wikipedia.org/wiki/Hash_table#Open_addressing" target="_blank" rel="noopener">开散列</a>。和普通的开散列不同的是，<strong>一个<code>bmap</code>中保存了8个键值对</strong>，下面来看一下<code>bmap</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="comment">// bucket实际上是一个bmap</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这里bucketCnt是一个全局声明的常量，大小为8，也就是限制每个bmap中保存8个键值对</span></span><br><span class="line">    <span class="comment">// 当判断一个key是否在当前bmap中时，会先获取这个key的hash的高8位，然后在tophash中查找是否有匹配的索引，如果有再进一步比较key是否相同，如果当前bmap中没有找到，则到下一个bmap中查找</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// tophash后面紧跟着保存在当前bmap中的8个key和8个value</span></span><br><span class="line">    <span class="comment">// 因为不同类型的key和value内存大小是不同的，这里需要在运行时根据指针运算来访问</span></span><br><span class="line">    <span class="comment">// 在bmap中是按照 `k1,k2,..,k8,v1,v2,...,v8` 这样来排列的，而不是按照直观上的`k1,v1,k2,v2,...,k8,v8`这样来排列，主要是为了减少内存对齐时额外的内存开销</span></span><br><span class="line">    <span class="comment">// 8个键值对之后还有一个overflow指针，用来链接下一个bmap，正如上面说的，每个bucket实际上是一个bmap链表，这里通过overflow链接的这些bmap被称为`overflow bucket`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为bmap链接下一个bmap的overflow指针在末尾，而不同类型的key和value的内存大小又不同，因此无法直接获取到下一个bmap的地址，前面说过，当key和value不包含指针的时候，gc时不需要扫描这些键值对；但是又需要扫描这些bmap，因此这种情况下会把这些bmap存到mapextra字段中的`overflow和oldoverflow中，这样gc时直接遍历这两个切片就好了。<br>那为什么不把overflow放到bmap头部呢？个人觉得可能是为了让内存访问更友好吧，连续的内存访问肯定更加高效。</p>
</blockquote>
<p>如上面<code>bmap</code>所见，键值对并没有显示声明出来，而是需要在运行时根据指针运算来访问，这里来看一下一个全局声明的常量<code>dataOffset</code>，这个常量在后续会经常看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    ...</span><br><span class="line">	dataOffset = unsafe.Offsetof(<span class="keyword">struct</span> &#123;</span><br><span class="line">		b bmap</span><br><span class="line">		v <span class="keyword">int64</span></span><br><span class="line">	&#125;&#123;&#125;.v)</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为<code>bmap</code>实际上只声明了一个<code>uint8</code>类型的数组，因此这里<code>v</code>字段的偏移量就是实际<code>bmap</code>中第一个<code>key</code>值的偏移量</p>
<p>这里假设<code>bmap</code>的地址是<code>bptr</code>，<code>key</code>的类型大小是<code>ksize</code>，<code>val</code>的类型大小是<code>vsize</code>，那么访问第<code>i</code>个<code>key</code>和<code>val</code>的地址可以通过下面公式计算（<code>i</code>从<code>0</code>开始计算）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ith key: bptr + dataOffset + i * ksize</span><br><span class="line">ith val: bptr + dataOffset + bucketCnt * ksize + i * vsize</span><br></pre></td></tr></table></figure>
<p>至此，我们对<code>map</code>的结构有了一个大体的了解，其键值对的存储结构大致可以用下图来描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    bucket数组         bmap中的overflow指向下一个bmap </span><br><span class="line">  实际上是bmap数组    这些由overflow引用的bucket被称作overflow bucket</span><br><span class="line">|-----------------|  |-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt;|k1,..,k8,v1,..,v8|-&gt; ...		  </span><br><span class="line">|-----------------|  |-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面可以看到，一个<code>bucket</code>实际上是一个<code>bmap</code>，而且<code>bmap</code>可以通过<code>overflow</code>指针来形成链表，这些通过<code>overflow</code>引用的<code>bmap</code>被称作<code>overflow bucket</code>，而<code>buckets</code>中<code>bmap</code>的称为<code>bucket</code>。<code>bucket</code>实际上也可以认为是整条<code>bmap</code>链表，比如扩容时的<code>bucket</code>迁移，实际上就是迁移整条<code>bmap</code>链表。</p>
</blockquote>
<h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><p>当我们使用<code>make</code>创建<code>map</code>时，可以指定一个<code>size</code>参数，当我们没有指定<code>size</code>时，或者<code>size</code>在编译时已知是一个不大于<code>8</code>的数值时（也就是size是一个常量），会通过<code>makemap_small</code>来创建一个<code>map</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makehmap_small implements Go map creation for make(map[k]v) and</span></span><br><span class="line"><span class="comment">// make(map[k]v, hint) when hint is known to be at most bucketCnt</span></span><br><span class="line"><span class="comment">// at compile time and the map needs to be allocated on the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap_small</span><span class="params">()</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">	h := <span class="built_in">new</span>(hmap)</span><br><span class="line">	h.hash0 = fastrand() <span class="comment">// 初始化hash seed</span></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过<code>makemap_small</code>创建的<code>map</code>，此时的<code>B</code>是0，<code>buckets</code>是<code>nil</code>，在第一次写入的时候才会去创建具体的<code>buckets</code></p>
<p>对应的，当我们指定了一个合适的<code>size</code>时，会通过另一个函数来创建<code>map</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makemap implements Go map creation for make(map[k]v, hint).</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果小于0或者过大，则设为0</span></span><br><span class="line">	<span class="keyword">if</span> hint &lt; <span class="number">0</span> || hint &gt; <span class="keyword">int</span>(maxSliceCap(t.bucket.size)) &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize Hmap</span></span><br><span class="line">    <span class="comment">// 编译器可能会进行优化，在栈上创建map，因此h可能不为空</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find size parameter which will hold the requested # of elements</span></span><br><span class="line">	B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 根据传入的size来计算B的大小，这里的B是buckets的数量，前文说过，map最多可以容纳 0.65*2^B 个键值对，当超过这个阈值时，会执行扩容</span></span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123; </span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate initial hash table</span></span><br><span class="line">	<span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line">	<span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        <span class="comment">// 创建bucket数组，这里可能会预先分配几个bmap，后续可以直接使用而不需要执行内存分配</span></span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建一个<code>map</code>时，如果<code>map</code>中要存储的键值对数据可以估计的话，最好在创建的时候指定好<code>size</code>，这样可以预先分配好<code>bucket</code>的数量。</p>
<h3 id="map的访问"><a href="#map的访问" class="headerlink" title="map的访问"></a>map的访问</h3><p>通常我们对<code>map</code>的访问有<code>get</code>、<code>set</code>、<code>delete</code>、和<code>for range</code>操作，在分析具体的实现下时，我们要先来了解一下如果定位一个<code>key</code>的位置，这里先不涉及在执行扩容时的场景。</p>
<p>我们再回顾一下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    bucket数组         bmap中的overflow指向下一个bmap </span><br><span class="line">  实际上是bmap数组    这些由overflow引用的bucket被称作overflow bucket</span><br><span class="line">|-----------------|  |-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt;|k1,..,k8,v1,..,v8|-&gt; ...		  </span><br><span class="line">|-----------------|  |-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br><span class="line">|k1,..,k8,v1,..,v8|-&gt; ...</span><br><span class="line">|-----------------|</span><br></pre></td></tr></table></figure>
<p>要定位一个<code>key</code>，我们需要先确定这个<code>key</code>是落在哪个<code>bucket</code>中，也就是哪一条<code>bmap</code>链表中，通过计算<code>key</code>的哈希值，然后通过<code>hash%bucket数量</code>的来定位 ，具体的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alg := t.key.alg <span class="comment">// 这里的t是map的类型描述</span></span><br><span class="line">hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0)) <span class="comment">// 计算hash值</span></span><br><span class="line">m := bucketMask(h.B) <span class="comment">// 这里的m为 1&lt;&lt;B-1</span></span><br><span class="line"><span class="comment">// 这里的hash&amp;m等价于求模操作</span></span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure>
<p>当定位到具体的<code>bucket</code>后，只需要从头开始遍历该<code>bmap</code>链表，因为<code>bmap</code>中有个<code>tophash</code>数组，保存了每个<code>key</code>对应的哈希值的高八位，因此我们不需要挨个对每个<code>key</code>进行比较，只需要先比较哈希值的高八位是否相同就行了，如果相同才接着比较<code>key</code>是否相等，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">top := tophash(hash) <span class="comment">// 取key的hash值的高八位</span></span><br><span class="line">	<span class="comment">// 这里b是一个bmap指针，如果当前bmap没有，则查找下一个bmap</span></span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123; </span><br><span class="line">        <span class="comment">// 遍历当前bmap，这里bucketCnt是常量8，限制一个bmap中最多只有8个键值对</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// 先比较哈希值高八位，如果不相等则continue</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 计算当前的key的位置</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="comment">// 是否间接存储（存储的是实际key的地址）</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 比较key是否相等</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				......</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>与<code>get</code>相关的方法有多个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val := m[key]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="function">// <span class="title">val</span>,<span class="title">has</span> := <span class="title">m</span>[<span class="title">key</span>]</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, <span class="keyword">bool</span>)</span> </span></span><br><span class="line"><span class="function">// <span class="title">for</span>-<span class="title">range</span>时，用于获取<span class="title">key</span>和<span class="title">val</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure>
<p>这三个方法大同小异，这里只分析第一个方法：</p>
<p>先看该函数的注释，如果<code>key</code>不存在时，返回的是对应的<code>val</code>类型的空值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span></span><br><span class="line"><span class="comment">// it will return a reference to the zero object for the value type if</span></span><br><span class="line"><span class="comment">// the key is not in the map.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The returned pointer may keep the whole map live, so don't</span></span><br><span class="line"><span class="comment">// hold onto it for very long.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果我们访问的map是nil或者map中没有存储内容，直接返回零值</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// map不是并发安全的，如果存在写操作则panic，因此我们需要在多个goroutine对map进行并发读写时，需要加锁保护</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map read and map write"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">// 获取buckets数组长度的掩码</span></span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 定位key所在的bucket</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 当前是否处于扩容操作，当发生扩容操作时，或重新分配buckets数组，并且需要将旧的buckets内的键值对迁移到新的buckets数组中，这个迁移过程不是一次性完成的而是分批完成的</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">       	<span class="comment">// 扩容操作有两种：第一种，如果是因为当前的键值对数量已经达到了阈值0.65*2^B，则会触发扩容，这时候新的buckets数组的数量为原来的2倍；第二种是当前键值对数量并没有达到阈值，但是当前存在太多的overflow bucket，可能是因为之前存储了太多的键值对，但是后面又被删除掉了，这时候有的bucket链表会比较长，但是实际上存储的键值对比较稀疏，这样会影响查找效率，这种情况会触发sameSizeGrow，即扩容时buckets数组长度与原来一致</span></span><br><span class="line">        <span class="comment">// 如果是前一种，则原先的buckets数量的掩码是m&gt;&gt;1</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 计算该key落在的oldbuckets中的哪个bucket中</span></span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">        <span class="comment">// 如果当前bucket还没有迁移，则在该bucket中查询，迁移操作是按照bucket为单位进行的</span></span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取哈希值高八位</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">    <span class="comment">// 遍历bmap链表</span></span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// 比较哈希值高八位</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 比较key是否相等</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 获取key对应的val，这里的计算公式在前面结构定义一节中已经说明过</span></span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">                <span class="comment">// 如果这里存储的是val的地址</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">					v = *((*unsafe.Pointer)(v))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p><code>set</code>操作对应的方法是<code>mapassign</code>，这个方法为指定的<code>key</code>分配一个用于存放<code>val</code>的槽，或者返回已经存在的槽，新的<code>val</code>直接写入这个槽中，即完成了<code>map</code>的<code>set</code>操作。</p>
<p>在写入时，因为可能该<code>key</code>已经存在，因此需要先遍历目标<code>bucket</code>的<code>bmap</code>链表，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// 不允许写入空map</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"assignment to entry in nil map"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果有并发写操作，直接panic</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">    <span class="comment">// 计算key的哈希值</span></span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line">	<span class="comment">// in which case we have not actually done a write.</span></span><br><span class="line">    <span class="comment">// 设置写标志</span></span><br><span class="line">	h.flags |= hashWriting</span><br><span class="line">	<span class="comment">// 如果buckets数组为空，则会创建一个长度为1的buckets数组</span></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 计算目标bucket在buckets数组中的索引</span></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 如果当前正在执行扩容操作，则会执行迁移操作，前面说过扩容时的迁移操作是分批进行的，而迁移是按照bucket为单位进行的，而触发迁移的时机是执行写操作</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// 该函数会执行迁移操作，迁移的目标是bucket%len_of_oldbuckets</span></span><br><span class="line">		growWork(t, h, bucket) </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 计算要写入的bucket</span></span><br><span class="line">	b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 计算哈希值高八位</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">	<span class="comment">// 在bmap中要插入的索引，如果前文所说，一个bmap最多可以有8个键值对</span></span><br><span class="line">	<span class="keyword">var</span> inserti *<span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// 要插入key的地址</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">    <span class="comment">// 对应的val的地址</span></span><br><span class="line">	<span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">    <span class="comment">// 因为前面已经执行过扩容操作，因此写入只需要对新的bucket进行操作</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历当前bmap</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// 高八位哈希值不相同</span></span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 对第一个遇到的空槽，设置为待定槽，因为可能在后续遍历中发现当前key已经存在，则直接返回对应的val就好了</span></span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == empty &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 这里说明哈希值高八位一致，因此需要比较key是否相等</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 如果不相等，继续遍历下一个</span></span><br><span class="line">			<span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果key已经存在，直接返回对应的val地址就好了</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate &#123;</span><br><span class="line">				typedmemmove(t.key, k, key)</span><br><span class="line">			&#125;</span><br><span class="line">			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">            <span class="comment">// goto大法好</span></span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 当前bmap没有找到对应的key，则继续遍历下一个bmap</span></span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123; <span class="comment">// 如果当前bucket已经遍历完成，则跳出</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 首先判断是否需要进行扩容：如果当前没有扩容操作正在执行并且数据达到阈值或者存在太多的bmap，则会触发扩容操作</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        <span class="comment">// 触发扩容操作，然后跳到开头重新执行上面流程</span></span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不需要扩容操作，并且没有可以使用的空槽，则需要分配一个新的overflow bucket，这里是分配在链表尾部，当前的b指向的就是整条bmap链表的最后一个节点</span></span><br><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">        <span class="comment">// 插入第一个槽中</span></span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		val = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// store new key/value at insert position</span></span><br><span class="line">    <span class="comment">// 设置key</span></span><br><span class="line">    <span class="comment">// 这里针对是否需要对key或者val进行间接存储的处理</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">		kmem := newobject(t.key)</span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">		insertk = kmem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">		vmem := newobject(t.elem)</span><br><span class="line">		*(*unsafe.Pointer)(val) = vmem</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	*inserti = top</span><br><span class="line">	h.count++	<span class="comment">// map中元素数据加1</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 检查写操作标志位</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 清除写操作</span></span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">	<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">		val = *((*unsafe.Pointer)(val))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>删除操作流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 设置写操作标志位</span></span><br><span class="line">   <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   alg := t.key.alg</span><br><span class="line">   hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line">   <span class="comment">// in which case we have not actually done a write (delete).</span></span><br><span class="line">   h.flags |= hashWriting</span><br><span class="line"></span><br><span class="line">   bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// 如果正在扩容，先执行迁移操作</span></span><br><span class="line">   <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">      growWork(t, h, bucket)</span><br><span class="line">   &#125;</span><br><span class="line">   b := (*bmap)(add(h.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">   top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">    <span class="comment">// 查找要删除的可以，因为前面已经执行了迁移操作，因此这里只需要在新的bucket中查找即可</span></span><br><span class="line">   <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">         <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">         k2 := k</span><br><span class="line">         <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">            k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> !alg.equal(key, k2) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 执行清除操作</span></span><br><span class="line">         <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">         <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">            *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">            memclrHasPointers(k, t.key.size)</span><br><span class="line">         &#125;</span><br><span class="line">         v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">         <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">            *(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">            memclrHasPointers(v, t.elem.size)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(v, t.elem.size)</span><br><span class="line">         &#125;</span><br><span class="line">         b.tophash[i] = empty <span class="comment">// 将tophash中的值设为empty，表示空槽</span></span><br><span class="line">         h.count-- <span class="comment">// 数量减一</span></span><br><span class="line">         <span class="keyword">break</span> search</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">"concurrent map writes"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h5><p>执行<code>for-range</code>操作时，需要一个迭代器，我们先来看迭代器的声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A hash iteration structure.</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	key         unsafe.Pointer <span class="comment">// key值，nil表示迭代结束</span></span><br><span class="line">	value       unsafe.Pointer <span class="comment">// val值</span></span><br><span class="line">	t           *maptype</span><br><span class="line">	h           *hmap</span><br><span class="line">	buckets     unsafe.Pointer <span class="comment">// bucket ptr at hash_iter initialization time</span></span><br><span class="line">	bptr        *bmap          <span class="comment">// 当前正在迭代的buckete的指针</span></span><br><span class="line">	overflow    *[]*bmap       <span class="comment">// keeps overflow buckets of hmap.buckets alive</span></span><br><span class="line">	oldoverflow *[]*bmap       <span class="comment">// keeps overflow buckets of hmap.oldbuckets alive</span></span><br><span class="line">	startBucket <span class="keyword">uintptr</span>        <span class="comment">// 记录这次迭代从哪个bucket开始</span></span><br><span class="line">	offset      <span class="keyword">uint8</span>          <span class="comment">// 记录这次迭代从hmap中的哪个offset开始</span></span><br><span class="line">	wrapped     <span class="keyword">bool</span>           <span class="comment">// already wrapped around from end of bucket array to beginning</span></span><br><span class="line">	B           <span class="keyword">uint8</span></span><br><span class="line">	i           <span class="keyword">uint8</span></span><br><span class="line">	bucket      <span class="keyword">uintptr</span></span><br><span class="line">	checkBucket <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hiter</code>的创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	it.t = t <span class="comment">// 记录map类型信息</span></span><br><span class="line">	it.h = h <span class="comment">// 引用map</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// grab snapshot of bucket state</span></span><br><span class="line">	it.B = h.B <span class="comment">// 记录当前的B</span></span><br><span class="line">	it.buckets = h.buckets <span class="comment">// 记录当前的buckets</span></span><br><span class="line">    <span class="comment">// 如果当前map中的键值对没有指针</span></span><br><span class="line">	<span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Allocate the current slice and remember pointers to both current and old.</span></span><br><span class="line">		<span class="comment">// This preserves all relevant overflow buckets alive even if</span></span><br><span class="line">		<span class="comment">// the table grows and/or overflow buckets are added to the table</span></span><br><span class="line">		<span class="comment">// while we are iterating.</span></span><br><span class="line">		h.createOverflow()</span><br><span class="line">		it.overflow = h.extra.overflow</span><br><span class="line">		it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// decide where to start</span></span><br><span class="line">    <span class="comment">// 这里随机选举一个开始迭代的位置，因此我们对map进行for-range操作，每次输出的序列都是不同的</span></span><br><span class="line">	r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">	<span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">		r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置开始的bucket和offset</span></span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">	it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前迭代的bucket索引</span></span><br><span class="line">	it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置迭代标志位</span></span><br><span class="line">	<span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">		atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行next操作</span></span><br><span class="line">	mapiternext(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mapiternext</code>方法用于推进迭代器前进到下一个键值对，对应逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">	h := it.h</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"concurrent map iteration and map write"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t := it.t</span><br><span class="line">	bucket := it.bucket</span><br><span class="line">	b := it.bptr <span class="comment">// 当前正在遍历的bucket</span></span><br><span class="line">	i := it.i</span><br><span class="line">	checkBucket := it.checkBucket</span><br><span class="line">	alg := t.key.alg</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123; <span class="comment">// 如果it.bptr还没有初始化，需要根据it.bucket进行初始化，第一次执行或者每次遍历完一个bucket都会清空bptr</span></span><br><span class="line">		<span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">			<span class="comment">// end of iteration</span></span><br><span class="line">			it.key = <span class="literal">nil</span></span><br><span class="line">			it.value = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果正在执行扩容，并且迭代是在扩容之后开始的，这时候如果旧的bucket还没有迁移到新的bucket中，那么需要到旧的bucket中遍历</span></span><br><span class="line">		<span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 获取当前要迭代的bucket对应的oldbucket</span></span><br><span class="line">			oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">			b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            <span class="comment">// 如果oldbucket中的元素还没有迁移到新的bucket中</span></span><br><span class="line">			<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">				checkBucket = bucket <span class="comment">// oldbucket中的键值对迁移到新的bucket中时，可能会迁移到两个bucket中，比如原来长度是4，hash%4等于3，限制长度是8，hash%8可能为4也可能为7，这里的checkBucket记录当前正在遍历h.buckets数组中的哪个bucket，用于后面的判断</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已经迁移完成，直接在新的bucket中遍历</span></span><br><span class="line">				b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">				checkBucket = noCheck</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前没有扩容操作，直接在新的bucket中遍历</span></span><br><span class="line">			b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">			checkBucket = noCheck</span><br><span class="line">		&#125;</span><br><span class="line">		bucket++ <span class="comment">// 下一次遍历的bucket的索引</span></span><br><span class="line">        <span class="comment">// 因为开始迭代的bucket位置是随机的，如果越界了，从第一个bucket开始</span></span><br><span class="line">		<span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">			bucket = <span class="number">0</span></span><br><span class="line">			it.wrapped = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 遍历bmap中键值对</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">        <span class="comment">// 计算开始遍历的偏移位置</span></span><br><span class="line">		offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 如果空槽，则跳过</span></span><br><span class="line">		<span class="keyword">if</span> b.tophash[offi] == empty || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">			k = *((*unsafe.Pointer)(k))</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 获取val</span></span><br><span class="line">		v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">        <span class="comment">// 如果正在执行扩容，并且正在遍历的bucket还没有迁移完成，并且扩容是由于键值对达到阈值触发的，这时候扩容后的buckets数组的长度为原来的两倍，原来的一个bucket中的键值对迁移时会迁移到新的两个bucket中，因为目标bucket是通过哈希取模计算的，而这时候bucket数组长度扩大了两倍，比如原理数组长度是4，取模后是3，现在数组长度是8，取模后可能为3也可能为7</span></span><br><span class="line">		<span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 如果key==key，正常都是走这个逻辑</span></span><br><span class="line">			<span class="keyword">if</span> t.reflexivekey || alg.equal(k, k) &#123; </span><br><span class="line">				<span class="comment">// 如果当前的key不是落在当前的bucket中的，比如现在正在遍历的bucket为3，但是key现在的hash是7，以后迁移时将迁移到索引为7的bucket中，因此这个时候应该跳过这个key</span></span><br><span class="line">				hash := alg.hash(k, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">				<span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// key != key的情况，比如math.NaN() != math.NaN()</span></span><br><span class="line">				<span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="keyword">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 走到这里，可能有一种情况，在迭代开始之后发生了扩容（比如我们在for-range里面插入新的键值对，这时候触发了迁移），这时候迭代的是扩容之前的键值对，即只会迭代当前的oldbuckets里面键值对，这时候如果这些键值对还没有发生迁移或者说key是不可比较的，比如key为math.NAN()，因为key!=key，因此这个key不会被删除或者更新，可以直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">			!(t.reflexivekey || alg.equal(k, k)) &#123;</span><br><span class="line">			it.key = k</span><br><span class="line">			<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">				v = *((*unsafe.Pointer)(v))</span><br><span class="line">			&#125;</span><br><span class="line">			it.value = v</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 走到这里说明发生了迁移，使用mapaccessK来获取</span></span><br><span class="line">			rk, rv := mapaccessK(t, h, k)</span><br><span class="line">			<span class="keyword">if</span> rk == <span class="literal">nil</span> &#123; <span class="comment">// 已经被删除了</span></span><br><span class="line">				<span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">			&#125;</span><br><span class="line">			it.key = rk</span><br><span class="line">			it.value = rv</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 更新迭代器状态</span></span><br><span class="line">		it.bucket = bucket</span><br><span class="line">		<span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">			it.bptr = b</span><br><span class="line">		&#125;</span><br><span class="line">		it.i = i + <span class="number">1</span></span><br><span class="line">		it.checkBucket = checkBucket</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 当前bmap遍历完成，遍历下一个bmap，如果已经是bmap链表的最后一个节点，则返回的b为nil，这时候会触发遍历下一个bucket</span></span><br><span class="line">	b = b.overflow(t)</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当写入时，如果当前<code>bucket</code>已经满了，则会触发扩容检查，如果当前不处于扩容状态并且满足：</p>
<ul>
<li>当前键值对个数已经达到 <code>0.65*2^B</code></li>
<li>当前<code>overflow bucket</code>数量达到<code>1&lt;&lt;(B&amp;15)</code>，这里的<code>B</code>如果大于15，按照15计算</li>
</ul>
<p>下面看一下开始扩容的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If we've hit the load factor, get bigger.</span></span><br><span class="line">	<span class="comment">// Otherwise, there are too many overflow buckets,</span></span><br><span class="line">	<span class="comment">// so keep the same number of buckets and "grow" laterally.</span></span><br><span class="line">	bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 如果键值对数量没有达到阈值，则说明是overflow bucket数量过多触发的</span></span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span> <span class="comment">// 这里将bigger设置成了0</span></span><br><span class="line">		<span class="comment">// 设置标志位，用于后续区分是哪种情况触发的扩容</span></span><br><span class="line">		<span class="comment">// 如果是overflow bucket数量过多触发的，实际上并不会增加bucket的数量</span></span><br><span class="line">		<span class="comment">// 因此称作sameSizeGrow</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存原来的buckets到oldbuckets</span></span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	<span class="comment">// 分配新的buckets</span></span><br><span class="line">	<span class="comment">// 如果是键值对达到阈值触发的扩容，bucket数量为原来的2倍，也就是扩展buckets数组</span></span><br><span class="line">	<span class="comment">// 否则维持原来的数量</span></span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 设置更新迭代标志位</span></span><br><span class="line">	flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">		flags |= oldIterator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// commit the grow (atomic wrt gc)</span></span><br><span class="line">    <span class="comment">// 更新hmap字段</span></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span></span><br><span class="line">	h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Promote current overflow buckets to the old generation.</span></span><br><span class="line">		<span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">"oldoverflow is not nil"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the actual copying of the hash table data is done incrementally</span></span><br><span class="line">	<span class="comment">// by growWork() and evacuate().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下<code>bucket</code>的迁移操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 迁移正在使用的bucket对应的oldbucket的数据</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 继续对h.nevacuate对应的bucket进行迁移，让迁移尽快完成</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，一次<code>growwork</code>最多可以迁移两个<code>bucket</code>，这样可以尽早完成扩容之后的迁移</p>
<p>接着看一下<code>evacuate</code>的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算要进行迁移的bucket</span></span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets() <span class="comment">// 获取oldbuckets数组的长度</span></span><br><span class="line">    <span class="comment">// 如果还没有执行过迁移</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="comment">// 一个oldbucket中的key可能迁移到两个新的bucket中，这里使用x来表示低位目标bucket，y表示高位目标bucket</span></span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 低位目标bucket的索引和当前要迁移的oldbucket的索引一致</span></span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.v = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="comment">// 如果是sameSizeGrow，buckets长度没有变化，则不会有高位目标bucket</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="comment">// Only calculate y pointers if we're growing bigger.</span></span><br><span class="line">			<span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">			y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 计算高位目标bucket</span></span><br><span class="line">			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">			y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">			y.v = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历bucket对应的bmap链表</span></span><br><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				<span class="keyword">if</span> top == empty &#123; <span class="comment">// 空槽，没有键值对</span></span><br><span class="line">					b.tophash[i] = evacuatedEmpty</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">					throw(<span class="string">"bad map state"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">					k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">                <span class="comment">// 不是sameSizeGrow，说明可能会迁移到高位目标bucket</span></span><br><span class="line">				<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">					hash := t.key.alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">                    <span class="comment">// 存在迭代器，并且key!=key(NaNs)，一般不会走这个分支</span></span><br><span class="line">					<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey &amp;&amp; !t.key.alg.equal(k2, k2) &#123;</span><br><span class="line">						useY = top &amp; <span class="number">1</span></span><br><span class="line">						top = tophash(hash)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 比如hash是7，oldbuckets长度是4，现在是8，原来bucket是3，现在应该迁移到7这个bucket，这种情况hash&amp;newbit=newbit    </span></span><br><span class="line">						<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">							useY = <span class="number">1</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 这里是对全局常量进行检查：evacuatedY=evacuatedX+1</span></span><br><span class="line">                <span class="comment">// evacuatedX标记迁移到低位目标bucket</span></span><br><span class="line">                <span class="comment">// evacuatedY标记迁移到高位目标bucket</span></span><br><span class="line">				<span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">					throw(<span class="string">"bad evacuatedN"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 对当前槽进行标记，表示已经完成迁移</span></span><br><span class="line">				b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">                <span class="comment">// 根据是否迁移到高位bucket选择目标bucket</span></span><br><span class="line">				dst := &amp;xy[useY]                 <span class="comment">// evacuation destination</span></span><br><span class="line">				<span class="comment">// 如果当前bmap满了，创建新的bmap</span></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.v = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 执行键值对迁移</span></span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.key, dst.k, k) <span class="comment">// copy value</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.elem, dst.v, v)</span><br><span class="line">				&#125;</span><br><span class="line">              	<span class="comment">// 更新迁移目标状态</span></span><br><span class="line">				dst.i++</span><br><span class="line">				<span class="comment">// These updates might push these pointers past the end of the</span></span><br><span class="line">				<span class="comment">// key or value arrays.  That's ok, as we have the overflow pointer</span></span><br><span class="line">				<span class="comment">// at the end of the bucket to protect against pointing past the</span></span><br><span class="line">				<span class="comment">// end of the bucket.</span></span><br><span class="line">				dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">				dst.v = add(dst.v, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Unlink the overflow buckets &amp; clear key/value to help GC.</span></span><br><span class="line">        <span class="comment">// 如果不存在对oldbuckets的迭代器并且键值对中包含指针，在oldbuckets清除当前迁移的bucket，帮助尽快gc掉这些没有用的内存</span></span><br><span class="line">		<span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">			b := add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize))</span><br><span class="line">			<span class="comment">// Preserve b.tophash because the evacuation</span></span><br><span class="line">			<span class="comment">// state is maintained there.</span></span><br><span class="line">			ptr := add(b, dataOffset)</span><br><span class="line">			n := <span class="keyword">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">			memclrHasPointers(ptr, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前迁移的bucket等于h.nevacuate则更新h.nevacuate的值</span></span><br><span class="line">    <span class="comment">// 如果所有bucket都已经迁移完成，则消除扩容状态</span></span><br><span class="line">	<span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">		advanceEvacuationMark(h, t, newbit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>