<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        go的接口值 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i>  </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iface"><span class="toc-text">iface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过汇编看iface"><span class="toc-text">通过汇编看iface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口类型转换"><span class="toc-text">接口类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口类型断言"><span class="toc-text">接口类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i>  </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        go的接口值
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-05-11 00:03:35</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#go" title="go">go</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#interface" title="interface">interface</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h1 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h1><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// layout of Itab known to compilers</span></span><br><span class="line"><span class="comment">// allocated in non-garbage-collected memory</span></span><br><span class="line"><span class="comment">// Needs to be in sync with</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.</span></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter *interfacetype <span class="comment">// 接口类型</span></span><br><span class="line">	_type *_type         <span class="comment">// 实际类型</span></span><br><span class="line">	hash  <span class="keyword">uint32</span>         <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span>        <span class="comment">// 4字节填充，与上面的4字节hash凑成8字节，与n内存对齐相关</span></span><br><span class="line">    <span class="comment">// itab末尾是实现方法的引用，如果多余1个，则其余方法引用紧跟itab内存之后分配</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type <span class="comment">// 接口类型信息</span></span><br><span class="line">	pkgpath name	 </span><br><span class="line">	mhdr    []imethod <span class="comment">// 接口声明的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,</span></span><br><span class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and</span></span><br><span class="line"><span class="comment">// ../reflect/type.go:/^type.rtype.</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">	ptrdata    <span class="keyword">uintptr</span>  <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">	hash       <span class="keyword">uint32</span>   <span class="comment">// 类型hash值</span></span><br><span class="line">	tflag      tflag    <span class="comment">// 类型相关一些flag，可以在反射包中使用</span></span><br><span class="line">	align      <span class="keyword">uint8</span>    <span class="comment">// 内存对齐</span></span><br><span class="line">	fieldalign <span class="keyword">uint8</span>    <span class="comment">// 字段对齐</span></span><br><span class="line">	kind       <span class="keyword">uint8</span>    <span class="comment">// 类型kind</span></span><br><span class="line">	alg        *typeAlg <span class="comment">// 类型的hash和equal方法</span></span><br><span class="line">	<span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">	<span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">	<span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">	gcdata    *<span class="keyword">byte</span></span><br><span class="line">	str       nameOff   <span class="comment">// offset of name</span></span><br><span class="line">	ptrToThis typeOff   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>_type</code>是最基本的类型信息，而实际我们声明的类型还有包含字段、方法等信息，查看下面代码，可以看到<code>_type</code>只是实际类型结构的一部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">	pkgpath nameOff</span><br><span class="line">	mcount  <span class="keyword">uint16</span> <span class="comment">// number of methods</span></span><br><span class="line">	xcount  <span class="keyword">uint16</span> <span class="comment">// number of exported methods</span></span><br><span class="line">	moff    <span class="keyword">uint32</span> <span class="comment">// offset from this uncommontype to [mcount]method</span></span><br><span class="line">	_       <span class="keyword">uint32</span> <span class="comment">// unused</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *_type)</span> <span class="title">uncommon</span><span class="params">()</span> *<span class="title">uncommontype</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> t.tflag&amp;tflagUncommon == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t.kind &amp; kindMask &#123;</span><br><span class="line">	<span class="keyword">case</span> kindStruct:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			structtype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindPtr:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			ptrtype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindFunc:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			functype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindSlice:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			slicetype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindArray:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			arraytype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindChan:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			chantype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindMap:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			maptype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">case</span> kindInterface:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			interfacetype</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">type</span> u <span class="keyword">struct</span> &#123;</span><br><span class="line">			_type</span><br><span class="line">			u uncommontype</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;(*u)(unsafe.Pointer(t)).u</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过汇编看iface"><a href="#通过汇编看iface" class="headerlink" title="通过汇编看iface"></a>通过汇编看iface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r io.Reader = Arr&#123;&#125;</span><br><span class="line">	r.Read(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arr []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Arr)</span> <span class="title">Read</span><span class="params">(n []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go tool compile -S main.go &gt; main.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	0x0000 00000 (test.go:7)	TEXT	&quot;&quot;.main(SB), $88-0</span><br><span class="line">	...</span><br><span class="line">	0x0024 00036 (test.go:8)	LEAQ	type.[0]uint8(SB), AX  // newobject方法参数</span><br><span class="line">	0x002b 00043 (test.go:8)	MOVQ	AX, (SP)</span><br><span class="line">	0x002f 00047 (test.go:8)	CALL	runtime.newobject(SB)</span><br><span class="line">	0x0034 00052 (test.go:8)	MOVQ	8(SP), AX // 这里把返回的指针保存到AX</span><br><span class="line">	0x0039 00057 (test.go:8)	MOVQ	AX, &quot;&quot;..autotmp_1+56(SP) // Arr对象</span><br><span class="line">	0x003e 00062 (test.go:8)	XORPS	X0, X0</span><br><span class="line">	0x0041 00065 (test.go:8)	MOVUPS	X0, &quot;&quot;..autotmp_1+64(SP)</span><br><span class="line">	0x0046 00070 (test.go:8)	LEAQ	go.itab.&quot;&quot;.Arr,io.Reader(SB), AX // itab</span><br><span class="line">	0x004d 00077 (test.go:8)	MOVQ	AX, (SP)</span><br><span class="line">	0x0051 00081 (test.go:8)	LEAQ	&quot;&quot;..autotmp_1+56(SP), AX // Arr对象指针</span><br><span class="line">	0x0056 00086 (test.go:8)	MOVQ	AX, 8(SP)</span><br><span class="line">	0x005b 00091 (test.go:8)	CALL	runtime.convT2Islice(SB) // 生成iface</span><br><span class="line">	0x0060 00096 (test.go:8)	MOVQ	24(SP), AX // 接口的data字段</span><br><span class="line">	0x0065 00101 (test.go:8)	MOVQ	16(SP), CX // 接口的tab字段，即itab表</span><br><span class="line">	0x006a 00106 (test.go:9)	MOVQ	24(CX), CX // itab的24~32为实际方法Read地址</span><br><span class="line">	// 110~127构造一个 Arr&#123;0 0 data&#125;结构，来调用方法Read</span><br><span class="line">	// 实际上方法的接收者就是方法第一个参数</span><br><span class="line">	0x006e 00110 (test.go:9)	MOVQ	$0, 8(SP) // 0</span><br><span class="line">	0x0077 00119 (test.go:9)	XORPS	X0, X0 </span><br><span class="line">	0x007a 00122 (test.go:9)	MOVUPS	X0, 16(SP) // 0</span><br><span class="line">	0x007f 00127 (test.go:9)	MOVQ	AX, (SP) // data</span><br><span class="line">	0x0083 00131 (test.go:9)	CALL	CX // 调用Read方法</span><br><span class="line">	0x008e 00142 (test.go:10)	RET</span><br><span class="line"></span><br><span class="line">// 有些itab在编译期间可以自动生成</span><br><span class="line">// 可能在a文件声明了Arr，b文件中声明了接口Reader，在C包文件c和D包文件d都用到了Arr初始化接口Reader，</span><br><span class="line">// 则会在c文件和d文件都生成这个itab表，因此声明为dupok，由链接器任意选择一个</span><br><span class="line">go.itab.&quot;&quot;.Arr,io.Reader SRODATA dupok size=32</span><br><span class="line">	0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">	0x0010 d6 ed 1d 4e 00 00 00 00 00 00 00 00 00 00 00 00  ...N............</span><br><span class="line">	rel 0+8 t=1 type.io.Reader+0</span><br><span class="line">	rel 8+8 t=1 type.&quot;&quot;.Arr+0</span><br><span class="line">	rel 24+8 t=1 &quot;&quot;.(*Arr).Read+0 // 这里rel告诉链接器要将24~32的符号引用替换成方法的逻辑地址</span><br></pre></td></tr></table></figure>
<p>可以看到，实现接口的方法引用列表会保存在itab末尾，调用时，需要先计算具体调用函数的偏移获取实际方法引用</p>
<p>上面生成接口值的时候，调用了<code>runtime.convT2Islice</code>方法，其实在<code>runtime.iface.go</code>中声明了一系列<code>runtime.convT2IXXX</code>的方法，表示将<code>XXX</code>类型的值转换成一个接口值，因为这里的例子中，<code>Arr</code>的<code>Kind</code>是<code>slice</code>，因此调用的是<code>runtime.convT2Islice</code>这个方法。</p>
<p>下面我们来看一下<code>convT2Islice</code>和<code>convT2I</code>这两个方法的实现。</p>
<p>先来看<code>convT2Islice</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数elem实际上是一个slice的指针</span></span><br><span class="line"><span class="comment">// 将一个实际类型的值转换成接口值这种情况，itab由编译器自动生成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2Islice</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type <span class="comment">//这里的_type就是该接口背后的真实数据类型</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2Islice))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(elem, t.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 如果切片的底层数组是nil</span></span><br><span class="line">	<span class="keyword">if</span> v := *(*slice)(elem); <span class="keyword">uintptr</span>(v.array) == <span class="number">0</span> &#123;</span><br><span class="line">		x = unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = mallocgc(t.size, t, <span class="literal">true</span>) <span class="comment">// 分配一个slice</span></span><br><span class="line">		*(*slice)(x) = *(*slice)(elem) <span class="comment">// 赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x <span class="comment">// 返回的接口值中的data指向的内存是elem的拷贝</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是<code>convT2I</code>，这个是比较通用的转换方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的elem是要转换成接口值的实际值的指针</span></span><br><span class="line"><span class="comment">// 由实际类型转换成接口类型的情况，itab由编译器自动生成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type </span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(elem, t.size)</span><br><span class="line">	&#125;</span><br><span class="line">	x := mallocgc(t.size, t, <span class="literal">true</span>) <span class="comment">// 这里根据*elem的大小分配一块内存</span></span><br><span class="line">	typedmemmove(t, x, elem) <span class="comment">// 内存拷贝</span></span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们把一个<strong>非指针值</strong>赋给一个接口类型的变量时，就会调用该方法。<strong>这里我们也可以看到，<code>iface.data</code>不是直接指向接口背后的实际值，而是指向其拷贝，因为这个原因，也就很好理解为什么方法接收者是指针的话，值类型就不会实现对应的接口类型了，因为访问的根本不是同一个变量。</strong></p>
<p>而当把一个指针值赋给一个接口类型的变量呢？编译器会直接生成代码，这个时候<code>iface.data</code>就是该指针值，我们可以写个小<code>demo</code>验证一下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  <span class="keyword">uintptr</span></span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="keyword">struct</span> &#123;</span><br><span class="line">		T <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	pi := <span class="keyword">interface</span>&#123;&#125;(&amp;n)</span><br><span class="line">	vi := <span class="keyword">interface</span>&#123;&#125;(n)</span><br><span class="line"></span><br><span class="line">	_pi := *(*eface)(unsafe.Pointer(&amp;pi))</span><br><span class="line">	_vi := *(*eface)(unsafe.Pointer(&amp;vi))</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%p %p %p\n"</span>, &amp;n, _pi.data, _vi.data) <span class="comment">// 0xc000060090 0xc000060090 0x597500</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中我们使用空接口，实际上空接口对应的定义<code>eface</code>和<code>iface</code>的差别只有第一个字段，因为它没有方法表，直接存储的就是值的类型。我们可以看到，接口值<code>vi</code>实际存储的是变量<code>n</code>的地址，而<code>vi.data</code>此时存的就是<code>n</code>的地址。<br>看一下对应的汇编片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	type.struct &#123; T int &#125;(SB), AX</span><br><span class="line">MOVQ	AX, (SP)</span><br><span class="line">CALL	runtime.newobject(SB)  // 代码里面用的unsafe.Pointer，因为传到fmt.Printf里面，逃逸分析认为该变量逃逸了</span><br><span class="line">MOVQ	8(SP), AX              // newobject返回的地址</span><br><span class="line">MOVQ	AX, &quot;&quot;..autotmp_41+80(SP) // 保存到栈上的临时变量中</span><br><span class="line">LEAQ	type.*struct &#123; T int &#125;(SB), CX  // *struct&#123;T int&#125;的 _type</span><br><span class="line">MOVQ	CX, &quot;&quot;.pi+88(SP)                // 设置pi的 _type</span><br><span class="line">MOVQ	AX, &quot;&quot;.pi+96(SP)                //  设置pi的data，这里data就是n的地址</span><br></pre></td></tr></table></figure></p>
<h3 id="接口类型转换"><a href="#接口类型转换" class="headerlink" title="接口类型转换"></a>接口类型转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">   tab := i.tab</span><br><span class="line">   <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">      r.tab = tab</span><br><span class="line">      r.data = i.data</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</span><br><span class="line">   r.data = i.data</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将接口值A强制转换成接口B时，需要满足：接口A的方法集包含或者等于接口B的方法集</strong></p>
<p>接口值之间的类型转换，不会考虑实际类型的方法集，而是简单的对接口的方法集进行判断，这个在编译时就可以进行检查</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.ReadCloser = XXX&#123;&#125;</span><br><span class="line">r.Read(<span class="literal">nil</span>)</span><br><span class="line">_ = io.Reader(r) <span class="comment">// ok</span></span><br><span class="line">_ = io.ReadCloser(r) <span class="comment">// ok</span></span><br><span class="line">_ = io.Writer(r) <span class="comment">// no</span></span><br><span class="line"><span class="keyword">var</span> rc io.Reader = XXX&#123;&#125;</span><br><span class="line">_ = io.ReaderCloser(rc) <span class="comment">// no</span></span><br></pre></td></tr></table></figure>
<h3 id="接口类型断言"><a href="#接口类型断言" class="headerlink" title="接口类型断言"></a>接口类型断言</h3><p><strong>接口断言：根据接口值的实际类型，判断是否实现了目标接口</strong></p>
<p>类型断言时，可能需要在运行时动态生成itab</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</span><br><span class="line">   tab := i.tab</span><br><span class="line">   <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// explicit conversions require non-nil interface value.</span></span><br><span class="line">      <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="literal">nil</span>, <span class="literal">nil</span>, &amp;inter.typ, <span class="string">""</span>&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 如果目标接口类型就是当前接口类型，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> tab.inter == inter &#123;</span><br><span class="line">      r.tab = tab</span><br><span class="line">      r.data = i.data</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   r.tab = getitab(inter, tab._type, <span class="literal">false</span>) <span class="comment">// 获取itab，如果失败直接panic</span></span><br><span class="line">   r.data = i.data</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I2</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface, b <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	tab := i.tab</span><br><span class="line">	<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tab.inter != inter &#123;</span><br><span class="line">		tab = getitab(inter, tab._type, <span class="literal">true</span>) <span class="comment">// true表示容忍失败</span></span><br><span class="line">		<span class="keyword">if</span> tab == <span class="literal">nil</span> &#123; <span class="comment">// 不符合，返回false</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.tab = tab</span><br><span class="line">	r.data = i.data</span><br><span class="line">	b = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="keyword">bool</span>)</span> *<span class="title">itab</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(inter.mhdr) == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"internal error - misuse of itab"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// easy case</span></span><br><span class="line">	<span class="keyword">if</span> typ.tflag&amp;tflagUncommon == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> canfail &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		name := inter.typ.nameOff(inter.mhdr[<span class="number">0</span>].name)</span><br><span class="line">		<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="literal">nil</span>, typ, &amp;inter.typ, name.name()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m *itab</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, look in the existing table to see if we can find the itab we need.</span></span><br><span class="line">	<span class="comment">// This is by far the most common case, so do it without locks.</span></span><br><span class="line">	<span class="comment">// Use atomic to ensure we see any previous writes done by the thread</span></span><br><span class="line">	<span class="comment">// that updates the itabTable field (with atomic.Storep in itabAdd).</span></span><br><span class="line">    <span class="comment">// 先查表是否已经存在需要的itab</span></span><br><span class="line">	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable)))</span><br><span class="line">	<span class="keyword">if</span> m = t.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> finish</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Not found.  Grab the lock and try again.</span></span><br><span class="line">	lock(&amp;itabLock)</span><br><span class="line">    <span class="comment">// 双重锁检查</span></span><br><span class="line">	<span class="keyword">if</span> m = itabTable.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line">		unlock(&amp;itabLock)</span><br><span class="line">		<span class="keyword">goto</span> finish</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Entry doesn't exist yet. Make a new entry &amp; add it.</span></span><br><span class="line">    <span class="comment">// 分配itab内存，itab的内存分配在gc堆之外，不会被垃圾扫描、回收</span></span><br><span class="line">	m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="keyword">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">	m.inter = inter</span><br><span class="line">	m._type = typ</span><br><span class="line">	m.init() <span class="comment">// 初始化</span></span><br><span class="line">	itabAdd(m) <span class="comment">// 添加到itabTable中，后续直接查表，不需要重新构造</span></span><br><span class="line">	unlock(&amp;itabLock)</span><br><span class="line">finish:</span><br><span class="line">	<span class="keyword">if</span> m.fun[<span class="number">0</span>] != <span class="number">0</span> &#123; <span class="comment">// itab初始化成功</span></span><br><span class="line">		<span class="keyword">return</span> m</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> canfail &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this can only happen if the conversion</span></span><br><span class="line">	<span class="comment">// was already done once using the , ok form</span></span><br><span class="line">	<span class="comment">// and we have a cached negative result.</span></span><br><span class="line">	<span class="comment">// The cached result doesn't record which</span></span><br><span class="line">	<span class="comment">// interface function was missing, so initialize</span></span><br><span class="line">	<span class="comment">// the itab again to get the missing function name.</span></span><br><span class="line">	<span class="built_in">panic</span>(&amp;TypeAssertionError&#123;concrete: typ, asserted: &amp;inter.typ, missingMethod: m.init()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// init fills in the m.fun array with all the code pointers for</span></span><br><span class="line"><span class="comment">// the m.inter/m._type pair. If the type does not implement the interface,</span></span><br><span class="line"><span class="comment">// it sets m.fun[0] to 0 and returns the name of an interface function that is missing.</span></span><br><span class="line"><span class="comment">// It is ok to call this multiple times on the same m, even concurrently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *itab)</span> <span class="title">init</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	inter := m.inter</span><br><span class="line">	typ := m._type</span><br><span class="line">	x := typ.uncommon() </span><br><span class="line"></span><br><span class="line">	<span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line">	<span class="comment">// and interface names are unique,</span></span><br><span class="line">	<span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line">	<span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">    <span class="comment">// 接口和类型的方法列表是按照名字排序的，因此实际循环时间复杂度是O(ni+nt)</span></span><br><span class="line">	ni := <span class="built_in">len</span>(inter.mhdr) <span class="comment">// 目标接口方法总数</span></span><br><span class="line">	nt := <span class="keyword">int</span>(x.mcount) <span class="comment">// 实际类型方法总数</span></span><br><span class="line">    <span class="comment">// 计算实际类型的方法引用列表的偏移</span></span><br><span class="line">	xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="keyword">uintptr</span>(x.moff)))[:nt:nt]</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">imethods:</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">		i := &amp;inter.mhdr[k]</span><br><span class="line">		itype := inter.typ.typeOff(i.ityp) <span class="comment">// 目标接口方法类型，与参数和返回值相关</span></span><br><span class="line">		name := inter.typ.nameOff(i.name)  <span class="comment">// 目标接口方法名</span></span><br><span class="line">		iname := name.name()</span><br><span class="line">		ipkg := name.pkgPath() <span class="comment">// 接口的包名</span></span><br><span class="line">		<span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">			ipkg = inter.pkgpath.name()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">			t := &amp;xmhdr[j]</span><br><span class="line">			tname := typ.nameOff(t.name) </span><br><span class="line">            <span class="comment">// 如果实际方法类型和方法名与目标方法的一致</span></span><br><span class="line">			<span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">				pkgPath := tname.pkgPath()</span><br><span class="line">				<span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">					pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 如果方法是导出的或者包名一致</span></span><br><span class="line">                <span class="comment">// 如果接口有未导出方法，只能在同一个包内被实现，可以用来限制其他包实现该接口</span></span><br><span class="line">				<span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">					<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">						ifn := typ.textOff(t.ifn) <span class="comment">//实际函数入口PC</span></span><br><span class="line">                        <span class="comment">// 保存到itab的方法列表中</span></span><br><span class="line">						*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span> imethods</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// didn't find method</span></span><br><span class="line">		m.fun[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 没有找到方法，即目标类型没有实现该方法</span></span><br><span class="line">		<span class="keyword">return</span> iname</span><br><span class="line">	&#125;</span><br><span class="line">	m.hash = typ.hash</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>因为go中的接口是隐式实现的，我们可以在声明类型的时候，使用一些断言来加入编译时的检查，并且也可以提示其他人该类型实现了某个接口，比如我们声明了类型<code>T</code>实现了接口<code>I</code>，我们可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ I = <span class="built_in">new</span>(T) <span class="comment">// 这里断言T实现了接口I</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/teh-cmc/go-internals/tree/master/chapter2_interfaces" target="_blank" rel="noopener">https://github.com/teh-cmc/go-internals/tree/master/chapter2_interfaces</a></p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>