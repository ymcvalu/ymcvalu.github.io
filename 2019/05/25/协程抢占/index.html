<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        协程抢占 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek" />

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i>  </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#协程抢占"><span class="toc-text">协程抢占</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协作式抢占"><span class="toc-text">协作式抢占</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#morestack：执行抢占"><span class="toc-text">morestack：执行抢占</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysmon：抢占标记"><span class="toc-text">sysmon：抢占标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缺陷"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#go-nosplit"><span class="toc-text">go:nosplit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非协作式抢占"><span class="toc-text">非协作式抢占</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i>  </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        协程抢占
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-05-25 02:40:18</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#golang" title="golang">golang</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h1 id="协程抢占"><a href="#协程抢占" class="headerlink" title="协程抢占"></a>协程抢占</h1><h3 id="协作式抢占"><a href="#协作式抢占" class="headerlink" title="协作式抢占"></a>协作式抢占</h3><h5 id="morestack：执行抢占"><a href="#morestack：执行抢占" class="headerlink" title="morestack：执行抢占"></a>morestack：执行抢占</h5><p>目前<code>go</code>实现是的协作抢占：在每个函数开头插入<code>morestack</code>检查，除了检查是否需要扩张栈，同时还检查是否当前协程需要抢占。那么怎么判断一个协程是否需要抢占呢？后台线程会定时扫描当前运行中的协程，如果发现一个协程运行比较久，会将其标记为抢占状态。</p>
<p>我们首先看一下一个<code>main</code>函数的汇编代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	TEXT	<span class="string">""</span>.main(SB), $<span class="number">64</span><span class="number">-0</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">00000</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	TLS, CX</span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	(CX)(TLS*<span class="number">2</span>), CX <span class="comment">// 获取当前g</span></span><br><span class="line"><span class="comment">// 比较当前SP和g.stackguard0，如果小于则需要触发morestarck</span></span><br><span class="line"><span class="number">0x0010</span> <span class="number">00016</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	CMPQ	SP, <span class="number">16</span>(CX) </span><br><span class="line"><span class="number">0x0014</span> <span class="number">00020</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	JLS	<span class="number">110</span></span><br><span class="line"><span class="number">0x0016</span> <span class="number">00022</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	SUBQ	$<span class="number">64</span>, SP    <span class="comment">// SP-64，相当于设置栈帧大小64字节</span></span><br><span class="line"><span class="number">0x001a</span> <span class="number">00026</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	MOVQ	BP, <span class="number">56</span>(SP) <span class="comment">// 保存caller的BP，可以看到BP是保存到当前函数的栈帧中的，如果一个函数栈帧大小为0，则不需要保存BP</span></span><br><span class="line"><span class="number">0x001f</span> <span class="number">00031</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	LEAQ	<span class="number">56</span>(SP), BP <span class="comment">// 设置当前BP</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">0x0064</span> <span class="number">00100</span> (morestack.<span class="keyword">go</span>:<span class="number">7</span>)	MOVQ	<span class="number">56</span>(SP), BP <span class="comment">// 还原BP</span></span><br><span class="line"><span class="number">0x0069</span> <span class="number">00105</span> (morestack.<span class="keyword">go</span>:<span class="number">7</span>)	ADDQ	$<span class="number">64</span>, SP    <span class="comment">// SP+64，相当于销毁栈帧</span></span><br><span class="line"><span class="number">0x006d</span> <span class="number">00109</span> (morestack.<span class="keyword">go</span>:<span class="number">7</span>)	RET</span><br><span class="line"><span class="number">0x006e</span> <span class="number">00110</span> (morestack.<span class="keyword">go</span>:<span class="number">7</span>)	NOP</span><br><span class="line"><span class="number">0x006e</span> <span class="number">00110</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	CALL	runtime.morestack_noctxt(SB)</span><br><span class="line"><span class="number">0x0073</span> <span class="number">00115</span> (morestack.<span class="keyword">go</span>:<span class="number">5</span>)	JMP	<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，进入函数之后，首先会检查当前函数的<code>SP</code>寄存器是否已经达到<code>g.stackguard0</code>，如果是的话，则需要先调用<code>runtime.morestack_noctxt</code>方法扩张当前函数栈（现在的实现是重新分配一个更大的函数栈，然后把旧的函数栈内容拷贝过去），然后再根据栈帧大小设置<code>SP</code>和<code>BP</code>指针，而在函数返回前需要先恢复<code>BP</code>和<code>SP</code>指针。<strong>上面的BP和SP寄存器的相关设置是在morestack之后，也就是在执行morestack的时候，0(SP)为函数返回地址</strong></p>
<p>我们接着来看一下<code>runtime·morestack_noctxt</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// morestack but not preserving ctxt.</span></span><br><span class="line"><span class="comment">// 这里noctxt表示调用方法没有context，即没有闭包或者receiver</span></span><br><span class="line">TEXT runtime·morestack_noctxt(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVL	$<span class="number">0</span>, DX <span class="comment">// 清空DX的低32位，DX寄存器用于保存函数上下文</span></span><br><span class="line">	JMP	runtime·morestack(SB) <span class="comment">// 跳转到morestack方法，这里用的是JMP，不是CALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * support for morestack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Called during function prolog when more stack is needed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The traceback routines see morestack on a g0 as being</span></span><br><span class="line"><span class="comment">// the top of a stack (for example, morestack calling newstack</span></span><br><span class="line"><span class="comment">// calling the scheduler calling newm calling gc), so we must</span></span><br><span class="line"><span class="comment">// record an argument size. For that purpose, it has no arguments.</span></span><br><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	<span class="comment">// Cannot grow scheduler stack (m-&gt;g0).</span></span><br><span class="line">    get_tls(CX)            <span class="comment">// 这里get_tls(r)是一个宏：MOVQ TLS, r </span></span><br><span class="line">	MOVQ	g(CX), BX      <span class="comment">// 保存当前的g到BX</span></span><br><span class="line">	MOVQ	g_m(BX), BX    <span class="comment">// 保存m到BX</span></span><br><span class="line">	MOVQ	m_g0(BX), SI   <span class="comment">// 保存g0到SI</span></span><br><span class="line">	CMPQ	g(CX), SI <span class="comment">// 如果当前处于g0栈</span></span><br><span class="line">	JNE	<span class="number">3</span>(PC)  <span class="comment">// PC+3</span></span><br><span class="line">	CALL	runtime·badmorestackg0(SB) <span class="comment">// g0栈不允许扩张</span></span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cannot grow signal stack (m-&gt;gsignal).</span></span><br><span class="line">	MOVQ	m_gsignal(BX), SI  <span class="comment">// gsignal用于处理信号量的栈</span></span><br><span class="line">	CMPQ	g(CX), SI</span><br><span class="line">	JNE	<span class="number">3</span>(PC)</span><br><span class="line">	CALL	runtime·badmorestackgsignal(SB) <span class="comment">// gsignal栈不允许扩张</span></span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called from f：把调用morestack的函数记为f</span></span><br><span class="line">	<span class="comment">// 保存 f's caller的信息到m.morebuf中</span></span><br><span class="line">    <span class="comment">// 8(SP)保存f的返回地址，即f's caller的PC</span></span><br><span class="line">	MOVQ	<span class="number">8</span>(SP), AX</span><br><span class="line">	MOVQ	AX, (m_morebuf+gobuf_pc)(BX) <span class="comment">// 设置m.morebuf.pc为f's caller的PC</span></span><br><span class="line">    <span class="comment">// 16(SP)的地址为f's caller的SP</span></span><br><span class="line">	LEAQ	<span class="number">16</span>(SP), AX	<span class="comment">// f's caller's SP</span></span><br><span class="line">	MOVQ	AX, (m_morebuf+gobuf_sp)(BX)</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	g(CX), SI</span><br><span class="line">	MOVQ	SI, (m_morebuf+gobuf_g)(BX)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set g-&gt;sched to context in f.</span></span><br><span class="line">    MOVQ	<span class="number">0</span>(SP), AX <span class="comment">// f's PC，morestack的frameSize为0，此时0(SP)为f的返回地址</span></span><br><span class="line">	MOVQ	AX, (g_sched+gobuf_pc)(SI) <span class="comment">// 设置g.sched.pc为f的PC</span></span><br><span class="line">	MOVQ	SI, (g_sched+gobuf_g)(SI)</span><br><span class="line">    <span class="comment">// 8(SP)的地址即为f的SP</span></span><br><span class="line">	LEAQ	<span class="number">8</span>(SP), AX <span class="comment">// f's SP</span></span><br><span class="line">	MOVQ	AX, (g_sched+gobuf_sp)(SI) <span class="comment">// 保存f的SP</span></span><br><span class="line">	MOVQ	BP, (g_sched+gobuf_bp)(SI) <span class="comment">// 保存f的BP</span></span><br><span class="line">	MOVQ	DX, (g_sched+gobuf_ctxt)(SI)  <span class="comment">// 保存f的DX</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call newstack on m-&gt;g0's stack.</span></span><br><span class="line">	MOVQ	m_g0(BX), BX  <span class="comment">// 获取g0</span></span><br><span class="line">	MOVQ	BX, g(CX)     <span class="comment">// 设置当前g为g0</span></span><br><span class="line">	MOVQ	(g_sched+gobuf_sp)(BX), SP <span class="comment">// 设置SP寄存器为g0.sched.sp</span></span><br><span class="line">	CALL	runtime·newstack(SB)       <span class="comment">// 调用newstack，该方法不会返回</span></span><br><span class="line">	CALL	runtime·abort(SB)	<span class="comment">// crash if newstack returns</span></span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>我们接着来看一下<code>runtime.newstack</code>这个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	thisg := getg() <span class="comment">// 这里获取的是当前执行的g，实际就是g0</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 这里的curg是触发了morestack的g，不是g0</span></span><br><span class="line">	gp := thisg.m.curg</span><br><span class="line">	...</span><br><span class="line">	morebuf := thisg.m.morebuf</span><br><span class="line">	thisg.m.morebuf.pc = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.lr = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.sp = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.g = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要抢占，当发现一个协程需要被抢占时，会将其g.stackguard0设置成stackPreempt，从而触发morestack的执行</span></span><br><span class="line">	preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt</span><br><span class="line">    <span class="comment">// 触发了抢占</span></span><br><span class="line"> 	<span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="comment">// We are interested in preempting user Go code, not runtime code.</span></span><br><span class="line">		<span class="comment">// If we're holding locks, mallocing, or preemption is disabled, don't</span></span><br><span class="line">		<span class="comment">// preempt.</span></span><br><span class="line">		<span class="keyword">if</span> thisg.m.locks != <span class="number">0</span> || thisg.m.mallocing != <span class="number">0</span> || thisg.m.preemptoff != <span class="string">""</span> || thisg.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">			<span class="comment">// 还原gp.stackguard0</span></span><br><span class="line">            <span class="comment">// gp-&gt;preempt is set, so it will be preempted next time.</span></span><br><span class="line">			gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">            <span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line">			gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sp := gp.sched.sp</span><br><span class="line">	<span class="keyword">if</span> sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 || sys.ArchFamily == sys.WASM &#123;</span><br><span class="line">		<span class="comment">// The call to morestack cost a word.</span></span><br><span class="line">		sp -= sys.PtrSize</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 再次检查抢占</span></span><br><span class="line">	<span class="keyword">if</span> preempt &#123;</span><br><span class="line">        <span class="comment">// g0不允许被抢占</span></span><br><span class="line">		<span class="keyword">if</span> gp == thisg.m.g0 &#123;</span><br><span class="line">			throw(<span class="string">"runtime: preempt g0"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> thisg.m.p == <span class="number">0</span> &amp;&amp; thisg.m.locks == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"runtime: g is running but p is not"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Synchronize with scang.</span></span><br><span class="line">        <span class="comment">// 更新状态为_Gwaiting</span></span><br><span class="line">		casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">		<span class="comment">// gc相关，抢占g扫描</span></span><br><span class="line">        <span class="keyword">if</span> gp.preemptscan &#123;</span><br><span class="line">			<span class="keyword">for</span> !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) &#123;</span><br><span class="line">				<span class="comment">// Likely to be racing with the GC as</span></span><br><span class="line">				<span class="comment">// it sees a _Gwaiting and does the</span></span><br><span class="line">				<span class="comment">// stack scan. If so, gcworkdone will</span></span><br><span class="line">				<span class="comment">// be set and gcphasework will simply</span></span><br><span class="line">				<span class="comment">// return.</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">				<span class="comment">// gcw is safe because we're on the</span></span><br><span class="line">				<span class="comment">// system stack.</span></span><br><span class="line">				gcw := &amp;gp.m.p.ptr().gcw</span><br><span class="line">                <span class="comment">// 扫描gp的栈</span></span><br><span class="line">				scanstack(gp, gcw)</span><br><span class="line">				<span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">					gcw.dispose()</span><br><span class="line">				&#125;</span><br><span class="line">				gp.gcscandone = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			gp.preemptscan = <span class="literal">false</span></span><br><span class="line">			gp.preempt = <span class="literal">false</span></span><br><span class="line">			casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)</span><br><span class="line">			<span class="comment">// This clears gcscanvalid.</span></span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">			gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">			gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Act like goroutine called runtime.Gosched.</span></span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        <span class="comment">// 这里执行抢占，实际上就是调用schedule方法，该方法不会返回</span></span><br><span class="line">		gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不是由于抢占而执行morestack，那么就是真的因为栈不够用了，需要扩容栈</span></span><br><span class="line">	oldsize := gp.stack.hi - gp.stack.lo</span><br><span class="line">	newsize := oldsize * <span class="number">2</span> <span class="comment">// 新的栈是原来的两倍</span></span><br><span class="line">	<span class="keyword">if</span> newsize &gt; maxstacksize &#123; <span class="comment">// 栈是有限制的哦：1&lt;&lt;20</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"runtime: goroutine stack exceeds "</span>, maxstacksize, <span class="string">"-byte limit\n"</span>)</span><br><span class="line">		throw(<span class="string">"stack overflow"</span>) <span class="comment">// 栈溢出了</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The goroutine must be executing in order to call newstack,</span></span><br><span class="line">	<span class="comment">// so it must be Grunning (or Gscanrunning).</span></span><br><span class="line">    <span class="comment">// 设置g的状态</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gcopystack)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The concurrent GC will not scan the stack while we are doing the copy since</span></span><br><span class="line">	<span class="comment">// the gp is in a Gcopystack status.</span></span><br><span class="line">    <span class="comment">// coypstack会创建一个新的栈，然后把旧的栈的内容拷到新的栈中</span></span><br><span class="line">	copystack(gp, newsize, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"stack grow done\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 可以开始跑了</span></span><br><span class="line">	casgstatus(gp, _Gcopystack, _Grunning)</span><br><span class="line">	gogo(&amp;gp.sched) <span class="comment">// gogo开始跑了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sysmon：抢占标记"><a href="#sysmon：抢占标记" class="headerlink" title="sysmon：抢占标记"></a>sysmon：抢占标记</h5><p>那么，我们的协程是什么时候被标记为可抢占的呢？当然是后台线程<code>sysmon</code>的功劳了，<code>sysmon</code>的工作之一就是找出持续运行很久的协程，然后把他标记为可抢占：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead()</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a heap span goes unused for 5 minutes after a garbage collection,</span></span><br><span class="line">	<span class="comment">// we hand it back to the operating system.</span></span><br><span class="line">	scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Scavenge-a-lot for testing.</span></span><br><span class="line">		forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span><br><span class="line">		scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastscavenge := nanotime()</span><br><span class="line">	nscavenge := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay)</span><br><span class="line"> 		...</span><br><span class="line">        <span class="comment">// 注释很清楚了</span></span><br><span class="line">		<span class="comment">// retake P's blocked in syscalls</span></span><br><span class="line">		<span class="comment">// and preempt long running G's</span></span><br><span class="line">		<span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">			idle = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			idle++</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	lock(&amp;allpLock)</span><br><span class="line">	<span class="comment">// 遍历p列表</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">		_p_ := allp[i]</span><br><span class="line">		<span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">			<span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pd := &amp;_p_.sysmontick</span><br><span class="line">		s := _p_.status</span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">			<span class="comment">// 这里是处理系统调用时的P</span></span><br><span class="line">            <span class="comment">// 如果系统调用阻塞到一定时长，并且当前有其他g可执行时，考虑将_Psyscall的p夺回过来，标记为_Pidle</span></span><br><span class="line">            ...</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> s == _Prunning &#123; </span><br><span class="line">            <span class="comment">// 如果当前P已经在同一个G上运行很久了，标记抢占</span></span><br><span class="line">			<span class="comment">// Preempt G if it's running for too long.</span></span><br><span class="line">			t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">				pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">				pd.schedwhen = now</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> pd.schedwhen+forcePreemptNS &gt; now &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 抢占</span></span><br><span class="line">			preemptone(_p_)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;allpLock)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	mp := _p_.m.ptr()</span><br><span class="line">	<span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置抢占标志位</span></span><br><span class="line">	gp.preempt = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Every call in a go routine checks for stack overflow by</span></span><br><span class="line">	<span class="comment">// comparing the current stack pointer to gp-&gt;stackguard0.</span></span><br><span class="line">	<span class="comment">// Setting gp-&gt;stackguard0 to StackPreempt folds</span></span><br><span class="line">	<span class="comment">// preemption into the normal stack overflow check.</span></span><br><span class="line">    <span class="comment">// 设置gp.stackguard0 = stackPreempt，从而能够触发morestack</span></span><br><span class="line">	gp.stackguard0 = stackPreempt</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们对<code>go</code>中的协作式抢占机制已经很明了了，但是，抢占只是标记一下，你说任你说，我不一定照做啊。</p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>之所以在函数调用的时候执行检查是因为函数切换的时候是一个<code>safe point</code>，这时候的通用寄存器是空的，切换协程不需要保存这些寄存器，而且栈中的<code>root pointer</code>是确定的，能够精确执行<code>gc</code>扫描。</p>
<p>然而，如果有一个协程没有发生函数调用，比如下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个协程就没有机会被抢占，也就不会让出<code>cpu</code>。</p>
<p>开始执行<code>gc</code>的时候先暂停所有协程的执行，然后再执行<code>stop the world</code>开启写屏障。这时候假如我们有一个协程跑的是类似上面的代码，那么我们的程序就会直接卡死：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="comment">// 该代码导致当前协程不会让出cpu</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// sleep 1s，确保子协程开始执行</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	log.Println(<span class="string">"开始触发gc"</span>)</span><br><span class="line">	<span class="comment">// 触发gc</span></span><br><span class="line">	runtime.GC()</span><br><span class="line">	log.Println(<span class="string">"手动gc完成"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为其他协程已经被暂停，而最后这个协程由于没有发生函数调用，无法执行抢占操作，从而垃圾收集器会一直处于等待，<code>gc</code>也一直不会被触发。当然我们平时的业务代码一般不会有这种情况发生，但是如果有一个函数需要执行比较久才会被抢占，那么就会导致<code>gc</code>的延时，同时也会严重影响程序的吞吐量。</p>
<h5 id="go-nosplit"><a href="#go-nosplit" class="headerlink" title="go:nosplit"></a>go:nosplit</h5><p>TODO</p>
<h3 id="非协作式抢占"><a href="#非协作式抢占" class="headerlink" title="非协作式抢占"></a>非协作式抢占</h3><p>因为协作式抢占存在很明显的缺点：抢占不及时，有一种解决方案是在函数中插入一些细粒度更小的抢占检查点，但是这会对性能产生影响，比如每次循环都需要额外执行一次分支判断。</p>
<p>因此有人提出来非协作式抢占来弥补这个缺陷，能够在任意指令触发抢占。非协作式抢占的主要难点在于如何满足<code>gc</code>安全，抢占应该发生在<code>safe point</code>。</p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>