<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        grpc server解析 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek" />

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i>  </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#grpc-server"><span class="toc-text">grpc server</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i>  </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        grpc server解析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-22 11:26:28</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#grpc - go" title="grpc - go">grpc - go</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p><code>grpc</code>是由谷歌开源的一个高性能、通用的开源<code>rpc</code>框架，具体的使用可以参考<a href="http://mcll.top/2018/12/21/grpc%E4%B8%8A%E6%89%8B%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">该文章</a>。本文主要看一下<code>go</code>版本的<code>grpc</code>的服务端实现。</p>
<h3 id="grpc-server"><a href="#grpc-server" class="headerlink" title="grpc server"></a>grpc server</h3><p>我们先看一下启动一个grpc server时的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":6060"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	<span class="comment">// 注册服务，EchoServer实现了.proto中声明的服务接口</span></span><br><span class="line">	proto.RegisterEchoSvcServer(s, &amp;EchoServer&#123;&#125;)</span><br><span class="line">	<span class="comment">// 启动服务</span></span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，第6行创建了一个grpc server，第8行将具体的服务注册到server中，然后第10行开始启动服务。</p>
<p>其中，<code>RegisterEchoSvcServer</code>这个函数由插件<code>protoc-gen-go</code>通过<code>.proto</code>文件自动生成的，我们先来看一下其实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务描述，由插件通过`.proto`文件自动生成</span></span><br><span class="line"><span class="keyword">var</span> _EchoSvc_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">	ServiceName: <span class="string">"proto.EchoSvc"</span>, <span class="comment">// 服务名</span></span><br><span class="line">	HandlerType: (*EchoSvcServer)(<span class="literal">nil</span>), <span class="comment">// 这里声明了该服务要实现的接口</span></span><br><span class="line">    <span class="comment">// 服务具有的方法列表</span></span><br><span class="line">	Methods: []grpc.MethodDesc&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			MethodName: <span class="string">"Echo"</span>, <span class="comment">// rpc方法名</span></span><br><span class="line">			Handler:    _EchoSvc_Echo_Handler, <span class="comment">// rpc请求的handler</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="comment">// stream方法列表，该服务没有</span></span><br><span class="line">	Streams:  []grpc.StreamDesc&#123;&#125;,</span><br><span class="line">	Metadata: <span class="string">"echo.proto"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterEchoSvcServer</span><span class="params">(s *grpc.Server, srv EchoSvcServer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传入服务描述和具体的服务实现对象</span></span><br><span class="line">	s.RegisterService(&amp;_EchoSvc_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的_EchoSvc_serviceDesc是有插件根据我们的服务声明自动生成的，grpc中的rpc方法主要有两种类型。第一种就是常见的普通的rpc方法，第二种是<a href="https://grpc.io/docs/guides/concepts/" target="_blank" rel="noopener">stream rpc方法</a></p>
<p>可以看到，实际上调用的是grpc server的服务注册方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterService</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ss需要实现的接口类型</span></span><br><span class="line">    ht := reflect.TypeOf(sd.HandlerType).Elem()</span><br><span class="line">    <span class="comment">// ss实际的类型</span></span><br><span class="line">	st := reflect.TypeOf(ss)</span><br><span class="line">    <span class="comment">// ss需要实现sd.HandlerType中指定的接口</span></span><br><span class="line">	<span class="keyword">if</span> !st.Implements(ht) &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v"</span>, st, ht)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 注册接口到server</span></span><br><span class="line">	s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">register</span><span class="params">(sd *ServiceDesc, ss <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line">	s.printf(<span class="string">"RegisterService(%q)"</span>, sd.ServiceName)</span><br><span class="line">    <span class="comment">// 如果server已经开始运行，不允许注册</span></span><br><span class="line">	<span class="keyword">if</span> s.serve &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService after Server.Serve for %q"</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 同一个服务名不允许重复注册</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := s.m[sd.ServiceName]; ok &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found duplicate service registration for %q"</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	srv := &amp;service&#123;</span><br><span class="line">		server: ss, <span class="comment">// 具体的服务实现对象</span></span><br><span class="line">		md:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*MethodDesc), <span class="comment">// 普通rpc方法描述</span></span><br><span class="line">		sd:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*StreamDesc), <span class="comment">// stream类型的rpc方法描述</span></span><br><span class="line">		mdata:  sd.Metadata,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 添加方法描述到srv的md</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">		d := &amp;sd.Methods[i]</span><br><span class="line">		srv.md[d.MethodName] = d</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 添加方法描述到srv.sd</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">		d := &amp;sd.Streams[i]</span><br><span class="line">		srv.sd[d.StreamName] = d</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将servicer添加到server的services表中</span></span><br><span class="line">	s.m[sd.ServiceName] = srv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，grpc的server中有一个service表，相当于http服务中的路由表。</p>
<p>接下来看一下，grpc server如果提供服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(lis net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.printf(<span class="string">"serving"</span>)</span><br><span class="line">    <span class="comment">// 开始运行</span></span><br><span class="line">	s.serve = <span class="literal">true</span></span><br><span class="line"> 	</span><br><span class="line">    s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.serveWG.Done()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// serve会阻塞直到退出服务</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-s.quit:</span><br><span class="line">			&lt;-s.done</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把lis添加到lis表中，可以看到一个server可以同时监听多个端口提供服务</span></span><br><span class="line">	ls := &amp;listenSocket&#123;Listener: lis&#125;</span><br><span class="line">	s.lis[ls] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 服务退出时，从lis表中移除</span></span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> s.lis != <span class="literal">nil</span> &amp;&amp; s.lis[ls] &#123;</span><br><span class="line">			ls.Close()</span><br><span class="line">			<span class="built_in">delete</span>(s.lis, ls)</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 接受客户端请求</span></span><br><span class="line">		rawConn, err := lis.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 错误处理...</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		s.serveWG.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 处理客户端连接</span></span><br><span class="line">			s.handleRawConn(rawConn)</span><br><span class="line">			s.serveWG.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleRawConn</span><span class="params">(rawConn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置read和write的Deadline</span></span><br><span class="line">	rawConn.SetDeadline(time.Now().Add(s.opts.connectionTimeout))</span><br><span class="line">	<span class="comment">// 可能开启了tls/ssl，需要证书认证，完成tls/ssl握手</span></span><br><span class="line">    conn, authInfo, err := s.useTransportAuthenticator(rawConn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> s.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		conn.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// grpc是基于http2协议进行通信的，完成http2协议的握手</span></span><br><span class="line">	st := s.newHTTP2Transport(conn, authInfo)</span><br><span class="line">	<span class="keyword">if</span> st == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前面设置Deadline是为了尽快完成握手操作</span></span><br><span class="line">    <span class="comment">// 因为客户端连接之后，并不是一直在发送请求，设置Deadline没有意义，因此这里取消deadline的设置</span></span><br><span class="line">	rawConn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">    <span class="comment">// 保存客户端的http2连接</span></span><br><span class="line">	<span class="keyword">if</span> !s.addConn(st) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 等待客户端rpc请求到来，并提供服务</span></span><br><span class="line">        <span class="comment">// 基于http2的多路复用，客户端可以使用一条连接同时发送多个请求</span></span><br><span class="line">		s.serveStreams(st)</span><br><span class="line">        <span class="comment">// 移除客户端的http2连接</span></span><br><span class="line">		s.removeConn(st)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveStreams</span><span class="params">(st transport.ServerTransport)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> st.Close()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HandleStreams接收两个参数：handler和tracer</span></span><br><span class="line">    <span class="comment">// 该方法有两个参数：hanlder和tracer</span></span><br><span class="line">    <span class="comment">// 该方法循环读取客户端连接发送过来的帧：</span></span><br><span class="line">    <span class="comment">//    1. 如果是HEADER帧，说明有新的rpc请求到来，回调handler</span></span><br><span class="line">    <span class="comment">//    2. 如果是DATA帧，将数据分发到对应的stream</span></span><br><span class="line">    <span class="comment">//    3. ...</span></span><br><span class="line">	st.HandleStreams(<span class="function"><span class="keyword">func</span><span class="params">(stream *transport.Stream)</span></span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 回调中开启子协程，处理rpc请求</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// grpc基于http2，同一条连接会分成多个stream，每个rpc请求使用一个stream</span></span><br><span class="line">            <span class="comment">// 这样多个客户端请求可以复用同一条连接</span></span><br><span class="line">            <span class="comment">// 当有新的rpc请求到来，会进入该回调，然后调用server的handleStream处理rpc请求</span></span><br><span class="line">			s.handleStream(st, stream, s.traceInfo(st, stream))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !EnableTracing &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx</span><br><span class="line">		&#125;</span><br><span class="line">		tr := trace.New(<span class="string">"grpc.Recv."</span>+methodFamily(method), method)</span><br><span class="line">		<span class="keyword">return</span> trace.NewContext(ctx, tr)</span><br><span class="line">	&#125;)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看一下server的handleStream方法，该方法处理rpc请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">handleStream</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo)</span></span> &#123;</span><br><span class="line">    <span class="comment">// rpc所请求的方法：服务名/方法名</span></span><br><span class="line">	sm := stream.Method()</span><br><span class="line">    <span class="comment">// 去掉开头的`/`</span></span><br><span class="line">	<span class="keyword">if</span> sm != <span class="string">""</span> &amp;&amp; sm[<span class="number">0</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">		sm = sm[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	pos := strings.LastIndex(sm, <span class="string">"/"</span>)</span><br><span class="line">	<span class="keyword">if</span> pos == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// 应该满足：服务名/方法名</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 请求的服务</span></span><br><span class="line">	service := sm[:pos]</span><br><span class="line">    <span class="comment">// 请求的方法</span></span><br><span class="line">	method := sm[pos+<span class="number">1</span>:]</span><br><span class="line">    <span class="comment">// 在server的服务表中查找对应的服务实现</span></span><br><span class="line">    <span class="comment">// server运行时不允许注册新的service，因此这里并发读，不需要加锁</span></span><br><span class="line">	srv, ok := s.m[service]</span><br><span class="line">    <span class="comment">// 如果请求的服务不存在</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 如果server的配置中，指定了处理未知服务的方法，则交由其处理</span></span><br><span class="line">		<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="literal">nil</span> &#123;</span><br><span class="line">			s.processStreamingRPC(t, stream, <span class="literal">nil</span>, unknownDesc, trInfo)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先在普通的rpc方法表中查找</span></span><br><span class="line">	<span class="keyword">if</span> md, ok := srv.md[method]; ok &#123;</span><br><span class="line">        <span class="comment">// 处理普通的rpc方法</span></span><br><span class="line">		s.processUnaryRPC(t, stream, srv, md, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 尝试在strem rpc找</span></span><br><span class="line">	<span class="keyword">if</span> sd, ok := srv.sd[method]; ok &#123;</span><br><span class="line">        <span class="comment">// 处理stream rpc</span></span><br><span class="line">		s.processStreamingRPC(t, stream, srv, sd, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求未知方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, <span class="literal">nil</span>, unknownDesc, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限于篇幅，我们这里主要看一下<code>processUnaryRPC</code>方法，<code>processStreamingRPC</code>方法大同小异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">processUnaryRPC</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> comp, decomp encoding.Compressor</span><br><span class="line">	<span class="keyword">var</span> cp Compressor</span><br><span class="line">	<span class="keyword">var</span> dc Decompressor</span><br><span class="line">	<span class="comment">// ...	</span></span><br><span class="line">    <span class="comment">// 设置压缩选项</span></span><br><span class="line">	<span class="keyword">if</span> s.opts.cp != <span class="literal">nil</span> &#123;</span><br><span class="line">		cp = s.opts.cp</span><br><span class="line">		stream.SetSendCompress(cp.Type())</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> rc := stream.RecvCompress(); rc != <span class="string">""</span> &amp;&amp; rc != encoding.Identity &#123;</span><br><span class="line">		<span class="comment">// Legacy compressor not specified; attempt to respond with same encoding.</span></span><br><span class="line">		comp = encoding.GetCompressor(rc)</span><br><span class="line">		<span class="keyword">if</span> comp != <span class="literal">nil</span> &#123;</span><br><span class="line">			stream.SetSendCompress(rc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> payInfo *payloadInfo</span><br><span class="line">	<span class="keyword">if</span> sh != <span class="literal">nil</span> || binlog != <span class="literal">nil</span> &#123;</span><br><span class="line">		payInfo = &amp;payloadInfo&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 接收并解压缩数据</span></span><br><span class="line">	d, err := recvAndDecompress(&amp;parser&#123;r: stream&#125;, stream, dc, s.opts.maxReceiveMessageSize, payInfo, decomp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// df方法用于从接收的数据包d中反序列化为v</span></span><br><span class="line">	df := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// 反序列化请求参数</span></span><br><span class="line">		<span class="keyword">if</span> err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"grpc: error unmarshalling request: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 创建context，该方法和header的获取以及写入有关，下面分析</span></span><br><span class="line">	ctx := NewContextWithServerTransportStream(stream.Context(), stream)</span><br><span class="line">	<span class="comment">// 执行handler，这个handler是通过.proto文件生成的，该方法内会去调用server的对应的方法，该方法返回对应的resp</span></span><br><span class="line">    <span class="comment">// 这里第三个参数是反序列化方法，第四个参数是创建server时指定的interceptor选项</span></span><br><span class="line">	reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)</span><br><span class="line">	<span class="comment">// 如果返回的错误，这里的err可能是由我们的rpc方法返回的</span></span><br><span class="line">	<span class="keyword">if</span> appErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		appStatus, ok := status.FromError(appErr)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// 如过没有实现 interface&#123;GRPCStatus()*Status&#125; 接口</span></span><br><span class="line">			appErr = status.Error(codes.Unknown, appErr.Error())</span><br><span class="line">			appStatus, _ = status.FromError(appErr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 写入错误信息到stream中</span></span><br><span class="line">		<span class="keyword">if</span> e := t.WriteStatus(stream, appStatus); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			grpclog.Warningf(<span class="string">"grpc: Server.processUnaryRPC failed to write status: %v"</span>, e)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> appErr</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	opts := &amp;transport.Options&#123;Last: <span class="literal">true</span>&#125;</span><br><span class="line">	<span class="comment">// 序列化reply给客户端</span></span><br><span class="line">	<span class="keyword">if</span> err := s.sendResponse(t, stream, reply, cp, opts, comp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = t.WriteStatus(stream, status.New(codes.OK, <span class="string">""</span>))</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码略有删减，主要是删掉一些和统计、trace以及日志相关的代码。主要的逻辑就是从stream读取请求参参数，反序列化后调用methodDesc中的handler方法，然后把返回的内容序列化后写入stream返回给客户端。</p>
<p>我们知道，grpc是基于http2协议的，因此也是存在<code>header</code>的，grpc和http一样，可以设置和获取请求的header。在服务端，主要有获取客户端传递过来的header以及传递header给客户端两个操作。</p>
<p>我们先看上面出现的<code>NewContextWithServerTransportStream</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该接口用于服务端设置传递给客户端的header</span></span><br><span class="line"><span class="keyword">type</span> ServerTransportStream <span class="keyword">interface</span> &#123;</span><br><span class="line">	Method() <span class="keyword">string</span></span><br><span class="line">	SetHeader(md metadata.MD) error</span><br><span class="line">	SendHeader(md metadata.MD) error</span><br><span class="line">	SetTrailer(md metadata.MD) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContextWithServerTransportStream</span><span class="params">(ctx context.Context, stream ServerTransportStream)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基于ctx创建新的context，并把stream保存到新的context中</span></span><br><span class="line">    <span class="comment">// 当调用grpc.SetHeader时，会执行stream.SetHeader方法</span></span><br><span class="line">	<span class="keyword">return</span> context.WithValue(ctx, streamKey&#123;&#125;, stream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在<code>processUnaryRPC</code>方法中，对该方法的调用如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">processUnaryRPC</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">	ctx := NewContextWithServerTransportStream(stream.Context(), stream)</span><br><span class="line">	reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，传入的是当前请求的<code>stream</code>的<code>context</code>，接下来看一下<code>stream</code>的<code>context</code>创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">operateHeaders</span><span class="params">(frame *http2.MetaHeadersFrame, handle <span class="keyword">func</span>(*Stream)</span>, <span class="title">traceCtx</span> <span class="title">func</span><span class="params">(context.Context, <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span>) <span class="params">(fatal <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	streamID := frame.Header().StreamID</span><br><span class="line">	state := decodeState&#123;serverSide: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="comment">// 解析header帧，包括获取header中的各个字段</span></span><br><span class="line">	<span class="keyword">if</span> err := state.decodeHeader(frame); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	 	<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buf := newRecvBuffer()</span><br><span class="line">	s := &amp;Stream&#123;</span><br><span class="line">		id:             streamID,</span><br><span class="line">		st:             t,</span><br><span class="line">		buf:            buf,</span><br><span class="line">		fc:             &amp;inFlow&#123;limit: <span class="keyword">uint32</span>(t.initialWindowSize)&#125;,</span><br><span class="line">		recvCompress:   state.encoding,</span><br><span class="line">		method:         state.method,</span><br><span class="line">		contentSubtype: state.contentSubtype,</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">// 除了grpc预定义的几个header之外，其他header都保存到mdata中</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(state.mdata) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 这里会将state.mdata保存到新的context中</span></span><br><span class="line">		s.ctx = metadata.NewIncomingContext(s.ctx, state.mdata)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	handle(s)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIncomingContext</span><span class="params">(ctx context.Context, md MD)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> context.WithValue(ctx, mdIncomingKey&#123;&#125;, md)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当收到一个<code>Header</code>帧，就表明有新的rpc请求到来，这时候就会解析header帧并创建stream，在创建stream的时候，会把用户自定义的header字段保存到stream.context中</p>
<p>在我们实际编码时，可以通过<code>metadata</code>包来读取客户端传递过来的<code>header</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(EchoServer)</span> <span class="title">Echo</span><span class="params">(ctx context.Context, req *proto.EchoReq)</span> <span class="params">(resp *proto.EchoResp, err error)</span></span> &#123;</span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		log.Printf(<span class="string">"%s: %v"</span>, md.Get(<span class="string">"key"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> &amp;proto.EchoResp&#123;</span><br><span class="line">		Msg: VERSION,</span><br><span class="line">	&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而设置header返回给客户端可以如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(EchoServer)</span> <span class="title">Echo</span><span class="params">(ctx context.Context, req *proto.EchoReq)</span> <span class="params">(resp *proto.EchoResp, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 最终会设置stream的header</span></span><br><span class="line">	grpc.SetHeader(ctx, metadata.Pairs(<span class="string">"key1"</span>, <span class="string">"val1"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;proto.EchoResp&#123;</span><br><span class="line">		Msg: VERSION,</span><br><span class="line">	&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下写回返回内容给客户端的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">sendResponse</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, msg <span class="keyword">interface</span>&#123;&#125;, cp Compressor, opts *transport.Options, comp encoding.Compressor)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 反序列化返回内容</span></span><br><span class="line">	data, err := encode(s.getCodec(stream.ContentSubtype()), msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Errorln(<span class="string">"grpc: server failed to encode response: "</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 压缩</span></span><br><span class="line">	compData, err := compress(data, cp, comp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Errorln(<span class="string">"grpc: server failed to compress response: "</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 创建消息头部</span></span><br><span class="line">	hdr, payload := msgHeader(data, compData)</span><br><span class="line">	<span class="comment">// TODO(dfawley): should we be checking len(data) instead?</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(payload) &gt; s.opts.maxSendMessageSize &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.ResourceExhausted, <span class="string">"grpc: trying to send message larger than max (%d vs. %d)"</span>, <span class="built_in">len</span>(payload), s.opts.maxSendMessageSize)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 写回内容</span></span><br><span class="line">	err = t.Write(stream, hdr, payload, opts)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; s.opts.statsHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.opts.statsHandler.HandleRPC(stream.Context(), outPayload(<span class="literal">false</span>, msg, data, payload, time.Now()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *http2Server)</span> <span class="title">Write</span><span class="params">(s *Stream, hdr []<span class="keyword">byte</span>, data []<span class="keyword">byte</span>, opts *Options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果header还没有发送，先发送header</span></span><br><span class="line">	<span class="keyword">if</span> !s.isHeaderSent() &#123; <span class="comment">// Headers haven't been written yet.</span></span><br><span class="line">		<span class="keyword">if</span> err := t.WriteHeader(s, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	emptyLen := http2MaxFrameLen - <span class="built_in">len</span>(hdr)</span><br><span class="line">	<span class="keyword">if</span> emptyLen &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">		emptyLen = <span class="built_in">len</span>(data)</span><br><span class="line">	&#125;</span><br><span class="line">	hdr = <span class="built_in">append</span>(hdr, data[:emptyLen]...)</span><br><span class="line">	data = data[emptyLen:]</span><br><span class="line">    <span class="comment">// 数据帧</span></span><br><span class="line">	df := &amp;dataFrame&#123;</span><br><span class="line">		streamID: s.id,</span><br><span class="line">		h:        hdr,</span><br><span class="line">		d:        data,</span><br><span class="line">		onEachWrite: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			atomic.StoreUint32(&amp;t.resetPingStrikes, <span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := s.wq.get(<span class="keyword">int32</span>(<span class="built_in">len</span>(hdr) + <span class="built_in">len</span>(data))); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-t.ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> ErrConnClosing</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ContextErr(s.ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 把数据帧加入到发送队列</span></span><br><span class="line">	<span class="keyword">return</span> t.controlBuf.put(df)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，看一下methodDesc中的handler，这个是由插件自动生成的包装方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">processUnaryRPC</span><span class="params">(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    reply, appErr := md.Handler(srv.server, ctx, df, s.opts.unaryInt)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">EchoSvc_Echo_Handler</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>, <span class="title">interceptor</span> <span class="title">grpc</span>.<span class="title">UnaryServerInterceptor</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">    in := <span class="built_in">new</span>(EchoReq)</span><br><span class="line">    <span class="comment">// dec是传入的反序列化方法</span></span><br><span class="line">	<span class="keyword">if</span> err := dec(in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有指定interceptor</span></span><br><span class="line">	<span class="keyword">if</span> interceptor == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用service对应的方法</span></span><br><span class="line">		<span class="keyword">return</span> srv.(EchoSvcServer).Echo(ctx, in)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务信息</span></span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: <span class="string">"/proto.EchoSvc/Echo"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回调handler</span></span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(EchoSvcServer).Echo(ctx, req.(*EchoReq))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 先执行interceptor，然后在执行handler</span></span><br><span class="line">	<span class="keyword">return</span> interceptor(ctx, in, info, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，用户创建<code>server</code>时，如果设置了<code>interceptor</code>选项，那么在执行具体的服务方法前，会先执行用户设置的<code>interceptor</code>，声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>interceptor</code>中，可以做一些通用处理，比如日志记录，异常处理或者请求拦截等</p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>