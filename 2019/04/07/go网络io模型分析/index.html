<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        go网络io模型分析 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i>  </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一切从创建Listener开始"><span class="toc-text">一切从创建Listener开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accept又是如何执行的呢"><span class="toc-text">Accept又是如何执行的呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#那么epoll的wait又是什么时候调用的呢"><span class="toc-text">那么epoll的wait又是什么时候调用的呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大同小异的读写操作"><span class="toc-text">大同小异的读写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#差点被遗忘的close"><span class="toc-text">差点被遗忘的close</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最后"><span class="toc-text">最后</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i>  </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        go网络io模型分析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-04-07 19:08:14</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#go" title="go">go</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>在过去，传统的网络编程模型是多线程模型，在主线程中开启一个网络监听，然后每次有一个客户端进行连接，就会单独开启一个线程来处理这个客户端请求。</p>
<p>然而，如果并发量比较大，服务端就会创建大量的线程，而且会有大量的线程阻塞在网络IO上，频繁的线程上下文切换会占用大量的cpu时间片，严重影响服务性能，而且大量的线程也需要占用大量的系统资源</p>
<p>这样就引出著名的<code>C10K</code>问题，如何在单台服务器上支持并发<code>10K</code>量级的连接</p>
<p>我们知道，虽然同一时间有大量的并发连接，但是同一时刻，只有少数的连接是可读/写的，我们完全可以只使用一个线程来服务提供服务，这也是目前解决<code>C10K</code>问题的主要思路，对应的解决方案叫做<strong>IO多路复用</strong>，现在主流的高性能网络服务器/框架都是基于该网络模型，比如<code>nginx</code>、<code>redis</code>或者<code>netty</code>网络库等。</p>
<p>说到这，就不得不提<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener"><code>epoll</code></a>，这是<code>linux</code>内核提供的用于实现<strong>IO多路复用</strong>的系统调用，其他操作系统上也有类似的接口，关于<code>epoll</code>具体内容网上有一大堆的<a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">资料</a>，这里就不重复介绍了</p>
<p><strong>IO多路复用模型</strong>，也可以称作是<strong>事件驱动模型</strong>，虽然能够有效解决<code>C10K</code>问题，但是相对传统的多线程模型也带来了一点复杂性。比如说，在多线程模型下，每个连接独占一个线程，而线程本身有自己的上下文；而如果是IO多路复用模型，需要在一个线程中处理多个连接，而每个需要有自己的上下文，需要开发者手动管理。比如服务端还没有接收到一个完整的协议报文时，我们需要把先前接收的部分内容保存到当前连接上下文中，等到下次其余内容到底时再一起处理。</p>
<p>今天，我们主要来看一下<code>go</code>中的网络模型。</p>
<p>在<code>go</code>中我们可以像传统的多线程模型那样为每个网络连接单独使用一个<code>goroutine</code>来提供服务，但是<code>goroutine</code>的资源占用相比系统级线程来说非常小，而且其切换在运行在用户态的，并且只需要交换很少的寄存器，因此<code>goroutine</code>的上下文切换代价也是极小的，更重要的是，其底层也是基于<code>epoll</code>（linux系统下）来实现事件通知的，因此只需要占用很少的系统级线程。</p>
<p>很明显可以看出，<code>go</code>中的网络IO模型是传统多线程模型和IO多路复用模型的结合，既有前者的易用性，又有后者的效率，因此使用<code>go</code>可以很容易地开发高性能服务器。</p>
<p>今天我们就来看一下，<code>go</code>中的网络IO模型是如何实现的。</p>
<h3 id="一切从创建Listener开始"><a href="#一切从创建Listener开始" class="headerlink" title="一切从创建Listener开始"></a>一切从创建Listener开始</h3><p>我们从创建<code>Listener</code>开始说起。</p>
<p>先看下面代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln,_ :=net.Listen(<span class="string">"tcp"</span>,<span class="string">":80"</span>)</span><br></pre></td></tr></table></figure>
<p>我们使用<code>Listen</code>来创建一个<code>Listener</code>，那么底层具体会发生什么呢？让我们一步一步来揭开</p>
<p>首先查看<code>net.Listen</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lc ListenConfig</span><br><span class="line">	<span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际上工作的是<code>ListenConfig.Listen</code>,我们继续往下看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lc *ListenConfig)</span> <span class="title">Listen</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">var</span> l Listener</span><br><span class="line">	la := addrs.first(isIPv4)</span><br><span class="line">	<span class="keyword">switch</span> la := la.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *TCPAddr:</span><br><span class="line">		l, err = sl.listenTCP(ctx, la)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们创建的是<code>tcp</code>连接，这里我们只关注<code>sl.listenTCP</code>方法，继续往下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span> <span class="title">listenTCP</span><span class="params">(ctx context.Context, laddr *TCPAddr)</span> <span class="params">(*TCPListener, error)</span></span> &#123;</span><br><span class="line">	fd, err := internetSocket(ctx, sl.network, laddr, <span class="literal">nil</span>, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"listen"</span>, sl.ListenConfig.Control)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;TCPListener&#123;fd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看函数第一行，调用了<code>internetSocket</code>，很明显里面就是创建实际<code>socket</code>的逻辑了，继续往下走</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr sockaddr, sotype, proto <span class="keyword">int</span>, mode <span class="keyword">string</span>, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (runtime.GOOS == <span class="string">"windows"</span> || runtime.GOOS == <span class="string">"openbsd"</span> || runtime.GOOS == <span class="string">"nacl"</span>) &amp;&amp; mode == <span class="string">"dial"</span> &amp;&amp; raddr.isWildcard() &#123;</span><br><span class="line">		raddr = raddr.toLocal(net)</span><br><span class="line">	&#125;</span><br><span class="line">	family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)</span><br><span class="line">	<span class="keyword">return</span> socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只看<code>linux</code>的情况，因此继续看<code>socket</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是实际创建socket的代码</span></span><br><span class="line">	s, err := sysSocket(family, sotype, proto)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置socket选项</span></span><br><span class="line">	<span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 根据socket创建netFD，netFD是net包对底层socket的封装</span></span><br><span class="line">	<span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sotype &#123;</span><br><span class="line">        <span class="comment">// 看上面的参数，我们传入的sotype是SOCK_STREAM，因此会走这个分支</span></span><br><span class="line">		<span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line">			<span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fd.Close()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line">			<span class="keyword">if</span> err := fd.listenDatagram(laddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fd.Close()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fd.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看<code>sysSocket</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysSocket</span><span class="params">(family, sotype, proto <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里的socketFunc实际上是创建socket的系统调用</span></span><br><span class="line">    <span class="comment">// 	socketFunc func(int, int, int) (int, error)  = syscall.Socket</span></span><br><span class="line">    <span class="comment">// 注意这里传入的SOCK_NONBLOCK，表明我们创建的是非阻塞的socket</span></span><br><span class="line">    <span class="comment">// 这里的SOCK_CLOEXEC表明在执行fork系统调用时，当执行exec时需要关闭从父进程继承的文件设备</span></span><br><span class="line">	s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)</span><br><span class="line">	<span class="keyword">switch</span> err &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, os.NewSyscallError(<span class="string">"socket"</span>, err)</span><br><span class="line">        <span class="comment">// 低版本内核不支持创建时指定SOCK_NONBLOCK或者SOCK_CLOEXEC</span></span><br><span class="line">        <span class="comment">// 这时候需要分两步，先创建socket，然后再设置flag</span></span><br><span class="line">	<span class="keyword">case</span> syscall.EPROTONOSUPPORT, syscall.EINVAL:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要加锁，与fork操作互斥，防止在创建socket而没有设置`SOCK_CLOEXEC`时执行了fork和exec</span></span><br><span class="line">	syscall.ForkLock.RLock()</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">	s, err = socketFunc(family, sotype, proto)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 设置SOCK_COLEXEC</span></span><br><span class="line">		syscall.CloseOnExec(s)</span><br><span class="line">	&#125;</span><br><span class="line">	syscall.ForkLock.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, os.NewSyscallError(<span class="string">"socket"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置非阻塞IO</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.SetNonblock(s, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, os.NewSyscallError(<span class="string">"setnonblock"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sysSocket</code>主要通过系统调用创建了<code>socket</code>，<strong>同时设置了<code>SOCK_NONBLOCK</code>标志位</strong>，这点非常重要，这里要明确，我们在<code>go</code>中使用的网络连接一般都是非阻塞的。关于阻塞IO和非阻塞IO的区别网上有一大堆的资料，这里就不重复说明了。使用非阻塞IO的主要的原因是，<strong>在go中，当使用阻塞系统调用时，当前goroutine对应的底层系统级线程就会被占用，无法与当前g解绑为其他g提供服务</strong>，这样当需要执行其他<code>g</code>时就需要创建新的线程来执行</p>
<p>接着来看<code>netFd.listenStream</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">listenStream</span><span class="params">(laddr sockaddr, backlog <span class="keyword">int</span>, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 为socket绑定监听的ip和端口</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.Bind(fd.pfd.Sysfd, lsa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> os.NewSyscallError(<span class="string">"bind"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// listenFunc func(int, int) error = syscall.Listen</span></span><br><span class="line">    <span class="comment">// 这里的listenFunc实际上是系统调用Listen</span></span><br><span class="line">    <span class="comment">// 开始监听</span></span><br><span class="line">	<span class="keyword">if</span> err = listenFunc(fd.pfd.Sysfd, backlog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> os.NewSyscallError(<span class="string">"listen"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 执行初始化操作</span></span><br><span class="line">	<span class="keyword">if</span> err = fd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)</span><br><span class="line">	fd.setAddr(fd.addrFunc()(lsa), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是常规的绑定监听地址和端口，然后开始监听，这里重要的是<code>netFD.init</code>函数，先来看<code>netFD</code>的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">	pfd poll.FD</span><br><span class="line"></span><br><span class="line">	<span class="comment">// immutable until Close</span></span><br><span class="line">	family      <span class="keyword">int</span></span><br><span class="line">	sotype      <span class="keyword">int</span></span><br><span class="line">	isConnected <span class="keyword">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">	net         <span class="keyword">string</span></span><br><span class="line">	laddr       Addr</span><br><span class="line">	raddr       Addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">	fdmu fdMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">	Sysfd <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// I/O poller.</span></span><br><span class="line">	pd pollDesc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Writev cache.</span></span><br><span class="line">	iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">	csema <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">	isBlocking <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line">	<span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">	IsStream <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line">	<span class="comment">// message based socket connection.</span></span><br><span class="line">	ZeroReadIsEOF <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">	isFile <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看上面的<code>netFD.init</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里的pfd实际上就是poll.FD，用来表示一个网络连接或者打开的系统文件</span></span><br><span class="line">	<span class="keyword">return</span> fd.pfd.Init(fd.net, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下<code>pollFD.Init</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Init</span><span class="params">(net <span class="keyword">string</span>, pollable <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// We don't actually care about the various network types.</span></span><br><span class="line">	<span class="keyword">if</span> net == <span class="string">"file"</span> &#123;</span><br><span class="line">		fd.isFile = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pollable &#123;</span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里又有个init，这里的pd是pollDesc类型</span></span><br><span class="line">	err := fd.pd.init(fd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// If we could not initialize the runtime poller,</span></span><br><span class="line">		<span class="comment">// assume we are using blocking mode.</span></span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面又有个<code>init</code>函数，我们先来看一下<code>fd.pd</code>对应的<code>pollDesc</code>类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtimeCtx <span class="keyword">uintptr</span> <span class="comment">// 这个运行时上下文很重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下<code>init</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">init</span><span class="params">(fd *FD)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 保证runtime_pollServerInit只会执行一次</span></span><br><span class="line">    serverInit.Do(runtime_pollServerInit)</span><br><span class="line">    <span class="comment">// 执行runtime_pollOpen</span></span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="keyword">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ctx != <span class="number">0</span> &#123;</span><br><span class="line">			runtime_pollUnblock(ctx)</span><br><span class="line">			runtime_pollClose(ctx)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> syscall.Errno(errno)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 把返回值保存到runtimeCtx中</span></span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数才是关键所在，这里涉及到了<code>runtime_pollServerInit</code>和<code>runtime_pollOpen</code>两个函数，从命名可以很容易看出这两个函数是在<code>runtime</code>包中实现的，然后在链接器链接过来的</p>
<p>先来看一下<code>runtime_pollServerInit</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	netpollinit()</span><br><span class="line">	atomic.Store(&amp;netpollInited, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 执行系统调用创建epoll</span></span><br><span class="line">    <span class="comment">// 先尝试使用create1系统调用</span></span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> epfd &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这边的1024是历史原因，只要大于0就好了</span></span><br><span class="line">    <span class="comment">// 原先epoll底层使用hash表实现，需要传入一个size指定hash表的大小，后面基于rb-tree实现，因此这个参数没有实际意义了，大于0即可</span></span><br><span class="line">	epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">if</span> epfd &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		closeonexec(epfd)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"runtime: epollcreate failed with"</span>, -epfd)</span><br><span class="line">	throw(<span class="string">"runtime: netpollinit failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是创建了一个<code>epoll</code></p>
<p>再来看一下<code>runtime_pollOpen</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="params">(*pollDesc, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 分配一个pollDesc，这个pollDesc是runtime的pollDesc，和上面的pollDesc不是同一个东西，但是他们之间又有关联</span></span><br><span class="line">    pd := pollcache.alloc()</span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> pd.wg != <span class="number">0</span> &amp;&amp; pd.wg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked write on free polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.rg != <span class="number">0</span> &amp;&amp; pd.rg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked read on free polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pd.fd = fd</span><br><span class="line">	pd.closing = <span class="literal">false</span></span><br><span class="line">	pd.seq++</span><br><span class="line">	pd.rg = <span class="number">0</span></span><br><span class="line">	pd.rd = <span class="number">0</span></span><br><span class="line">	pd.wg = <span class="number">0</span></span><br><span class="line">	pd.wd = <span class="number">0</span></span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errno <span class="keyword">int32</span></span><br><span class="line">	errno = netpollopen(fd, pd)</span><br><span class="line">    <span class="comment">// 这里返回了pd的地址，也就是poll.pollDesc中的runtimeCtx实际上保存的就是runtime.pollDesc的地址</span></span><br><span class="line">	<span class="keyword">return</span> pd, <span class="keyword">int</span>(errno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">    <span class="comment">// 设置需要通知的实际类型，这里设置了边缘触发模式，关于epoll的边缘触发和水平触发模式可以网上有一堆的资料</span></span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    <span class="comment">// 可以看到，这里把pollDesc的地址存到了ev.Data中</span></span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    <span class="comment">// 执行epollctl系统调用，添加socket到epoll中</span></span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="keyword">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此一个<code>net.Listener</code>就创建完成了，总结一下主要的逻辑：</p>
<ol>
<li>创建一个非阻塞<code>socket</code>，并执行<code>bind</code>和<code>listen</code></li>
<li>如果没有初始化过<code>runtime</code>包的<code>epoll</code>，则执行初始化，创建一个<code>epoll</code></li>
<li>以边缘触发模式将<code>socket</code>添加到<code>epoll</code>中</li>
<li>返回封装后的<code>net.Listener</code></li>
</ol>
<h3 id="Accept又是如何执行的呢"><a href="#Accept又是如何执行的呢" class="headerlink" title="Accept又是如何执行的呢"></a>Accept又是如何执行的呢</h3><p>接下来我们来看一下执行<code>Accept</code>时会发生什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !l.ok() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, syscall.EINVAL</span><br><span class="line">	&#125;</span><br><span class="line">	c, err := l.accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"accept"</span>, Net: l.fd.net, Source: <span class="literal">nil</span>, Addr: l.fd.laddr, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *TCPListener)</span> <span class="title">accept</span><span class="params">()</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line">	fd, err := ln.fd.accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTCPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面创建的是一个<code>TcpListener</code>，因此自然是执行对应的<code>Accept</code>，可以看到是调用<code>netFD.Accept</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">accept</span><span class="params">()</span> <span class="params">(netfd *netFD, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 执行poll.FD的Accept方法，获取新的客户端连接</span></span><br><span class="line">	d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errcall != <span class="string">""</span> &#123;</span><br><span class="line">			err = wrapSyscallError(errcall, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 封装netFD</span></span><br><span class="line">	<span class="keyword">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(d)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里的netFD.init上面分析过了，就是将新的socket加入到epoll中</span></span><br><span class="line">	<span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fd.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class="line">	netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class="line">	<span class="keyword">return</span> netfd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下<code>poll.FD</code>的<code>Accept</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, syscall.Sockaddr, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">/// 首先尝试直接获取客户端连接</span></span><br><span class="line">		s, rsa, errcall, err := accept(fd.Sysfd)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// 获取成功，直接返回</span></span><br><span class="line">			<span class="keyword">return</span> s, rsa, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">            <span class="comment">// 因为我们创建的socket是非阻塞的，当没有新的连接可以accept时会直接返回EAGAIN而不是阻塞</span></span><br><span class="line">		<span class="keyword">case</span> syscall.EAGAIN:</span><br><span class="line">            <span class="comment">// 如果是可轮询的，表明可以等到epoll事件通知</span></span><br><span class="line">			<span class="keyword">if</span> fd.pd.pollable() &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> syscall.ECONNABORTED:</span><br><span class="line">			<span class="comment">// This means that a socket on the listen</span></span><br><span class="line">			<span class="comment">// queue was closed before we Accept()ed it;</span></span><br><span class="line">			<span class="comment">// it's a silly error, so try again.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, errcall, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accept</span><span class="params">(s <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, syscall.Sockaddr, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4</span></span><br><span class="line">    <span class="comment">// 首先使用系统调用accept4获取一个非阻塞的socket</span></span><br><span class="line">	ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)</span><br><span class="line">	<span class="keyword">switch</span> err &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> ns, sa, <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// errors other than the ones listed</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, sa, <span class="string">"accept4"</span>, err</span><br><span class="line">	<span class="keyword">case</span> syscall.ENOSYS: <span class="comment">// syscall missing</span></span><br><span class="line">	<span class="keyword">case</span> syscall.EINVAL: <span class="comment">// some Linux use this instead of ENOSYS</span></span><br><span class="line">	<span class="keyword">case</span> syscall.EACCES: <span class="comment">// some Linux use this instead of ENOSYS</span></span><br><span class="line">	<span class="keyword">case</span> syscall.EFAULT: <span class="comment">// some Linux use this instead of ENOSYS</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有些内核不支持accept4</span></span><br><span class="line">	ns, sa, err = AcceptFunc(s)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		syscall.CloseOnExec(ns)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">"accept"</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.SetNonblock(ns, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		CloseFunc(ns)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">"setnonblock"</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ns, sa, <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看<code>pollDesc.waitRead</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">waitRead</span><span class="params">(isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pd.wait(<span class="string">'r'</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">wait</span><span class="params">(mode <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"waiting for unsupported file type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 又是一个runtime包的方法</span></span><br><span class="line">	res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">	<span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看一下<code>runtime_pollWait</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	err := netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// As for now only Solaris uses level-triggered IO.</span></span><br><span class="line">	<span class="keyword">if</span> GOOS == <span class="string">"solaris"</span> &#123;</span><br><span class="line">		netpollarm(pd, mode)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 实际干活的是netpollblock</span></span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		err = netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Can happen if timeout has fired and unblocked us,</span></span><br><span class="line">		<span class="comment">// but before we had a chance to run, timeout has been reset.</span></span><br><span class="line">		<span class="comment">// Pretend it has not happened and retry.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里如果是'r'模式，则gpp是&amp;pd.rg</span></span><br><span class="line">    <span class="comment">// 'w'模式则是'&amp;pd.wg'</span></span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cas操作，设置gpp为pdwait</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := *gpp</span><br><span class="line">		<span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">			*gpp = <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"runtime: double wait"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Casuintptr(gpp, <span class="number">0</span>, pdWait) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里直接执行gopark，将当前协程挂起 ^-^</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 这里netpollblockcommit会被调用，把当前g的引用保存到gpp中，也就是pollDesc的rg或者wg中</span></span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// be careful to not lose concurrent READY notification</span></span><br><span class="line">	old := atomic.Xchguintptr(gpp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">		throw(<span class="string">"runtime: corrupted polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，<code>Accept</code>的流程也很清晰了：</p>
<ol>
<li>首先直接尝试通过<code>socket</code>执行<code>accept</code>来获取可能的客户端连接</li>
<li>如果此时客户端没有连接，因为<code>socket</code>是非阻塞模式，会直接返回<code>EAGAIN</code></li>
<li>调用<code>runtime.poll_runtime_pollWait</code>将当前协程挂起，并且根据是等待读还是等待写将当前<code>g</code>的引用保存到<code>pollDesc</code>中的<code>rg</code>或者<code>wg</code>中</li>
<li>当有新的客户端连接到来时，<code>epoll</code>会通知将当前阻塞的协程恢复，然后重新执行第一步</li>
</ol>
<h3 id="那么epoll的wait又是什么时候调用的呢"><a href="#那么epoll的wait又是什么时候调用的呢" class="headerlink" title="那么epoll的wait又是什么时候调用的呢"></a>那么epoll的wait又是什么时候调用的呢</h3><p>我们可以在协程的调度逻辑中看到这样一段代码段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 这里的netpoll的参数false表示不阻塞</span></span><br><span class="line">	<span class="keyword">if</span> gp := netpoll(<span class="literal">false</span>); gp != <span class="literal">nil</span> &#123; </span><br><span class="line">           <span class="comment">// 这里获取的可能是一个列表，将后面多余的g加入调度队列，这里调度一次只能调度一个</span></span><br><span class="line">		injectglist(gp.schedlink.ptr())</span><br><span class="line">           <span class="comment">// 设置g为runnable</span></span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下<code>netpoll</code>的执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(block <span class="keyword">bool</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	waitms := <span class="keyword">int32</span>(<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 调度逻辑中传入的是0</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		waitms = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 执行epoll_wait系统调用</span></span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: epollwait on fd"</span>, epfd, <span class="string">"failed with"</span>, -n)</span><br><span class="line">			throw(<span class="string">"runtime: netpoll failed"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里gp是一个链表</span></span><br><span class="line">	<span class="keyword">var</span> gp guintptr</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">		<span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">'r'</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">'w'</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从ev.data取出pollDesc，还记得上面分析过，在加入epoll时会把对应的pollDesc保存到ev.Data中，而协程阻塞时会把g指针保存在pollDesc中的rg或者wg中</span></span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			<span class="comment">// 这里执行netpollready，把对应阻塞的g加到gp链表头部</span></span><br><span class="line">			netpollready(&amp;gp, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> block &amp;&amp; gp == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gp.ptr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(gpp *guintptr, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg guintptr</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'r'</span> || mode == <span class="string">'r'</span>+<span class="string">'w'</span> &#123;</span><br><span class="line">        <span class="comment">// 这里调用了netpollunblock，获取对应的g</span></span><br><span class="line">		rg.set(netpollunblock(pd, <span class="string">'r'</span>, <span class="literal">true</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> || mode == <span class="string">'r'</span>+<span class="string">'w'</span> &#123;</span><br><span class="line">		wg.set(netpollunblock(pd, <span class="string">'w'</span>, <span class="literal">true</span>))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 链表设置，将新的g添加到链表头部</span></span><br><span class="line">	<span class="keyword">if</span> rg != <span class="number">0</span> &#123;</span><br><span class="line">		rg.ptr().schedlink = *gpp</span><br><span class="line">		*gpp = rg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="number">0</span> &#123;</span><br><span class="line">		wg.ptr().schedlink = *gpp</span><br><span class="line">		*gpp = wg</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, ioready <span class="keyword">bool</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果是等待读则rg是阻塞的g的引用</span></span><br><span class="line">    <span class="comment">// 如果是等待写则wg是阻塞的g的引用</span></span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := *gpp</span><br><span class="line">		<span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; !ioready &#123;</span><br><span class="line">			<span class="comment">// Only set READY for ioready. runtime_pollWait</span></span><br><span class="line">			<span class="comment">// will check for timeout/cancel before waiting.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> <span class="built_in">new</span> <span class="keyword">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> ioready &#123;</span><br><span class="line">			<span class="built_in">new</span> = pdReady</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 状态为ready</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Casuintptr(gpp, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old == pdReady || old == pdWait &#123;</span><br><span class="line">				old = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在执行协程的调度时，会执行<code>epoll_wait</code>系统调用，获取已经准备好的<code>socket</code>，并唤醒对应的<code>goroutine</code></p>
<p>除了在调度时会执行<code>epoll_wait</code>，在后台线程<code>sysmon</code>中也会定时执行<code>epoll_wait</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">			gp := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(gp)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大同小异的读写操作"><a href="#大同小异的读写操作" class="headerlink" title="大同小异的读写操作"></a>大同小异的读写操作</h3><p>那么接下来，我们来看一下<code>Read</code>操作，实际上<code>Read</code>最后会执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !c.ok() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, syscall.EINVAL</span><br><span class="line">   &#125;</span><br><span class="line">   n, err := c.fd.Read(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">      err = &amp;OpError&#123;Op: <span class="string">"read"</span>, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	n, err = fd.pfd.Read(p)</span><br><span class="line">	runtime.KeepAlive(fd)</span><br><span class="line">	<span class="keyword">return</span> n, wrapSyscallError(<span class="string">"read"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到了<code>poll.FD</code>的<code>Read</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里执行对应的加锁操作</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 首先尝试直接读，如果无可读内容，因为是非阻塞模式，会返回EAGAIN</span></span><br><span class="line">		n, err := syscall.Read(fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">                <span class="comment">// 这里的waitRead有没有似曾相识？这个方法在accept流程的时候已经分析过了，最后会将当前协程挂起</span></span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// On MacOS we can see EINTR here if the user</span></span><br><span class="line">			<span class="comment">// pressed ^Z.  See issue #22838.</span></span><br><span class="line">			<span class="keyword">if</span> runtime.GOOS == <span class="string">"darwin"</span> &amp;&amp; err == syscall.EINTR &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下写过程，最后会执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里执行对应的加锁操作</span></span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 记录已经写入字节数</span></span><br><span class="line">	<span class="keyword">var</span> nn <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		max := <span class="built_in">len</span>(p)</span><br><span class="line">		<span class="keyword">if</span> fd.IsStream &amp;&amp; max-nn &gt; maxRW &#123;</span><br><span class="line">			max = nn + maxRW</span><br><span class="line">		&#125;</span><br><span class="line">		n, err := syscall.Write(fd.Sysfd, p[nn:max])</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nn += n</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 写入方法与读方法的区别在于，读方法只要读取到内容就会返回</span></span><br><span class="line">        <span class="comment">// 而写入需要将传入的字节切片全部写入才返回</span></span><br><span class="line">		<span class="keyword">if</span> nn == <span class="built_in">len</span>(p) &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, err</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 这里的waitWrite和上面的waitRead类似</span></span><br><span class="line">		<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">			<span class="keyword">if</span> err = fd.pd.waitWrite(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nn, io.ErrUnexpectedEOF</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实最后都是调用的pd.wait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">waitWrite</span><span class="params">(isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pd.wait(<span class="string">'w'</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用runtime_pollWait将当前协程挂起</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">wait</span><span class="params">(mode <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"waiting for unsupported file type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">	<span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差点被遗忘的close"><a href="#差点被遗忘的close" class="headerlink" title="差点被遗忘的close"></a>差点被遗忘的close</h3><p>接着来看一下<code>Close</code>方法，实际执行的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !c.ok() &#123;</span><br><span class="line">		<span class="keyword">return</span> syscall.EINVAL</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里执行netFD.Close</span></span><br><span class="line">	err := c.fd.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = &amp;OpError&#123;Op: <span class="string">"close"</span>, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 清除finalizer</span></span><br><span class="line">	runtime.SetFinalizer(fd, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 调用poll.FD的Close方法</span></span><br><span class="line">	<span class="keyword">return</span> fd.pfd.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !fd.fdmu.increfAndClose() &#123;</span><br><span class="line">		<span class="keyword">return</span> errClosing(fd.isFile)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里evict方法唤醒所有阻塞读写的g</span></span><br><span class="line">	fd.pd.evict()</span><br><span class="line">	<span class="comment">// 减少引用，如果引用为0则关闭</span></span><br><span class="line">	err := fd.decref()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fd.isBlocking == <span class="number">0</span> &#123;</span><br><span class="line">		runtime_Semacquire(&amp;fd.csema)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">evict</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	runtime_pollUnblock(pd.runtimeCtx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollUnblock</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> pd.closing &#123;</span><br><span class="line">		throw(<span class="string">"runtime: unblock on closing polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pd.closing = <span class="literal">true</span></span><br><span class="line">	pd.seq++</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;rg), <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 获取阻塞的g</span></span><br><span class="line">	rg = netpollunblock(pd, <span class="string">'r'</span>, <span class="literal">false</span>)</span><br><span class="line">	wg = netpollunblock(pd, <span class="string">'w'</span>, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> pd.rt.f != <span class="literal">nil</span> &#123;</span><br><span class="line">		deltimer(&amp;pd.rt)</span><br><span class="line">		pd.rt.f = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.wt.f != <span class="literal">nil</span> &#123;</span><br><span class="line">		deltimer(&amp;pd.wt)</span><br><span class="line">		pd.wt.f = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 调用goready唤醒g</span></span><br><span class="line">		netpollgoready(rg, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒g</span></span><br><span class="line">		netpollgoready(wg, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">decref</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 减少引用，如果引用为0，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> fd.fdmu.decref() &#123;</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">		<span class="keyword">return</span> fd.destroy()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">destroy</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用runtime_pollClose方法</span></span><br><span class="line">	fd.pd.<span class="built_in">close</span>()</span><br><span class="line">    <span class="comment">// var CloseFunc func(int) error = syscall.Close</span></span><br><span class="line">    <span class="comment">// 这里的CloseFunc就是系统调用close</span></span><br><span class="line">	err := CloseFunc(fd.Sysfd)</span><br><span class="line">	fd.Sysfd = <span class="number">-1</span></span><br><span class="line">	runtime_Semrelease(&amp;fd.csema)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	runtime_pollClose(pd.runtimeCtx)</span><br><span class="line">	pd.runtimeCtx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollClose</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !pd.closing &#123;</span><br><span class="line">		throw(<span class="string">"runtime: close polldesc w/o unblock"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.wg != <span class="number">0</span> &amp;&amp; pd.wg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked write on closing polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.rg != <span class="number">0</span> &amp;&amp; pd.rg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked read on closing polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从epoll中删除fd</span></span><br><span class="line">	netpollclose(pd.fd)</span><br><span class="line">    <span class="comment">// 释放pollDesc</span></span><br><span class="line">	pollcache.free(pd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollclose</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">    <span class="comment">// 系统调用epoll_ctl删除对应的fd</span></span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_DEL, <span class="keyword">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，关闭一个连接时：</p>
<ol>
<li>设置pollDesc相关flag为已关闭，唤醒该连接上阻塞的协程</li>
<li>减少对应poll.FD的引用，如果引用为0，则只需真正的关闭</li>
<li>执行关闭操作，先从epoll删除对应的fd，然后执行close系统调用关闭</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>可以看到，<code>go</code>使用非阻塞IO来防止大量系统线程阻塞带来的上下文切换，取而代之的是让轻量级的协程阻塞在IO事件上，然后通过<code>epoll</code>来实现IO事件通知，唤醒阻塞的协程。</p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>