<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        net/rpc分析 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#rpc"><span class="toc-text">rpc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-text">server</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#service"><span class="toc-text">service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#server-1"><span class="toc-text">server</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Request-amp-Response"><span class="toc-text">Request &amp; Response</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Register"><span class="toc-text">Register</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#启动服务"><span class="toc-text">启动服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#处理请求"><span class="toc-text">处理请求</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#client"><span class="toc-text">client</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#client-1"><span class="toc-text">client</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Call"><span class="toc-text">Call</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NewClient"><span class="toc-text">NewClient</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Call-1"><span class="toc-text">Call</span></a></li></ol></li>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        net/rpc分析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-02-28 16:50:08</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#go" title="go">go</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><p><code>golang</code>本身提供了<code>net/rpc</code>标准库，用于提供<code>rpc</code>服务。</p>
<p><code>rpc</code>通过将网络传输和数据序列化/反序列化屏蔽在接口背后，提供一种简洁的调用接口，已达到调用远程服务方法在执行本地方法一样。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><p><code>service</code>代表每个注册的服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> methodType <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex 				  <span class="comment">// protects counters</span></span><br><span class="line">	method     reflect.Method <span class="comment">// 方法信息</span></span><br><span class="line">	ArgType    reflect.Type   <span class="comment">// 第一个参数类型</span></span><br><span class="line">	ReplyType  reflect.Type   <span class="comment">// 第二个参数类型，该参数用来返回结果</span></span><br><span class="line">	numCalls   <span class="keyword">uint</span>           <span class="comment">// 统计调用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span>                 <span class="comment">// 服务名</span></span><br><span class="line">	rcvr   reflect.Value          <span class="comment">// 服务对象的值</span></span><br><span class="line">	typ    reflect.Type           <span class="comment">// 服务对象的类型</span></span><br><span class="line">	method <span class="keyword">map</span>[<span class="keyword">string</span>]*methodType <span class="comment">// 该服务对外提供的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h5><p><code>server</code>代表一个<code>rpc server</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	serviceMap sync.Map     <span class="comment">// 注册的服务：map[string]*service</span></span><br><span class="line">	reqLock    sync.Mutex   <span class="comment">// protects freeReq</span></span><br><span class="line">	freeReq    *Request     <span class="comment">// 缓存Request列表，避免每次请求都要重新创建一个</span></span><br><span class="line">	respLock   sync.Mutex   <span class="comment">// protects freeResp</span></span><br><span class="line">	freeResp   *Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request is a header written before every RPC call. It is used internally</span></span><br><span class="line"><span class="comment">// but documented here as an aid to debugging, such as when analyzing</span></span><br><span class="line"><span class="comment">// network traffic.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServiceMethod <span class="keyword">string</span>   <span class="comment">// format: "Service.Method"</span></span><br><span class="line">	Seq           <span class="keyword">uint64</span>   <span class="comment">// 请求的Seq，客户端会对请求进行编号，用于区分不同的请求</span></span><br><span class="line">	next          *Request <span class="comment">// for free list in Server</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is a header written before every RPC return. It is used internally</span></span><br><span class="line"><span class="comment">// but documented here as an aid to debugging, such as when analyzing</span></span><br><span class="line"><span class="comment">// network traffic.</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServiceMethod <span class="keyword">string</span>    <span class="comment">// echoes that of the Request</span></span><br><span class="line">	Seq           <span class="keyword">uint64</span>    <span class="comment">// echoes that of the request</span></span><br><span class="line">	Error         <span class="keyword">string</span>    <span class="comment">// error, if any.</span></span><br><span class="line">	next          *Response <span class="comment">// for free list in Server</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Register</span><span class="params">(rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用反射名作为服务名称</span></span><br><span class="line">    <span class="keyword">return</span> server.register(rcvr, <span class="string">""</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 自定义服务名称</span></span><br><span class="line">   <span class="keyword">return</span> server.register(rcvr, name, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">register</span><span class="params">(rcvr <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, useName <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   s := <span class="built_in">new</span>(service) </span><br><span class="line">   s.typ = reflect.TypeOf(rcvr)   <span class="comment">// 设置类型</span></span><br><span class="line">   s.rcvr = reflect.ValueOf(rcvr) <span class="comment">// 设置值</span></span><br><span class="line">   <span class="comment">// 默认取类型名</span></span><br><span class="line">   sname := reflect.Indirect(s.rcvr).Type().Name()</span><br><span class="line">   <span class="keyword">if</span> useName &#123; <span class="comment">// 如果需要使用自定义名称</span></span><br><span class="line">      sname = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> sname == <span class="string">""</span> &#123;</span><br><span class="line">      s := <span class="string">"rpc.Register: no service name for type "</span> + s.typ.String()</span><br><span class="line">      log.Print(s)</span><br><span class="line">      <span class="keyword">return</span> errors.New(s)</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 如果该service不是导出类型，保错</span></span><br><span class="line">   <span class="keyword">if</span> !isExported(sname) &amp;&amp; !useName &#123;</span><br><span class="line">      s := <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" is not exported"</span></span><br><span class="line">      log.Print(s)</span><br><span class="line">      <span class="keyword">return</span> errors.New(s)</span><br><span class="line">   &#125;</span><br><span class="line">   s.name = sname</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存找该services用于提供对外服务的方法</span></span><br><span class="line">   s.method = suitableMethods(s.typ, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 方法数必须大于0</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(s.method) == <span class="number">0</span> &#123;</span><br><span class="line">      str := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// To help the user, see if a pointer receiver would work.</span></span><br><span class="line">      method := suitableMethods(reflect.PtrTo(s.typ), <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(method) != <span class="number">0</span> &#123;</span><br><span class="line">         str = <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" has no exported methods of suitable type (hint: pass a pointer to value of that type)"</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         str = <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" has no exported methods of suitable type"</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.Print(str)</span><br><span class="line">      <span class="keyword">return</span> errors.New(str)</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">// 不允许同一个服务名称重复注册</span></span><br><span class="line">   <span class="keyword">if</span> _, dup := server.serviceMap.LoadOrStore(sname, s); dup &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">"rpc: service already defined: "</span> + sname)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>suitableMethods</code>用来查找<code>service</code>中需要暴露的方法，实现就是遍历该<code>service</code>的所有方法，并返回其中符合条件的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suitableMethods</span><span class="params">(typ reflect.Type, reportErr <span class="keyword">bool</span>)</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">methodType</span></span> &#123;</span><br><span class="line">	methods := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*methodType)</span><br><span class="line">    <span class="comment">// 遍历方法</span></span><br><span class="line">	<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; typ.NumMethod(); m++ &#123;</span><br><span class="line">		method := typ.Method(m)</span><br><span class="line">		mtype := method.Type</span><br><span class="line">		mname := method.Name</span><br><span class="line">		<span class="comment">// Method must be exported.</span></span><br><span class="line">        <span class="comment">// 如果method是导出的（方法名首字母大写），PkgPath为空</span></span><br><span class="line">		<span class="keyword">if</span> method.PkgPath != <span class="string">""</span> &#123; </span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Method needs three ins: receiver, *args, *reply.</span></span><br><span class="line">        <span class="comment">// 参数个数必须为3，其中第一个参数为service对象</span></span><br><span class="line">		<span class="keyword">if</span> mtype.NumIn() != <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: method %q has %d input parameters; needs exactly three\n"</span>, mname, mtype.NumIn())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// First arg need not be a pointer.</span></span><br><span class="line">		<span class="comment">// 第二个参数必须是内置类型或者自定义的导出类型，不需要是指针类型</span></span><br><span class="line">        argType := mtype.In(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> !isExportedOrBuiltinType(argType) &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: argument type of method %q is not exported: %q\n"</span>, mname, argType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Second arg must be a pointer.</span></span><br><span class="line">		replyType := mtype.In(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 第三个参数必须是指针类型，该参数用来向客户端返回请求结果</span></span><br><span class="line">		<span class="keyword">if</span> replyType.Kind() != reflect.Ptr &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: reply type of method %q is not a pointer: %q\n"</span>, mname, replyType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Reply type must be exported.</span></span><br><span class="line">        <span class="comment">// 该参数也必须是内置类型或者导出类型</span></span><br><span class="line">		<span class="keyword">if</span> !isExportedOrBuiltinType(replyType) &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: reply type of method %q is not exported: %q\n"</span>, mname, replyType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Method needs one out.</span></span><br><span class="line">        <span class="comment">// 方法必须有且只有一个error类型的返回值</span></span><br><span class="line">		<span class="keyword">if</span> mtype.NumOut() != <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: method %q has %d output parameters; needs exactly one\n"</span>, mname, mtype.NumOut())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The return type of the method must be error.</span></span><br><span class="line">		<span class="keyword">if</span> returnType := mtype.Out(<span class="number">0</span>); returnType != typeOfError &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">"rpc.Register: return type of method %q is %q, must be error\n"</span>, mname, returnType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 符合条件，添加</span></span><br><span class="line">		methods[mname] = &amp;methodType&#123;method: method, ArgType: argType, ReplyType: replyType&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Accept</span><span class="params">(lis net.Listener)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      conn, err := lis.Accept()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Print(<span class="string">"rpc.Serve: accept:"</span>, err.Error())</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 每个客户启用一个goroutine进行处理</span></span><br><span class="line">      <span class="keyword">go</span> server.ServeConn(conn)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeConn</span><span class="params">(conn io.ReadWriteCloser)</span></span> &#123;</span><br><span class="line">	buf := bufio.NewWriter(conn)</span><br><span class="line">    <span class="comment">// 默认使用gob编解码</span></span><br><span class="line">	srv := &amp;gobServerCodec&#123;</span><br><span class="line">		rwc:    conn,</span><br><span class="line">		dec:    gob.NewDecoder(conn),</span><br><span class="line">		enc:    gob.NewEncoder(buf),</span><br><span class="line">		encBuf: buf,</span><br><span class="line">	&#125;</span><br><span class="line">	server.ServeCodec(srv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec)</span></span> &#123;</span><br><span class="line">	sending := <span class="built_in">new</span>(sync.Mutex) <span class="comment">// 写response内容时需要加锁</span></span><br><span class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从连接中读取请求，主要是通过gobEncoder实现</span></span><br><span class="line">		service, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &#123;</span><br><span class="line">				log.Println(<span class="string">"rpc:"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !keepReading &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// send a response if we actually managed to read a header.</span></span><br><span class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</span><br><span class="line">				server.sendResponse(sending, req, invalidRequest, codec, err.Error())</span><br><span class="line">				server.freeRequest(req)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 每个rpc都使用一个goroutine进行处理</span></span><br><span class="line">		<span class="keyword">go</span> service.call(server, sending, wg, mtype, req, argv, replyv, codec)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 优雅关闭</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	codec.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">call</span><span class="params">(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">	mtype.Lock()</span><br><span class="line">	mtype.numCalls++ <span class="comment">// 统计调用次数</span></span><br><span class="line">	mtype.Unlock()</span><br><span class="line">	function := mtype.method.Func</span><br><span class="line">	<span class="comment">// 调用具体的请求方法</span></span><br><span class="line">	returnValues := function.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)</span><br><span class="line">	<span class="comment">// The return value for the method is an error.</span></span><br><span class="line">	errInter := returnValues[<span class="number">0</span>].Interface()</span><br><span class="line">	errmsg := <span class="string">""</span></span><br><span class="line">    <span class="comment">// 如果请求方法返回error</span></span><br><span class="line">	<span class="keyword">if</span> errInter != <span class="literal">nil</span> &#123;</span><br><span class="line">		errmsg = errInter.(error).Error()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 写入响应结果，这里主要通过gob.Decoder实现</span></span><br><span class="line">	server.sendResponse(sending, req, replyv.Interface(), codec, errmsg)</span><br><span class="line">	<span class="comment">// 释放req</span></span><br><span class="line">    server.freeRequest(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><h5 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	codec ClientCodec <span class="comment">// codec</span></span><br><span class="line"></span><br><span class="line">	reqMutex sync.Mutex <span class="comment">// protects following</span></span><br><span class="line">	request  Request</span><br><span class="line"></span><br><span class="line">	mutex    sync.Mutex <span class="comment">// protects following</span></span><br><span class="line">	seq      <span class="keyword">uint64</span> <span class="comment">// 下一次请求的seq</span></span><br><span class="line">	pending  <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Call <span class="comment">// 正在执行的请求</span></span><br><span class="line">	closing  <span class="keyword">bool</span> <span class="comment">// user has called Close</span></span><br><span class="line">	shutdown <span class="keyword">bool</span> <span class="comment">// server has told us to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Call <span class="keyword">struct</span> &#123;</span><br><span class="line">   ServiceMethod <span class="keyword">string</span>      <span class="comment">// 调用的远程方法</span></span><br><span class="line">   Args          <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 方法第一个参数</span></span><br><span class="line">   Reply         <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 第二个参数，用于接收返回值</span></span><br><span class="line">   Error         error       <span class="comment">// 保存请求的错误信息</span></span><br><span class="line">   Done          <span class="keyword">chan</span> *Call  <span class="comment">// 用于通知请求结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NewClient"><a href="#NewClient" class="headerlink" title="NewClient"></a>NewClient</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn io.ReadWriteCloser)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">	encBuf := bufio.NewWriter(conn)</span><br><span class="line">	client := &amp;gobClientCodec&#123;conn, gob.NewDecoder(conn), gob.NewEncoder(encBuf), encBuf&#125;</span><br><span class="line">	<span class="keyword">return</span> NewClientWithCodec(client)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientWithCodec</span><span class="params">(codec ClientCodec)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">	client := &amp;Client&#123;</span><br><span class="line">		codec:   codec,</span><br><span class="line">		pending: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]*Call),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> client.input() <span class="comment">// input用来处理server的响应</span></span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Call-1"><a href="#Call-1" class="headerlink" title="Call"></a>Call</h5><p>使用方法<code>Call</code>和方法<code>Go</code>调用远程方法，其中<code>Call</code>会同步等待请求结束，<code>Go</code>是异步执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Call</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Call方法内部也是调用Go，然后等待调用完成后返回</span></span><br><span class="line">	call := &lt;-client.Go(serviceMethod, args, reply, <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">1</span>)).Done</span><br><span class="line">	<span class="keyword">return</span> call.Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go方法返回一个channel用来通知调用结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Go</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, done <span class="keyword">chan</span> *Call)</span> *<span class="title">Call</span></span> &#123;</span><br><span class="line">	call := <span class="built_in">new</span>(Call)</span><br><span class="line">	call.ServiceMethod = serviceMethod</span><br><span class="line">	call.Args = args</span><br><span class="line">	call.Reply = reply</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		done = <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">10</span>) <span class="comment">// buffered.</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// If caller passes done != nil, it must arrange that</span></span><br><span class="line">		<span class="comment">// done has enough buffer for the number of simultaneous</span></span><br><span class="line">		<span class="comment">// RPCs that will be using that channel. If the channel</span></span><br><span class="line">		<span class="comment">// is totally unbuffered, it's best not to run at all.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span>(done) == <span class="number">0</span> &#123;</span><br><span class="line">			log.Panic(<span class="string">"rpc: done channel is unbuffered"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	call.Done = done</span><br><span class="line">	client.send(call)</span><br><span class="line">	<span class="keyword">return</span> call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send执行实际的请求发送</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">send</span><span class="params">(call *Call)</span></span> &#123;</span><br><span class="line">	client.reqMutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> client.reqMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register this call.</span></span><br><span class="line">	client.mutex.Lock()</span><br><span class="line">	<span class="keyword">if</span> client.shutdown || client.closing &#123;</span><br><span class="line">		client.mutex.Unlock()</span><br><span class="line">		call.Error = ErrShutdown</span><br><span class="line">		call.done()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	seq := client.seq <span class="comment">// 获取此次请求seq</span></span><br><span class="line">	client.seq++ <span class="comment">// 计算下一次请求seq</span></span><br><span class="line">	client.pending[seq] = call <span class="comment">// 加入pending列表中</span></span><br><span class="line">	client.mutex.Unlock() </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Encode and send the request.</span></span><br><span class="line">	client.request.Seq = seq</span><br><span class="line">	client.request.ServiceMethod = call.ServiceMethod</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">	err := client.codec.WriteRequest(&amp;client.request, call.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		client.mutex.Lock()</span><br><span class="line">		call = client.pending[seq]</span><br><span class="line">		<span class="built_in">delete</span>(client.pending, seq)</span><br><span class="line">		client.mutex.Unlock()</span><br><span class="line">		<span class="keyword">if</span> call != <span class="literal">nil</span> &#123;</span><br><span class="line">			call.Error = err</span><br><span class="line">			call.done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析上面的<code>send</code>方法，当请求发送出去之后就返回了，那么如何处理请求的响应呢？我们可以看到每次新的请求都会加入到<code>client.pending</code>中，那么对应的应该有一个幕后的协程来处理，当收到<code>server</code>的响应时，根据<code>seq</code>获取对应的<code>call</code>，然后通过<code>call.Done</code>通知请求完成，</p>
<p>对应的方法为<code>input</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">input</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> response Response</span><br><span class="line">	<span class="keyword">for</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		response = Response&#123;&#125;</span><br><span class="line">        <span class="comment">// 读取server的返回结果</span></span><br><span class="line">		err = client.codec.ReadResponseHeader(&amp;response)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 获取这次响应对应的请求的seq</span></span><br><span class="line">		seq := response.Seq</span><br><span class="line">		client.mutex.Lock()</span><br><span class="line">        <span class="comment">// 获取对应的请求</span></span><br><span class="line">		call := client.pending[seq]</span><br><span class="line">		<span class="built_in">delete</span>(client.pending, seq)</span><br><span class="line">		client.mutex.Unlock()</span><br><span class="line">		<span class="comment">// 处理响应结果</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> call == <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// We've got no pending call. That usually means that</span></span><br><span class="line">			<span class="comment">// WriteRequest partially failed, and call was already</span></span><br><span class="line">			<span class="comment">// removed; response is a server telling us about an</span></span><br><span class="line">			<span class="comment">// error reading request body. We should still attempt</span></span><br><span class="line">			<span class="comment">// to read error body, but there's no one to give it to.</span></span><br><span class="line">			err = client.codec.ReadResponseBody(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">"reading error body: "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> response.Error != <span class="string">""</span>:</span><br><span class="line">			<span class="comment">// We've got an error response. Give this to the request;</span></span><br><span class="line">			<span class="comment">// any subsequent requests will get the ReadResponseBody</span></span><br><span class="line">			<span class="comment">// error if there is one.</span></span><br><span class="line">			call.Error = ServerError(response.Error)</span><br><span class="line">			err = client.codec.ReadResponseBody(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">"reading error body: "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			call.done()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			err = client.codec.ReadResponseBody(call.Reply)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				call.Error = errors.New(<span class="string">"reading body "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			call.done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 发生错误退出之后，停止所有等待的请求</span></span><br><span class="line">	<span class="comment">// Terminate pending calls.</span></span><br><span class="line">	client.reqMutex.Lock()</span><br><span class="line">	client.mutex.Lock()</span><br><span class="line">	client.shutdown = <span class="literal">true</span></span><br><span class="line">	closing := client.closing</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="keyword">if</span> closing &#123;</span><br><span class="line">			err = ErrShutdown</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = io.ErrUnexpectedEOF</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 停止所有等待的请求</span></span><br><span class="line">	<span class="keyword">for</span> _, call := <span class="keyword">range</span> client.pending &#123;</span><br><span class="line">		call.Error = err</span><br><span class="line">		call.done()</span><br><span class="line">	&#125;</span><br><span class="line">	client.mutex.Unlock()</span><br><span class="line">	client.reqMutex.Unlock()</span><br><span class="line">	<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &amp;&amp; !closing &#123;</span><br><span class="line">		log.Println(<span class="string">"rpc: client protocol error:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知调用结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(call *Call)</span> <span class="title">done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> call.Done &lt;- call:</span><br><span class="line">		<span class="comment">// ok</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// We don't want to block here. It is the caller's responsibility to make</span></span><br><span class="line">		<span class="comment">// sure the channel has enough buffer space. See comment in Go().</span></span><br><span class="line">		<span class="keyword">if</span> debugLog &#123;</span><br><span class="line">			log.Println(<span class="string">"rpc: discarding Call reply due to insufficient Done chan capacity"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
