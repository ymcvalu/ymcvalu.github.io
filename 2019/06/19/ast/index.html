<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="fDu2EbXziVRK-QATAvl0GYkq0mLojeEfo2tAFJVbtek">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        ast - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

    <div class="site-nav-toggle" id="site-nav-toggle">
        <button>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
            <span class="btn-bar"></span>
        </button>
    </div>

    <div class="index-about">
        <i> mcll </i>
    </div>

    <div class="index-container">
        
        <div class="index-left">
            
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-ast"><span class="toc-text">go ast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ast-抽象语法树"><span class="toc-text">ast: 抽象语法树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码解析"><span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#来个例子"><span class="toc-text">来个例子</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
            <div class="index-about-mobile">
                <i> mcll </i>
            </div>
        </div>
        
        <div class="index-middle">
            <!-- Main Content -->
            


<div class="post-container">
    <div class="post-title">
        ast
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-06-19 16:04:07</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#golang" title="golang">golang</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h1 id="go-ast"><a href="#go-ast" class="headerlink" title="go ast"></a>go ast</h1><p><code>go</code>的官方库提供了几个包，可以帮我们解析<code>go</code>的源文件，主要有：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/master/src/go/scanner/scanner.go" target="_blank" rel="noopener">go/scanner</a>：词法解析，将源代码分割成一个个token</li>
<li><a href="https://github.com/golang/go/blob/master/src/go/token/token.go" target="_blank" rel="noopener">go/token</a>：token类型及相关结构体定义</li>
<li><a href="https://github.com/golang/go/blob/master/src/go/ast/ast.go" target="_blank" rel="noopener">go/ast</a>：ast的结构定义</li>
<li><a href="https://github.com/golang/go/blob/master/src/go/parser/parser.go#L17" target="_blank" rel="noopener">go/parser</a>：语法分析，读取token流生成ast</li>
</ul>
<p>通过解析源文件，我们可以得到<code>ast</code>(抽象语法树)。</p>
<p>而通过遍历<code>ast</code>，我们可以得到源码中声明的结构体、方法、类型等等信息，并根据实际需要<a href="https://github.com/ymcvalu/enhance/tree/master/enhance" target="_blank" rel="noopener">生成具体的代码</a>，比如自动生成<code>tag</code>，模板方法、手动实现泛型效果等。而且，go的注释在解析时是可以保留的，这就可以实现<code>java</code>中类似<code>annotation</code>的功能，比如根据注释自动生成接口文档（<a href="https://github.com/beego/bee/blob/develop/generate/swaggergen/g_docs.go" target="_blank" rel="noopener">beego的swagger文档生成</a>），根据注释提取接口权限信息实现统一权限校验等。</p>
<p>解析过程：</p>
<p>词法分析，将源代码分割成一个个token -&gt; 语法分析，根据<a href="https://golang.org/ref/spec" target="_blank" rel="noopener">go语言的文法</a>对token流进行规约/推导 -&gt; 生成ast</p>
<h3 id="ast-抽象语法树"><a href="#ast-抽象语法树" class="headerlink" title="ast: 抽象语法树"></a>ast: 抽象语法树</h3><p>ast是源代码结构的一种抽象表示，以树状形式来表达编程语言的语法结构。</p>
<p>比如表达式 <code>a+b</code>，对应的ast为：</p>
<p><img src="/img/ast1.png" alt=""></p>
<p>对应使用go表示的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*ast.BinaryExpr &#123; <span class="comment">// a+b是一个二元表达式</span></span><br><span class="line">.  X: *ast.Ident &#123; <span class="comment">// X表示第一个操作数</span></span><br><span class="line">.  .  Name: <span class="string">"a"</span></span><br><span class="line">.  .  &#125;</span><br><span class="line">.  &#125;</span><br><span class="line">.  Op: + <span class="comment">// 操作符</span></span><br><span class="line">.  Y: *ast.Ident &#123; <span class="comment">// Y表示第二个操作数</span></span><br><span class="line">.  .  Name: <span class="string">"b"</span></span><br><span class="line">.  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>首先要知道具体的接口怎么用，才知道源码从哪个入口开始看是吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"go/ast"</span></span><br><span class="line">	<span class="string">"go/parser"</span></span><br><span class="line">	<span class="string">"go/token"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建FileSet</span></span><br><span class="line">	fset := token.NewFileSet()</span><br><span class="line">	<span class="comment">// 解析源文件main.go，返回ast.File代表一个源文件的node</span></span><br><span class="line">	f, err := parser.ParseFile(fset, <span class="string">"./main.go"</span>, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印AST</span></span><br><span class="line">	ast.Print(fset, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看第12行代码，这里创建了一个<code>FileSet</code>，顾名思义，<code>FileSet</code>就是源文件集合，因为我们一次解析可能不止解析一个文件，而是一系列文件。</p>
<p><code>FileSet</code>最主要的用途是用来保存<code>token</code>的位置信息，每个token在当前文件的位置可以用行号，列号，token在当前文件中的偏移量这三个属性来描述，使用<a href="https://github.com/golang/go/blob/master/src/go/token/position.go#L20" target="_blank" rel="noopener"><code>Position</code></a>这个结构体来描述，<code>FileSet</code>中保存所有<code>token</code>的<code>Position</code>信息，而在<code>ast</code>中，只保存一个<a href="https://github.com/golang/go/blob/master/src/go/token/position.go#L76" target="_blank" rel="noopener"><code>Pos</code></a>索引。当遍历<code>ast</code>的时候，我们需要使用<code>Pos</code>索引向<a href=""><code>FileSet</code></a>获取<code>Position</code>。</p>
<p>现在来看一下14行<code>parser.ParseFile</code>这个方法，这个方法实现了语法分析：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFile</span><span class="params">(fset *token.FileSet, filename <span class="keyword">string</span>, src <span class="keyword">interface</span>&#123;&#125;, mode Mode)</span> <span class="params">(f *ast.File, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 必须要传入fset，用来保存Position信息</span></span><br><span class="line">    <span class="keyword">if</span> fset == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"parser.ParseFile: no token.FileSet provided (fset == nil)"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取源文件，如果src不为空，则从src读取，否则读取filename指定的文件</span></span><br><span class="line">	text, err := readSource(filename, src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p parser </span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parse source</span></span><br><span class="line">	p.init(fset, filename, text, mode) <span class="comment">// 初始化parser</span></span><br><span class="line">	f = p.parseFile() <span class="comment">// 解析源文件，生成AST</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先来简单看一下<code>parser.init</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *parser)</span> <span class="title">init</span><span class="params">(fset *token.FileSet, filename <span class="keyword">string</span>, src []<span class="keyword">byte</span>, mode Mode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 添加当前文件到FileSet中</span></span><br><span class="line">    p.file = fset.AddFile(filename, <span class="number">-1</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	<span class="keyword">var</span> m scanner.Mode</span><br><span class="line">    <span class="comment">// 设置scanner的mode，如果指定了ast需要保留注释，那么词法解析的时候需要解析注释</span></span><br><span class="line">	<span class="keyword">if</span> mode&amp;ParseComments != <span class="number">0</span> &#123;</span><br><span class="line">		m = scanner.ScanComments</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">	eh := <span class="function"><span class="keyword">func</span><span class="params">(pos token.Position, msg <span class="keyword">string</span>)</span></span> &#123; p.errors.Add(pos, msg) &#125;</span><br><span class="line">	<span class="comment">// 初始化词法解析器</span></span><br><span class="line">    p.scanner.Init(p.file, src, eh, m)</span><br><span class="line">	p.mode = mode</span><br><span class="line">	p.trace = mode&amp;Trace != <span class="number">0</span> <span class="comment">// for convenience (p.trace is used frequently)</span></span><br><span class="line">	<span class="comment">// parser.next会前进到下一个非注释的token，其中注释会被保留</span></span><br><span class="line">	p.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，注释有两种：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this</span></span><br><span class="line"><span class="comment">// is</span></span><br><span class="line"><span class="comment">// doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalNum <span class="keyword">int</span> <span class="comment">// this is a comment</span></span><br></pre></td></tr></table></figure>
<p>第一种是注释独自自己占一到多行的，后一种则是跟语句在同一行。<code>parser.next</code>方法中，读取<code>token</code>时，如果遇到第一种注释，会保存到<code>parser.leadComment</code>，如果是第二种注释，则保存到<code>parser.lineComment</code>中，最终会保留到具体的<code>ast</code>中的节点中。</p>
<p>接着来看一下<a href="https://github.com/golang/go/blob/master/src/go/parser/parser.go#L2500" target="_blank" rel="noopener"><code>parser.parseFile</code></a>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *parser)</span> <span class="title">parseFile</span><span class="params">()</span> *<span class="title">ast</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果执行parser.next时有错误发生</span></span><br><span class="line">	<span class="keyword">if</span> p.errors.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// package clause</span></span><br><span class="line">	doc := p.leadComment <span class="comment">// package前面的注释被认为是当前文件的doc</span></span><br><span class="line">    <span class="comment">// 期待第一个token是`package`关键字，该方法内会执行parser.next方法，前进到下一个token</span></span><br><span class="line">	pos := p.expect(token.PACKAGE) </span><br><span class="line">	<span class="comment">// 解析当前的token为标识符，也就是包名</span></span><br><span class="line">	ident := p.parseIdent()</span><br><span class="line">	<span class="keyword">if</span> ident.Name == <span class="string">"_"</span> &amp;&amp; p.mode&amp;DeclarationErrors != <span class="number">0</span> &#123;</span><br><span class="line">		p.error(p.pos, <span class="string">"invalid package name _"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 读取`;`，如果没有的话，需要插入一个`;`</span></span><br><span class="line">    <span class="comment">// 也就是说go会自动在语句末尾插入`;`</span></span><br><span class="line">	p.expectSemi()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果前面解析标识符时失败</span></span><br><span class="line">	<span class="keyword">if</span> p.errors.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置topScope</span></span><br><span class="line">    <span class="comment">// scope用于保存当前作用域内声明的符号引用，比如声明的方法、类型或常/变量等</span></span><br><span class="line">	p.openScope()</span><br><span class="line">    <span class="comment">// 设置包作用域</span></span><br><span class="line">	p.pkgScope = p.topScope</span><br><span class="line">    <span class="comment">// 一个源文件是由一系列声明组成的:</span></span><br><span class="line">    <span class="comment">// import声明</span></span><br><span class="line">    <span class="comment">// 方法声明</span></span><br><span class="line">    <span class="comment">// 类型声明</span></span><br><span class="line">    <span class="comment">// 全局常量/变量声明</span></span><br><span class="line">    <span class="comment">// 这里的ast.Decl是这些声明的公共接口</span></span><br><span class="line">	<span class="keyword">var</span> decls []ast.Decl</span><br><span class="line">	<span class="comment">// 如果不是只解析包名</span></span><br><span class="line">    <span class="keyword">if</span> p.mode&amp;PackageClauseOnly == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 解析导入声明</span></span><br><span class="line">        <span class="comment">// 确保当前token的`import`</span></span><br><span class="line">		<span class="keyword">for</span> p.tok == token.IMPORT &#123;</span><br><span class="line">            <span class="comment">// p.parserImportSpec解析具体的导入声明</span></span><br><span class="line">			decls = <span class="built_in">append</span>(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不是只解析导入声明</span></span><br><span class="line">		<span class="keyword">if</span> p.mode&amp;ImportsOnly == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 解析源代码后面的其他内容</span></span><br><span class="line">			<span class="keyword">for</span> p.tok != token.EOF &#123;</span><br><span class="line">				decls = <span class="built_in">append</span>(decls, p.parseDecl(declStart))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭作用域</span></span><br><span class="line">	p.closeScope()</span><br><span class="line">    <span class="comment">// 确保topScope为nil，否则说明有多余的`&#123;&#125;`没有匹配</span></span><br><span class="line">	assert(p.topScope == <span class="literal">nil</span>, <span class="string">"unbalanced scopes"</span>)</span><br><span class="line">	assert(p.labelScope == <span class="literal">nil</span>, <span class="string">"unbalanced label scopes"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// resolve global identifiers within the same file</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 在包作用域内查找未解析的符号引用，比如在方法内引用了全局的方法，变量等</span></span><br><span class="line">	<span class="keyword">for</span> _, ident := <span class="keyword">range</span> p.unresolved &#123;</span><br><span class="line">		<span class="comment">// i &lt;= index for current ident</span></span><br><span class="line">		assert(ident.Obj == unresolved, <span class="string">"object already resolved"</span>)</span><br><span class="line">		ident.Obj = p.pkgScope.Lookup(ident.Name) <span class="comment">// also removes unresolved sentinel</span></span><br><span class="line">        <span class="comment">// 有的是在同一个包的其他文件中声明的</span></span><br><span class="line">		<span class="keyword">if</span> ident.Obj == <span class="literal">nil</span> &#123;</span><br><span class="line">			p.unresolved[i] = ident</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ast.File&#123;</span><br><span class="line">		Doc:        doc,</span><br><span class="line">		Package:    pos,</span><br><span class="line">		Name:       ident,</span><br><span class="line">		Decls:      decls,</span><br><span class="line">		Scope:      p.pkgScope,</span><br><span class="line">		Imports:    p.imports,</span><br><span class="line">		Unresolved: p.unresolved[<span class="number">0</span>:i],</span><br><span class="line">		Comments:   p.comments,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>decl</code>，包括全局的变量声明，类型声明，函数声明等，具体就不展开了。</p>
<h3 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h3><p>现在来实现一个自动生成<code>tag</code>的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用时需要传入目标源代码路径，目标结构体包含的某个行号和列号</span></span><br><span class="line">	args := os.Args[:<span class="built_in">len</span>(os.Args)]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">4</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"参数：文件路径，行号，列号"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fpath := args[<span class="number">1</span>]</span><br><span class="line">	lineNum, err := strconv.Atoi(args[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"incorrect line number"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// columnNum, err := strconv.Atoi(args[3])</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"incorrect column number"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建FileSet</span></span><br><span class="line">	fset := token.NewFileSet()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析源文件</span></span><br><span class="line">	f, err := parser.ParseFile(fset, fpath, <span class="literal">nil</span>, parser.ParseComments)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"failed to parse file: "</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 全局变量，用来保存找到的目标结构体声明的具体node</span></span><br><span class="line">	<span class="keyword">var</span> target *ast.StructType</span><br><span class="line">    <span class="comment">// 使用Inspect方法遍历ast</span></span><br><span class="line">	ast.Inspect(f, <span class="function"><span class="keyword">func</span><span class="params">(node ast.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="comment">// 如果不是结构体类型声明，跳过，继续下一个遍历</span></span><br><span class="line">		st, ok := node.(*ast.StructType)</span><br><span class="line">        <span class="comment">// 如果不是结构体类型或者类型声明未完成</span></span><br><span class="line">		<span class="keyword">if</span> !ok || st.Incomplete &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是结构体声明，需要包含指定的行和列，这里实际上只要包含实际行就行</span></span><br><span class="line">		begin := fset.Position(st.Pos())</span><br><span class="line">		end := fset.Position(st.End())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到目标struct，返回false，结束遍历</span></span><br><span class="line">		<span class="keyword">if</span> begin.Line &lt;= lineNum &amp;&amp; end.Line &gt;= lineNum &#123;</span><br><span class="line">			target = st <span class="comment">// 设置目标target</span></span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了目标trget</span></span><br><span class="line">	<span class="keyword">if</span> target != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 生成tag，因为结构体声明是可以嵌套的，该方法会递归调用</span></span><br><span class="line">		genTag(target)</span><br><span class="line">        <span class="comment">// 打开目标文件</span></span><br><span class="line">		fd, err := os.OpenFile(fpath, os.O_TRUNC|os.O_RDWR, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> fd.Close()</span><br><span class="line">        <span class="comment">// 使用format.Node方法将ast转换为源文件</span></span><br><span class="line">		err = format.Node(fd, fset, f)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看一下<code>genTag</code>方法，该放方法主要就是遍历声明的字段，为其生成tag然后设置到ast中对应的node上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genTag</span><span class="params">(st *ast.StructType)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历结构体声明的字段列表</span></span><br><span class="line">	fs := st.Fields.List</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> fs &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			tag <span class="keyword">string</span></span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		fd := fs[i]</span><br><span class="line">        <span class="comment">// 如果有指定字段名</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(fd.Names) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			name := fd.Names[<span class="number">0</span>].Name</span><br><span class="line">            <span class="comment">// 只有导出字段才需要生成tag</span></span><br><span class="line">			<span class="keyword">if</span> !isExport(name) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 根据字段名生成tag中的名字，比如NodeId变成node_id</span></span><br><span class="line">			tag = genKey(name)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断字段的类型</span></span><br><span class="line">		<span class="keyword">switch</span> t := fd.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是标识符标识引用了其他声明类型</span></span><br><span class="line">		<span class="keyword">case</span> *ast.Ident:</span><br><span class="line">            <span class="comment">// 如果tag==""表示没有字段名，这时候默认字段名就是类型名</span></span><br><span class="line">            <span class="comment">// 如果类型导出，则生成tag</span></span><br><span class="line">			<span class="keyword">if</span> tag == <span class="string">""</span> &amp;&amp; isExport(t.Name) &#123;</span><br><span class="line">				tag = genKey(t.Name)</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="comment">// 嵌套结构体声明</span></span><br><span class="line">		<span class="keyword">case</span> *ast.StructType:</span><br><span class="line">			<span class="comment">// 递归生成tag</span></span><br><span class="line">            genTag(t)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> tagStr <span class="keyword">string</span></span><br><span class="line">        <span class="comment">// 获取原来的tag</span></span><br><span class="line">		<span class="keyword">if</span> fd.Tag != <span class="literal">nil</span> &#123;</span><br><span class="line">			tagStr = fd.Tag.Value</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 解析tag字符串：`json:"sdf" form:"sdf"`成tag切片</span></span><br><span class="line">		tags, err := parseTag(tagStr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		change := <span class="literal">false</span></span><br><span class="line">		<span class="comment">// 如果已经存在json这个tag，则跳过自动生成</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := tags.Lookup(<span class="string">"json"</span>); !ok &#123;</span><br><span class="line">			tags.Append(<span class="string">"json"</span>, tag)</span><br><span class="line">			change = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果已经生成form这个tag，跳过</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := tags.Lookup(<span class="string">"form"</span>); !ok &#123;</span><br><span class="line">			tags.Append(<span class="string">"form"</span>, tag)</span><br><span class="line">			change = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 如果自动生成了tag</span></span><br><span class="line">		<span class="keyword">if</span> change &#123;</span><br><span class="line">            <span class="comment">// 根据新的tag切片生成tag字符串</span></span><br><span class="line">			tagStr = tags.TagStr()</span><br><span class="line">			<span class="keyword">if</span> fd.Tag == <span class="literal">nil</span> &#123;</span><br><span class="line">				fd.Tag = &amp;ast.BasicLit&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 设置到目标node中</span></span><br><span class="line">			fd.Tag.Kind = token.STRING</span><br><span class="line">			fd.Tag.Value = tagStr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ymcvalu/auto-tag" target="_blank" rel="noopener">完整代码</a></p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
        </div>
    </div>

    
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = 
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>