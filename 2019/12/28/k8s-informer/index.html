<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="gopher">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        k8s informer源码分析 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>can</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kubernetes之Informer"><span class="toc-text">kubernetes之Informer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Informer相关的接口"><span class="toc-text">Informer相关的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#探索informer实现"><span class="toc-text">探索informer实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#启动"><span class="toc-text">启动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解密controller"><span class="toc-text">解密controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflector：ListAndWatch"><span class="toc-text">Reflector：ListAndWatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InformerFactory"><span class="toc-text">InformerFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        k8s informer源码分析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-12-28 22:50:56</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#k8s - informer" title="k8s - informer">k8s - informer</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h1 id="kubernetes之Informer"><a href="#kubernetes之Informer" class="headerlink" title="kubernetes之Informer"></a>kubernetes之Informer</h1><p> <img src="/img/kubernetes-high-level-component-archtecture.jpg" alt=""></p>
<p>我们与<code>k8s</code>集群的交互，主要是通过向<code>api-server</code>提交资源对象。</p>
<p>举个例子，我们要部署一个应用，则只需要提交一个<code>deployment</code>类型的资源对象到<code>api-server</code>。</p>
<p><code>api-server</code>在验证用户提交的资源对象通过之后，会将该资源对象保存到<code>etcd</code>集群中。</p>
<p>同时，<code>api-server</code>还需要通知<code>deployment-manager</code>有一个新的<code>deployment</code>资源对象被新增了，从而能够对它进行处理，比如创建<code>replicaSet</code>。</p>
<p>也就是，在<code>k8s</code>中，需要有一个机制，能够让资源对象的<code>controller</code>能够感知到资源对象。</p>
<p><code>Informer</code>接口就是用于实现该功能。</p>
<p><code>Informer</code>提供了：</p>
<ul>
<li><code>ListAndWatch</code>：用于跟<code>api-server</code>同步资源对象列表和更新</li>
<li>带索引的缓存功能：将资源对象缓存到本地，可以直接通过缓存查询资源对象内容，减轻<code>api-server</code>压力</li>
<li>事件回调功能：提供回调机制，当有资源对象新增、更新或者删除时可以回调自定义接口</li>
</ul>
<p><code>Informer</code>是<code>client-go</code>中一个非常核心的功能，除了在<code>controller-manager</code>、<code>scheduler</code>等组件中被广泛使用，在各种自定义资源对象的控制器中也离不开它的身影。</p>
<p><img src="/img/informer.png" alt=""></p>
<p>上图描述了一个资源对象的控制器的大体工作流程，来自于极客时间的《深入剖析Kubernetes》课程：</p>
<ul>
<li>控制器通过<code>informer</code>与<code>api-server</code>同步资源对象的列表和变更</li>
<li>在事件回调中，将事件加入到<code>workQueue</code>中，这里<code>workQueue</code>可以协调生产者与消费者之间的速率，而且消费失败的事件可以重新加入队列，一般使用限速队列，当消费失败重新加入队列到下次重新消费之前，限速器会根据重试次数产生一定的延时，因为一般消费失败，马上进行重试很大概率还是会失败。</li>
<li>在控制循环中，不断从<code>workQueue</code>取出事件进行处理</li>
</ul>
<p>接下来看一下<code>informer</code>的实现，相关的代码都在<code>k8s.io/client-go/tools/cache</code>包下面</p>
<h3 id="Informer相关的接口"><a href="#Informer相关的接口" class="headerlink" title="Informer相关的接口"></a>Informer相关的接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceEventHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">	OnAdd(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	OnUpdate(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	OnDelete(obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SharedInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 添加一个事件handler</span></span><br><span class="line">	AddEventHandler(handler ResourceEventHandler)</span><br><span class="line">	<span class="comment">// 添加一个事件handler，同时指定resync周期，上一个方法没有指定则使用默认的</span></span><br><span class="line">    <span class="comment">// 如果resync周期大于0，则会定期将本地缓存中的资源对象加入到DeltaFifo中，重新触发事件</span></span><br><span class="line">	AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)</span><br><span class="line">	<span class="comment">// 获取本地缓存</span></span><br><span class="line">	GetStore() Store</span><br><span class="line">	</span><br><span class="line">	GetController() Controller</span><br><span class="line">	<span class="comment">// 开始从apiServer同步资源对象</span></span><br><span class="line">    <span class="comment">// 该方法会阻塞直到stop</span></span><br><span class="line">	Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 是否List已经执行，并且List返回的资源对象已经从DeltaFifo中被pop完</span></span><br><span class="line">	HasSynced() <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 获取最新的资源版本号;k8s依赖于etcd，每个资源对象都有自己的全局唯一的资源版本号，并且是全局递增的</span></span><br><span class="line">	LastSyncResourceVersion() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SharedIndexInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	SharedInformer</span><br><span class="line">	<span class="comment">// 给本地缓存添加索引</span></span><br><span class="line">	AddIndexers(indexers Indexers) error</span><br><span class="line">    <span class="comment">// 获取带索引的本地缓存</span></span><br><span class="line">	GetIndexer() Indexer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="探索informer实现"><a href="#探索informer实现" class="headerlink" title="探索informer实现"></a>探索informer实现</h3><p>接下来，我们看一下<code>SharedIndexInformer</code>接口的实现</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedIndexInformer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 带索引的本地缓存</span></span><br><span class="line">	indexer    Indexer</span><br><span class="line">    <span class="comment">// 控制器，上面图中的Reflector实际上是controller的</span></span><br><span class="line">	controller Controller</span><br><span class="line">	<span class="comment">// 保存事件handler列表，并且分发事件</span></span><br><span class="line">	processor             *sharedProcessor</span><br><span class="line">    <span class="comment">// 用于检测本地缓存中的资源对象是否被更改了</span></span><br><span class="line">    <span class="comment">// 如果更新了本地缓存，则会导致缓存与apiServer的数据不一致</span></span><br><span class="line">    <span class="comment">// 如果我们确实要更新资源对象，则应该先使用DeepCopy获取一个副本，然后在副本上进行更新</span></span><br><span class="line">	cacheMutationDetector MutationDetector</span><br><span class="line">	<span class="comment">// 提供与apiServer交互的ListAndWatch接口</span></span><br><span class="line">	listerWatcher ListerWatcher</span><br><span class="line">    <span class="comment">// 该informer所关注的资源对象的类型</span></span><br><span class="line">	objectType    runtime.Object</span><br><span class="line">    <span class="comment">// 定时检查是否需要resync的周期</span></span><br><span class="line">	resyncCheckPeriod time.Duration</span><br><span class="line">    <span class="comment">// 通过AddEventHandler方法添加事件handler的默认resync周期</span></span><br><span class="line">	defaultEventHandlerResyncPeriod time.Duration</span><br><span class="line">    </span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// 是否已经运行、停止</span></span><br><span class="line">	started, stopped <span class="keyword">bool</span></span><br><span class="line">	startedLock      sync.Mutex</span><br><span class="line">    <span class="comment">// 保护事件handler列表的锁</span></span><br><span class="line">	blockDeltas sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看一下对应的创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSharedInformer creates a new instance for the listwatcher.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedInformer</span><span class="params">(lw ListerWatcher, objType runtime.Object, resyncPeriod time.Duration)</span> <span class="title">SharedInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewSharedIndexInformer(lw, objType, resyncPeriod, Indexers&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSharedIndexInformer creates a new instance for the listwatcher.</span></span><br><span class="line"><span class="comment">// 参数lw提供listAndWatch的接口</span></span><br><span class="line"><span class="comment">// 参数indexers则是本地缓存的索引函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedIndexInformer</span><span class="params">(lw ListerWatcher, objType runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span> <span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	realClock := &amp;clock.RealClock&#123;&#125;</span><br><span class="line">	sharedIndexInformer := &amp;sharedIndexInformer&#123;</span><br><span class="line">        <span class="comment">// 初始化processor</span></span><br><span class="line">		processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,</span><br><span class="line">        <span class="comment">// 创建一个带索引的本地缓存</span></span><br><span class="line">		indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),</span><br><span class="line">        <span class="comment">// listAndWatch接口</span></span><br><span class="line">		listerWatcher:                   lw,</span><br><span class="line">		objectType:                      objType,</span><br><span class="line">		resyncCheckPeriod:               defaultEventHandlerResyncPeriod,</span><br><span class="line">		defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,</span><br><span class="line">        <span class="comment">// 默认是一个空实现</span></span><br><span class="line">		cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class="string">"%T"</span>, objType)),</span><br><span class="line">		clock:                           realClock,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sharedIndexInformer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>NewIndex</code>方法，实际上返回的是一个并发安全的<code>map</code>，同时可以根据<code>indexers</code>中的索引函数来对资源对象进行索引。</p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, s.indexer) <span class="comment">// indexer会作为fifo的knownObjects</span></span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo, <span class="comment">// 先进先出队列</span></span><br><span class="line">		ListerWatcher:    s.listerWatcher,</span><br><span class="line">		ObjectType:       s.objectType,</span><br><span class="line">		FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 该方法会定时调用，判断是否有事件handler需要resync</span></span><br><span class="line">		ShouldResync:     s.processor.shouldResync, <span class="comment">// 是否同步</span></span><br><span class="line">		<span class="comment">// watch到的事件，最终会回调s.HandleDeltas</span></span><br><span class="line">        <span class="comment">// 该方法中会更新本地缓存，然后再通过s.processor将事件分发给注册的事件handler</span></span><br><span class="line">		Process: s.HandleDeltas, </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		<span class="comment">// 创建controller</span></span><br><span class="line">		s.controller = New(cfg) </span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">	processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    <span class="comment">// 后台运行定时脏缓存检查</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">    <span class="comment">// 我们注册的事件handler会被包装成processorListener</span></span><br><span class="line">    <span class="comment">// 后台运行processorListener的pop和run方法，每个processorListener会开两个子协程</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// run controller</span></span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>Run</code>方法中：</p>
<ul>
<li>设置状态为开始运行</li>
<li>创建一个<code>deltaFifo</code>和<code>controller</code></li>
<li>后台运行脏缓存检查</li>
<li>后台为每个<code>processorListener</code>启动<code>pop</code>和<code>run</code>工作协程，开始监听事件。一旦有新的事件到来，会先调用<code>s.HandleDeltas</code>将其更新到本地缓存，然后通过<code>channel</code>通知每个<code>processorListener</code>，<code>processorListener</code>再去回调我们注册的事件handler。</li>
<li>调用<code>controller</code>的<code>Run</code>方法，实际跟<code>api-server</code>的<code>listAndWatch</code>交互是由<code>controller</code>来负责的</li>
</ul>
<h3 id="解密controller"><a href="#解密controller" class="headerlink" title="解密controller"></a>解密controller</h3><p>接下来我们看一下<code>controller</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller is a generic controller framework.</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 开始运行</span></span><br><span class="line">	Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// Informer的HasSynced的实现</span></span><br><span class="line">	HasSynced() <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Informer的LastSyncResourceVersion的实现</span></span><br><span class="line">	LastSyncResourceVersion() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Controller is a generic controller framework.</span></span><br><span class="line"><span class="keyword">type</span> controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         Config</span><br><span class="line">	reflector      *Reflector</span><br><span class="line">	reflectorMutex sync.RWMutex</span><br><span class="line">	clock          clock.Clock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New makes a new Controller from the given Config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(c *Config)</span> <span class="title">Controller</span></span> &#123;</span><br><span class="line">	ctlr := &amp;controller&#123;</span><br><span class="line">		config: *c,</span><br><span class="line">		clock:  &amp;clock.RealClock&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctlr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下主要的<code>Run</code>方法的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个Reflector</span></span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.clock = c.clock</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line">	<span class="comment">// 后台开始运行r.Run</span></span><br><span class="line">    <span class="comment">// 该方法会执行ListAndWatch，并且定时触发resync检查</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">	<span class="comment">// 运行c.processLoop，直到stop</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下<code>processLoop</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的Queue，就是上面在s.Run里面创建的DeltaFifo</span></span><br><span class="line">        <span class="comment">// Process实际上就是s.HandleDeltas</span></span><br><span class="line">        <span class="comment">// ListAndWatch产生的事件会添加到DeltaFifo中，该方法不断从队列获取事件并回调Process</span></span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == ErrFIFOClosed &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 如果需要重试，则重新加入队列中</span></span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reflector：ListAndWatch"><a href="#Reflector：ListAndWatch" class="headerlink" title="Reflector：ListAndWatch"></a>Reflector：ListAndWatch</h3><p>我们接下来看一下<code>Reflector</code>的主要逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">3</span>).Infof(<span class="string">"Starting reflector %v (%s) from %s"</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">	wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 终于看到调用ListAndWatch了</span></span><br><span class="line">		<span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, r.period, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下<code>ListAndWatch</code>方法，该方法有点长，只保留相关代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> 	<span class="keyword">var</span> resourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	options := metav1.ListOptions&#123;ResourceVersion: r.relistResourceVersion()&#125;</span><br><span class="line">	<span class="comment">// 执行List</span></span><br><span class="line">	<span class="keyword">if</span> err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> list runtime.Object</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		listCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			pager := pager.New(pager.SimplePageFunc(<span class="function"><span class="keyword">func</span><span class="params">(opts metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> r.listerWatcher.List(opts)</span><br><span class="line">			&#125;))</span><br><span class="line">			<span class="keyword">if</span> r.WatchListPageSize != <span class="number">0</span> &#123;</span><br><span class="line">				pager.PageSize = r.WatchListPageSize</span><br><span class="line">			&#125;			</span><br><span class="line">            <span class="comment">// 获取list列表</span></span><br><span class="line">			list, err = pager.List(context.Background(), options)</span><br><span class="line">			<span class="built_in">close</span>(listCh)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-listCh:</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">		resourceVersion = listMetaInterface.GetResourceVersion()</span><br><span class="line"> 		items, err := meta.ExtractList(list)</span><br><span class="line">        <span class="comment">// 会调用DeltaFifo的Replace接口，替换掉DeltaFifo的内容</span></span><br><span class="line"> 		<span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"%s: Unable to sync list result: %v"</span>, r.name, err)</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="comment">// 更新已经同步的资源版本</span></span><br><span class="line">		r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 定时触发resync检查</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		resyncCh, cleanup := r.resyncChan()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			cleanup() <span class="comment">// Call the last one written into cleanup</span></span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-resyncCh:</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-cancelCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// ShouldResync会检查是否需要触发resync</span></span><br><span class="line">			<span class="keyword">if</span> r.ShouldResync == <span class="literal">nil</span> || r.ShouldResync() &#123;</span><br><span class="line">                <span class="comment">// 如果需要触发resync，则调用DeltaFifo的Resync</span></span><br><span class="line">				<span class="keyword">if</span> err := r.store.Resync(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					resyncerrc &lt;- err</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cleanup()</span><br><span class="line">			resyncCh, cleanup = r.resyncChan()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始Watch</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		timeoutSeconds := <span class="keyword">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="number">1.0</span>))</span><br><span class="line">		</span><br><span class="line">		options = metav1.ListOptions&#123;</span><br><span class="line">			ResourceVersion: resourceVersion,</span><br><span class="line">			TimeoutSeconds: &amp;timeoutSeconds,</span><br><span class="line">			AllowWatchBookmarks: <span class="literal">true</span>,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w, err := r.listerWatcher.Watch(options)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> utilnet.IsConnectionRefused(err) &#123;</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理watch到的事件</span></span><br><span class="line">		<span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>watch</code>的主要逻辑都在<code>watchHandler</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	start := r.clock.Now()</span><br><span class="line">	eventCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> w.Stop()</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> errorStopRequested</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">			<span class="comment">// watch事件</span></span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line">		 </span><br><span class="line">			meta, err := meta.Accessor(event.Object)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取对应的资源版本</span></span><br><span class="line">			newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">			<span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">			<span class="comment">// 新增事件</span></span><br><span class="line">			<span class="keyword">case</span> watch.Added:</span><br><span class="line">				<span class="comment">// 调用DeltaFifo的Add接口</span></span><br><span class="line">				err := r.store.Add(event.Object)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to add watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 更新事件</span></span><br><span class="line">			<span class="keyword">case</span> watch.Modified:</span><br><span class="line">				<span class="comment">// 调用DeltaFifo的Update接口</span></span><br><span class="line">				err := r.store.Update(event.Object)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to update watch event object (%#v) to store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 删除事件</span></span><br><span class="line">			<span class="keyword">case</span> watch.Deleted:</span><br><span class="line">				err := r.store.Delete(event.Object)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to delete watch event object (%#v) from store: %v"</span>, r.name, event.Object, err))</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> watch.Bookmark:</span><br><span class="line">				<span class="comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%s: unable to understand watch event %#v"</span>, r.name, event))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 更新最后同步的资源版本</span></span><br><span class="line">			*resourceVersion = newResourceVersion</span><br><span class="line">			r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">			eventCount++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InformerFactory"><a href="#InformerFactory" class="headerlink" title="InformerFactory"></a>InformerFactory</h3><p><code>client-go</code>还提供了一个<code>SharedInformerFactory</code>，方便我们创建（多个）<code>Informer</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以看到，<code>Reflector</code>会通过<code>ListAndWatch</code>接口，从<code>api-server</code>同步资源对象的变更情况，然后添加到<code>DeltaFifo</code>队列中；</p>
<p><code>controller</code>会不断从<code>DeltaFifo</code>中取出事件，然后回调<code>sharedIndexInformer</code>的<code>HandleDeltas</code>方法；</p>
<p><code>HandleDeltas</code>方法中，会更新本地缓存，然后根据事件类型调用注册的事件handler。</p>
<p>还要一些细节，比如<code>DeltaFifo</code>，<code>Indexer</code>，<code>processorListener</code>的实现，或者<code>Informer</code>的<code>HasSynced</code>接口实现等，比较简单就不在讲了。</p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
   <!-- <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p> -->
</footer>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.6}});</script></body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
